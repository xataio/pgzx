var comptimeExprs =[{"code":"T"},{"code":"func call"},{"code":"if (alignment) |a| ([]align(a) T) else []T"},{"code":"T"},{"code":"if (alignment) |a| ([:s]align(a) T) else [:s]T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"sentinel"},{"code":"T"},{"code":"alignment"},{"code":"func call"},{"code":"T"},{"code":"sentinel"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (T != u8)\n            @compileError(\"The Writer interface is only defined for ArrayList(u8) \" ++\n                \"but the given type is ArrayList(\" ++ @typeName(T) ++ \")\")\n        else\n            std.io.Writer(*Self, Allocator.Error, appendWrite)"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"n"},{"code":"T"},{"code":"n"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"if (alignment) |a| ([]align(a) T) else []T"},{"code":"T"},{"code":"if (alignment) |a| ([:s]align(a) T) else [:s]T"},{"code":"T"},{"code":"alignment"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"sentinel"},{"code":"T"},{"code":"sentinel"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (T != u8)\n            @compileError(\"The Writer interface is only defined for ArrayList(u8) \" ++\n                \"but the given type is ArrayList(\" ++ @typeName(T) ++ \")\")\n        else\n            std.io.Writer(WriterContext, Allocator.Error, appendWrite)"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"n"},{"code":"T"},{"code":"n"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"T"},{"code":"block_comptime"},{"code":"buffer_capacity"},{"code":"func call"},{"code":"buffer_capacity"},{"code":"field call"},{"code":"self"},{"code":"switch (@TypeOf(&self.buffer)) {\n            *align(alignment) [buffer_capacity]T => []align(alignment) T,\n            *align(alignment) const [buffer_capacity]T => []align(alignment) const T,\n            else => unreachable,\n        }"},{"code":"T"},{"code":"alignment"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"n"},{"code":"T"},{"code":"alignment"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"alignment"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (T != u8)\n            @compileError(\"The Writer interface is only defined for BoundedArray(u8, ...) \" ++\n                \"but the given type is BoundedArray(\" ++ @typeName(T) ++ \", ...)\")\n        else\n            std.io.Writer(*Self, error{Overflow}, appendWrite)"},{"code":"buffer_capacity"},{"code":"T"},{"code":"std.SemanticVersion.parse(zig_version_string) catch unreachable"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"writer"},{"code":"writer"},{"code":"field call"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"field call"},{"code":"id"},{"code":"switch (id) {\n            .top_level => Build.TopLevelStep,\n            .compile => Compile,\n            .install_artifact => InstallArtifact,\n            .install_file => InstallFile,\n            .install_dir => InstallDir,\n            .remove_dir => RemoveDir,\n            .fmt => Fmt,\n            .translate_c => TranslateC,\n            .write_file => WriteFile,\n            .run => Run,\n            .check_file => CheckFile,\n            .check_object => CheckObject,\n            .config_header => ConfigHeader,\n            .objcopy => ObjCopy,\n            .options => Options,\n            .custom => @compileError(\"no type available for custom step\"),\n        }"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"switch (builtin.cpu.arch) {\n    .wasm32, .wasm64 => 64 * 1024,\n    .aarch64 => switch (builtin.os.tag) {\n        .macos, .ios, .watchos, .tvos => 16 * 1024,\n        else => 4 * 1024,\n    },\n    .sparc64 => 8 * 1024,\n    else => 4 * 1024,\n}"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"Elem"},{"code":"Elem"},{"code":"optional_alignment"},{"code":"optional_sentinel"},{"code":"func call"},{"code":"Elem"},{"code":"Elem"},{"code":"optional_alignment"},{"code":"optional_sentinel"},{"code":"func call"},{"code":"Elem"},{"code":"Elem"},{"code":"Elem"},{"code":"Elem"},{"code":"sentinel"},{"code":"T"},{"code":"alignment orelse @alignOf(T)"},{"code":"T"},{"code":"alignment orelse @alignOf(T)"},{"code":"alignment"},{"code":"alignment"},{"code":"t: {\n    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;\n    break :t Error![]align(Slice.alignment) Slice.child;\n}"},{"code":"t: {\n    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;\n    break :t Error![]align(Slice.alignment) Slice.child;\n}"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"switch (@typeInfo(@TypeOf(x))) {\n    .Int => math.Log2Int(@TypeOf(x)),\n    .ComptimeInt => comptime_int,\n    else => @compileError(\"int please\"),\n}"},{"code":"T"},{"code":"T"},{"code":"allocator"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (builtin.zig_backend) {\n    // The SPIR-V backend does not support the optimized path yet.\n    .stage2_spirv64 => false,\n    else => true,\n}"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"ptr"},{"code":"func call"},{"code":"T"},{"code":"field call"},{"code":"ptr"},{"code":"field call"},{"code":"ptr"},{"code":"end"},{"code":"func call"},{"code":"ptr"},{"code":"field call"},{"code":"switch (builtin.zig_backend) {\n    .stage2_llvm, .stage2_c => true,\n    else => false,\n}"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"sentinel"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"ReturnType"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (native_endian) {\n    .little => readPackedIntLittle,\n    .big => readPackedIntBig,\n}"},{"code":"switch (native_endian) {\n    .little => readPackedIntBig,\n    .big => readPackedIntLittle,\n}"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (native_endian) {\n    .little => writePackedIntLittle,\n    .big => writePackedIntBig,\n}"},{"code":"switch (native_endian) {\n    .little => writePackedIntBig,\n    .big => writePackedIntLittle,\n}"},{"code":"T"},{"code":"S"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"delimiter_type"},{"code":"switch (delimiter_type) {\n            .sequence, .any => []const T,\n            .scalar => T,\n        }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"delimiter_type"},{"code":"switch (delimiter_type) {\n            .sequence, .any => []const T,\n            .scalar => T,\n        }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"delimiter_type"},{"code":"switch (delimiter_type) {\n            .sequence, .any => []const T,\n            .scalar => T,\n        }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"s"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"reverseIterator(\"abc\")"},{"code":"field call"},{"code":"3"},{"code":"[2]i32"},{"code":"slice"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"ptr"},{"code":"struct_init_field_type"},{"code":"size"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"child"},{"code":"P"},{"code":"block_comptime"},{"code":"func call"},{"code":"ptr"},{"code":"func call"},{"code":"value"},{"code":"B"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"bytes"},{"code":"func call"},{"code":"T"},{"code":"bytesType"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"bytes"},{"code":"func call"},{"code":"Slice"},{"code":"func call"},{"code":"slice"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (builtin.zig_backend == .stage2_c) u8 else void"},{"code":"if (builtin.zig_backend == .stage2_c) u8 else void"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"struct_init_field_type"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"new_alignment"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"new_alignment"},{"code":"slice"},{"code":"new_alignment"},{"code":"func call"},{"code":"func call"},{"code":"switch (builtin.os.tag) {\n        .windows => windows.HANDLE,\n        .wasi => void,\n        else => os.pid_t,\n    }"},{"code":"switch (builtin.os.tag) {\n            .linux, .macos, .ios => @as(?std.os.rusage, null),\n            .windows => @as(?windows.VM_COUNTERS, null),\n            else => {},\n        }"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.os.tag == .windows) windows.HANDLE else void"},{"code":"if (builtin.os.tag == .windows or builtin.os.tag == .wasi) void else ?os.uid_t"},{"code":"if (builtin.os.tag == .windows or builtin.os.tag == .wasi) void else ?os.gid_t"},{"code":"if (builtin.os.tag == .windows) void else [2]os.fd_t"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (builtin.os.tag) {\n    .linux => if (!builtin.link_libc or builtin.abi == .musl and builtin.link_mode == .Static)\n        ElfDynLib\n    else\n        DlDynLib,\n    .windows => WindowsDynLib,\n    .macos, .tvos, .watchos, .ios, .freebsd, .netbsd, .openbsd, .dragonfly, .solaris, .illumos => DlDynLib,\n    else => void,\n}"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (@typeInfo(T)) {\n            .Struct => T,\n            .Union => |u| struct {\n                pub const Bare =\n                    @Type(.{ .Union = .{\n                    .layout = u.layout,\n                    .tag_type = null,\n                    .fields = u.fields,\n                    .decls = &.{},\n                } });\n                pub const Tag =\n                    u.tag_type orelse @compileError(\"MultiArrayList does not support untagged unions\");\n                tags: Tag,\n                data: Bare,\n\n                pub fn fromT(outer: T) @This() {\n                    const tag = meta.activeTag(outer);\n                    return .{\n                        .tags = tag,\n                        .data = switch (tag) {\n                            inline else => |t| @unionInit(Bare, @tagName(t), @field(outer, @tagName(t))),\n                        },\n                    };\n                }\n                pub fn toT(tag: Tag, bare: Bare) T {\n                    return switch (tag) {\n                        inline else => |t| @unionInit(T, @tagName(t), @field(bare, @tagName(t))),\n                    };\n                }\n            },\n            else => @compileError(\"MultiArrayList only supports structs and tagged unions\"),\n        }"},{"code":"field call"},{"code":"field"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"blk: {\n            const Data = struct {\n                size: usize,\n                size_index: usize,\n                alignment: usize,\n            };\n            var data: [fields.len]Data = undefined;\n            for (fields, 0..) |field_info, i| {\n                data[i] = .{\n                    .size = @sizeOf(field_info.type),\n                    .size_index = i,\n                    .alignment = if (@sizeOf(field_info.type) == 0) 1 else field_info.alignment,\n                };\n            }\n            const Sort = struct {\n                fn lessThan(context: void, lhs: Data, rhs: Data) bool {\n                    _ = context;\n                    return lhs.alignment > rhs.alignment;\n                }\n            };\n            mem.sort(Data, &data, {}, Sort.lessThan);\n            var sizes_bytes: [fields.len]usize = undefined;\n            var field_indexes: [fields.len]usize = undefined;\n            for (data, 0..) |elem, i| {\n                sizes_bytes[i] = elem.size;\n                field_indexes[i] = elem.size_index;\n            }\n            break :blk .{\n                .bytes = sizes_bytes,\n                .fields = field_indexes,\n            };\n        }"},{"code":"field"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"entry: {\n            var entry_fields: [fields.len]std.builtin.Type.StructField = undefined;\n            for (&entry_fields, sizes.fields) |*entry_field, i| entry_field.* = .{\n                .name = fields[i].name ++ \"_ptr\",\n                .type = *fields[i].type,\n                .default_value = null,\n                .is_comptime = fields[i].is_comptime,\n                .alignment = fields[i].alignment,\n            };\n            break :entry @Type(.{ .Struct = .{\n                .layout = .Extern,\n                .fields = &entry_fields,\n                .decls = &.{},\n                .is_tuple = false,\n            } });\n        }"},{"code":"T"},{"code":"field call"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"endian"},{"code":"func call"},{"code":"NewInt"},{"code":"new_endian"},{"code":"func call"},{"code":"Int"},{"code":"int_count"},{"code":"func call"},{"code":"Int"},{"code":"int_count"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"endian"},{"code":"func call"},{"code":"NewInt"},{"code":"func call"},{"code":"NewInt"},{"code":"new_endian"},{"code":"func call"},{"code":"block_comptime"},{"code":"int_count"},{"code":"int_count"},{"code":"Int"},{"code":"func call"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"Int"},{"code":"endian"},{"code":"func call"},{"code":"NewInt"},{"code":"endian"},{"code":"func call"},{"code":"NewInt"},{"code":"new_endian"},{"code":"func call"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"compareFn"},{"code":"func call"},{"code":"T"},{"code":"Context"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"Context"},{"code":"compareFn"},{"code":"func call"},{"code":"T"},{"code":"Context"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"blk: {\n    @setEvalBranchQuota(30000);\n    break :blk ZigTableGen(true, norm_r, norm_v, norm_f, norm_f_inv, norm_zero_case);\n}"},{"code":"blk: {\n    @setEvalBranchQuota(30000);\n    break :blk ZigTableGen(false, exp_r, exp_v, exp_f, exp_f_inv, exp_zero_case);\n}"},{"code":"pointer"},{"code":"EnumType"},{"code":"EnumType"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (index_info.bits >= @typeInfo(usize).Int.bits) usize else Index"},{"code":"field call"},{"code":"blk: {\n            // we don't use the prealloc_exp constant when prealloc_item_count is 0\n            // but lazy-init may still be triggered by other code so supply a value\n            if (prealloc_item_count == 0) {\n                break :blk 0;\n            } else {\n                assert(std.math.isPowerOfTwo(prealloc_item_count));\n                const value = std.math.log2_int(usize, prealloc_item_count);\n                break :blk value;\n            }\n        }"},{"code":"prealloc_item_count"},{"code":"self"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"self"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"ElementPtr"},{"code":"ElementPtr"},{"code":"ElementPtr"},{"code":"SelfType"},{"code":"prealloc_item_count"},{"code":"T"},{"code":"T"},{"code":"coerce_ptr_elem_ty"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"blk: {\n    @setEvalBranchQuota(2000);\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.a510)] = .{\n        .llvm_name = \"a510\",\n        .description = \"Cortex-A510 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .fuse_adrp_add,\n            .fuse_aes,\n            .use_postra_scheduler,\n        }),\n    };\n    result[@intFromEnum(Feature.a65)] = .{\n        .llvm_name = \"a65\",\n        .description = \"Cortex-A65 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .enable_select_opt,\n            .fuse_address,\n            .fuse_adrp_add,\n            .fuse_aes,\n            .fuse_literals,\n            .predictable_select_expensive,\n        }),\n    };\n    result[@intFromEnum(Feature.a710)] = .{\n        .llvm_name = \"a710\",\n        .description = \"Cortex-A710 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .cmp_bcc_fusion,\n            .enable_select_opt,\n            .fuse_adrp_add,\n            .fuse_aes,\n            .lsl_fast,\n            .predictable_select_expensive,\n            .use_postra_scheduler,\n        }),\n    };\n    result[@intFromEnum(Feature.a76)] = .{\n        .llvm_name = \"a76\",\n        .description = \"Cortex-A76 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .enable_select_opt,\n            .fuse_adrp_add,\n            .fuse_aes,\n            .lsl_fast,\n            .predictable_select_expensive,\n        }),\n    };\n    result[@intFromEnum(Feature.a78)] = .{\n        .llvm_name = \"a78\",\n        .description = \"Cortex-A78 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .cmp_bcc_fusion,\n            .enable_select_opt,\n            .fuse_adrp_add,\n            .fuse_aes,\n            .lsl_fast,\n            .predictable_select_expensive,\n            .use_postra_scheduler,\n        }),\n    };\n    result[@intFromEnum(Feature.a78c)] = .{\n        .llvm_name = \"a78c\",\n        .description = \"Cortex-A78C ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .cmp_bcc_fusion,\n            .enable_select_opt,\n            .fuse_adrp_add,\n            .fuse_aes,\n            .lsl_fast,\n            .predictable_select_expensive,\n            .use_postra_scheduler,\n        }),\n    };\n    result[@intFromEnum(Feature.aes)] = .{\n        .llvm_name = \"aes\",\n        .description = \"Enable AES support (FEAT_AES, FEAT_PMULL)\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.aggressive_fma)] = .{\n        .llvm_name = \"aggressive-fma\",\n        .description = \"Enable Aggressive FMA for floating-point.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.alternate_sextload_cvt_f32_pattern)] = .{\n        .llvm_name = \"alternate-sextload-cvt-f32-pattern\",\n        .description = \"Use alternative pattern for sextload convert to f32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.altnzcv)] = .{\n        .llvm_name = \"altnzcv\",\n        .description = \"Enable alternative NZCV format for floating point comparisons (FEAT_FlagM2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.am)] = .{\n        .llvm_name = \"am\",\n        .description = \"Enable v8.4-A Activity Monitors extension (FEAT_AMUv1)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.amvs)] = .{\n        .llvm_name = \"amvs\",\n        .description = \"Enable v8.6-A Activity Monitors Virtualization support (FEAT_AMUv1p1)\",\n        .dependencies = featureSet(&[_]Feature{\n            .am,\n        }),\n    };\n    result[@intFromEnum(Feature.arith_bcc_fusion)] = .{\n        .llvm_name = \"arith-bcc-fusion\",\n        .description = \"CPU fuses arithmetic+bcc operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.arith_cbz_fusion)] = .{\n        .llvm_name = \"arith-cbz-fusion\",\n        .description = \"CPU fuses arithmetic + cbz/cbnz operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ascend_store_address)] = .{\n        .llvm_name = \"ascend-store-address\",\n        .description = \"Schedule vector stores by ascending address\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.b16b16)] = .{\n        .llvm_name = \"b16b16\",\n        .description = \"Enable SVE2.1 or SME2.1 non-widening BFloat16 to BFloat16 instructions (FEAT_B16B16)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.balance_fp_ops)] = .{\n        .llvm_name = \"balance-fp-ops\",\n        .description = \"balance mix of odd and even D-registers for fp multiply(-accumulate) ops\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.bf16)] = .{\n        .llvm_name = \"bf16\",\n        .description = \"Enable BFloat16 Extension (FEAT_BF16)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.brbe)] = .{\n        .llvm_name = \"brbe\",\n        .description = \"Enable Branch Record Buffer Extension (FEAT_BRBE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.bti)] = .{\n        .llvm_name = \"bti\",\n        .description = \"Enable Branch Target Identification (FEAT_BTI)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x10)] = .{\n        .llvm_name = \"call-saved-x10\",\n        .description = \"Make X10 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x11)] = .{\n        .llvm_name = \"call-saved-x11\",\n        .description = \"Make X11 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x12)] = .{\n        .llvm_name = \"call-saved-x12\",\n        .description = \"Make X12 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x13)] = .{\n        .llvm_name = \"call-saved-x13\",\n        .description = \"Make X13 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x14)] = .{\n        .llvm_name = \"call-saved-x14\",\n        .description = \"Make X14 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x15)] = .{\n        .llvm_name = \"call-saved-x15\",\n        .description = \"Make X15 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x18)] = .{\n        .llvm_name = \"call-saved-x18\",\n        .description = \"Make X18 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x8)] = .{\n        .llvm_name = \"call-saved-x8\",\n        .description = \"Make X8 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.call_saved_x9)] = .{\n        .llvm_name = \"call-saved-x9\",\n        .description = \"Make X9 callee saved.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ccdp)] = .{\n        .llvm_name = \"ccdp\",\n        .description = \"Enable v8.5 Cache Clean to Point of Deep Persistence (FEAT_DPB2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ccidx)] = .{\n        .llvm_name = \"ccidx\",\n        .description = \"Enable v8.3-A Extend of the CCSIDR number of sets (FEAT_CCIDX)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ccpp)] = .{\n        .llvm_name = \"ccpp\",\n        .description = \"Enable v8.2 data Cache Clean to Point of Persistence (FEAT_DPB)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.chk)] = .{\n        .llvm_name = \"chk\",\n        .description = \"Enable Armv8.0-A Check Feature Status Extension (FEAT_CHK)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.clrbhb)] = .{\n        .llvm_name = \"clrbhb\",\n        .description = \"Enable Clear BHB instruction (FEAT_CLRBHB)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cmp_bcc_fusion)] = .{\n        .llvm_name = \"cmp-bcc-fusion\",\n        .description = \"CPU fuses cmp+bcc operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.complxnum)] = .{\n        .llvm_name = \"complxnum\",\n        .description = \"Enable v8.3-A Floating-point complex number support (FEAT_FCMA)\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.contextidr_el2)] = .{\n        .llvm_name = \"CONTEXTIDREL2\",\n        .description = \"Enable RW operand Context ID Register (EL2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cortex_r82)] = .{\n        .llvm_name = \"cortex-r82\",\n        .description = \"Cortex-R82 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .use_postra_scheduler,\n        }),\n    };\n    result[@intFromEnum(Feature.crc)] = .{\n        .llvm_name = \"crc\",\n        .description = \"Enable ARMv8 CRC-32 checksum instructions (FEAT_CRC32)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crypto)] = .{\n        .llvm_name = \"crypto\",\n        .description = \"Enable cryptographic instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .aes,\n            .sha2,\n        }),\n    };\n    result[@intFromEnum(Feature.cssc)] = .{\n        .llvm_name = \"cssc\",\n        .description = \"Enable Common Short Sequence Compression (CSSC) instructions (FEAT_CSSC)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.custom_cheap_as_move)] = .{\n        .llvm_name = \"custom-cheap-as-move\",\n        .description = \"Use custom handling of cheap instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.d128)] = .{\n        .llvm_name = \"d128\",\n        .description = \"Enable Armv9.4-A 128-bit Page Table Descriptors, System Registers and Instructions (FEAT_D128, FEAT_LVA3, FEAT_SYSREG128, FEAT_SYSINSTR128)\",\n        .dependencies = featureSet(&[_]Feature{\n            .lse128,\n        }),\n    };\n    result[@intFromEnum(Feature.disable_latency_sched_heuristic)] = .{\n        .llvm_name = \"disable-latency-sched-heuristic\",\n        .description = \"Disable latency scheduling heuristic\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dit)] = .{\n        .llvm_name = \"dit\",\n        .description = \"Enable v8.4-A Data Independent Timing instructions (FEAT_DIT)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dotprod)] = .{\n        .llvm_name = \"dotprod\",\n        .description = \"Enable dot product support (FEAT_DotProd)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ecv)] = .{\n        .llvm_name = \"ecv\",\n        .description = \"Enable enhanced counter virtualization extension (FEAT_ECV)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.el2vmsa)] = .{\n        .llvm_name = \"el2vmsa\",\n        .description = \"Enable Exception Level 2 Virtual Memory System Architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.el3)] = .{\n        .llvm_name = \"el3\",\n        .description = \"Enable Exception Level 3\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.enable_select_opt)] = .{\n        .llvm_name = \"enable-select-opt\",\n        .description = \"Enable the select optimize pass for select loop heuristics\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ete)] = .{\n        .llvm_name = \"ete\",\n        .description = \"Enable Embedded Trace Extension (FEAT_ETE)\",\n        .dependencies = featureSet(&[_]Feature{\n            .trbe,\n        }),\n    };\n    result[@intFromEnum(Feature.exynos_cheap_as_move)] = .{\n        .llvm_name = \"exynos-cheap-as-move\",\n        .description = \"Use Exynos specific handling of cheap instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .custom_cheap_as_move,\n        }),\n    };\n    result[@intFromEnum(Feature.f32mm)] = .{\n        .llvm_name = \"f32mm\",\n        .description = \"Enable Matrix Multiply FP32 Extension (FEAT_F32MM)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sve,\n        }),\n    };\n    result[@intFromEnum(Feature.f64mm)] = .{\n        .llvm_name = \"f64mm\",\n        .description = \"Enable Matrix Multiply FP64 Extension (FEAT_F64MM)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sve,\n        }),\n    };\n    result[@intFromEnum(Feature.fgt)] = .{\n        .llvm_name = \"fgt\",\n        .description = \"Enable fine grained virtualization traps extension (FEAT_FGT)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fix_cortex_a53_835769)] = .{\n        .llvm_name = \"fix-cortex-a53-835769\",\n        .description = \"Mitigate Cortex-A53 Erratum 835769\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flagm)] = .{\n        .llvm_name = \"flagm\",\n        .description = \"Enable v8.4-A Flag Manipulation Instructions (FEAT_FlagM)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fmv)] = .{\n        .llvm_name = \"fmv\",\n        .description = \"Enable Function Multi Versioning support.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.force_32bit_jump_tables)] = .{\n        .llvm_name = \"force-32bit-jump-tables\",\n        .description = \"Force jump table entries to be 32-bits wide except at MinSize\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp16fml)] = .{\n        .llvm_name = \"fp16fml\",\n        .description = \"Enable FP16 FML instructions (FEAT_FHM)\",\n        .dependencies = featureSet(&[_]Feature{\n            .fullfp16,\n        }),\n    };\n    result[@intFromEnum(Feature.fp_armv8)] = .{\n        .llvm_name = \"fp-armv8\",\n        .description = \"Enable ARMv8 FP (FEAT_FP)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fptoint)] = .{\n        .llvm_name = \"fptoint\",\n        .description = \"Enable FRInt[32|64][Z|X] instructions that round a floating-point number to an integer (in FP format) forcing it to fit into a 32- or 64-bit int (FEAT_FRINTTS)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fullfp16)] = .{\n        .llvm_name = \"fullfp16\",\n        .description = \"Full FP16 (FEAT_FP16)\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_address)] = .{\n        .llvm_name = \"fuse-address\",\n        .description = \"CPU fuses address generation and memory operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_addsub_2reg_const1)] = .{\n        .llvm_name = \"fuse-addsub-2reg-const1\",\n        .description = \"CPU fuses (a + b + 1) and (a - b - 1)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_adrp_add)] = .{\n        .llvm_name = \"fuse-adrp-add\",\n        .description = \"CPU fuses adrp+add operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_aes)] = .{\n        .llvm_name = \"fuse-aes\",\n        .description = \"CPU fuses AES crypto operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_arith_logic)] = .{\n        .llvm_name = \"fuse-arith-logic\",\n        .description = \"CPU fuses arithmetic and logic operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_crypto_eor)] = .{\n        .llvm_name = \"fuse-crypto-eor\",\n        .description = \"CPU fuses AES/PMULL and EOR operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_csel)] = .{\n        .llvm_name = \"fuse-csel\",\n        .description = \"CPU fuses conditional select operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_literals)] = .{\n        .llvm_name = \"fuse-literals\",\n        .description = \"CPU fuses literal generation operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gcs)] = .{\n        .llvm_name = \"gcs\",\n        .description = \"Enable Armv9.4-A Guarded Call Stack Extension\",\n        .dependencies = featureSet(&[_]Feature{\n            .chk,\n        }),\n    };\n    result[@intFromEnum(Feature.harden_sls_blr)] = .{\n        .llvm_name = \"harden-sls-blr\",\n        .description = \"Harden against straight line speculation across BLR instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_nocomdat)] = .{\n        .llvm_name = \"harden-sls-nocomdat\",\n        .description = \"Generate thunk code for SLS mitigation in the normal text section\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_retbr)] = .{\n        .llvm_name = \"harden-sls-retbr\",\n        .description = \"Harden against straight line speculation across RET and BR instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hbc)] = .{\n        .llvm_name = \"hbc\",\n        .description = \"Enable Armv8.8-A Hinted Conditional Branches Extension (FEAT_HBC)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hcx)] = .{\n        .llvm_name = \"hcx\",\n        .description = \"Enable Armv8.7-A HCRX_EL2 system register (FEAT_HCX)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.i8mm)] = .{\n        .llvm_name = \"i8mm\",\n        .description = \"Enable Matrix Multiply Int8 Extension (FEAT_I8MM)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ite)] = .{\n        .llvm_name = \"ite\",\n        .description = \"Enable Armv9.4-A Instrumentation Extension FEAT_ITE\",\n        .dependencies = featureSet(&[_]Feature{\n            .ete,\n        }),\n    };\n    result[@intFromEnum(Feature.jsconv)] = .{\n        .llvm_name = \"jsconv\",\n        .description = \"Enable v8.3-A JavaScript FP conversion instructions (FEAT_JSCVT)\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8,\n        }),\n    };\n    result[@intFromEnum(Feature.lor)] = .{\n        .llvm_name = \"lor\",\n        .description = \"Enables ARM v8.1 Limited Ordering Regions extension (FEAT_LOR)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ls64)] = .{\n        .llvm_name = \"ls64\",\n        .description = \"Enable Armv8.7-A LD64B/ST64B Accelerator Extension (FEAT_LS64, FEAT_LS64_V, FEAT_LS64_ACCDATA)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lse)] = .{\n        .llvm_name = \"lse\",\n        .description = \"Enable ARMv8.1 Large System Extension (LSE) atomic instructions (FEAT_LSE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lse128)] = .{\n        .llvm_name = \"lse128\",\n        .description = \"Enable Armv9.4-A 128-bit Atomic Instructions (FEAT_LSE128)\",\n        .dependencies = featureSet(&[_]Feature{\n            .lse,\n        }),\n    };\n    result[@intFromEnum(Feature.lse2)] = .{\n        .llvm_name = \"lse2\",\n        .description = \"Enable ARMv8.4 Large System Extension 2 (LSE2) atomicity rules (FEAT_LSE2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lsl_fast)] = .{\n        .llvm_name = \"lsl-fast\",\n        .description = \"CPU has a fastpath logical shift of up to 3 places\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mec)] = .{\n        .llvm_name = \"mec\",\n        .description = \"Enable Memory Encryption Contexts Extension\",\n        .dependencies = featureSet(&[_]Feature{\n            .rme,\n        }),\n    };\n    result[@intFromEnum(Feature.mops)] = .{\n        .llvm_name = \"mops\",\n        .description = \"Enable Armv8.8-A memcpy and memset acceleration instructions (FEAT_MOPS)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mpam)] = .{\n        .llvm_name = \"mpam\",\n        .description = \"Enable v8.4-A Memory system Partitioning and Monitoring extension (FEAT_MPAM)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mte)] = .{\n        .llvm_name = \"mte\",\n        .description = \"Enable Memory Tagging Extension (FEAT_MTE, FEAT_MTE2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.neon)] = .{\n        .llvm_name = \"neon\",\n        .description = \"Enable Advanced SIMD instructions (FEAT_AdvSIMD)\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8,\n        }),\n    };\n    result[@intFromEnum(Feature.nmi)] = .{\n        .llvm_name = \"nmi\",\n        .description = \"Enable Armv8.8-A Non-maskable Interrupts (FEAT_NMI, FEAT_GICv3_NMI)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bti_at_return_twice)] = .{\n        .llvm_name = \"no-bti-at-return-twice\",\n        .description = \"Don't place a BTI instruction after a return-twice\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_neg_immediates)] = .{\n        .llvm_name = \"no-neg-immediates\",\n        .description = \"Convert immediates and instructions to their negated or complemented equivalent when the immediate does not fit in the encoding.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_sve_fp_ld1r)] = .{\n        .llvm_name = \"no-sve-fp-ld1r\",\n        .description = \"Avoid using LD1RX instructions for FP\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_zcz_fp)] = .{\n        .llvm_name = \"no-zcz-fp\",\n        .description = \"Has no zero-cycle zeroing instructions for FP registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nv)] = .{\n        .llvm_name = \"nv\",\n        .description = \"Enable v8.4-A Nested Virtualization Enchancement (FEAT_NV, FEAT_NV2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.outline_atomics)] = .{\n        .llvm_name = \"outline-atomics\",\n        .description = \"Enable out of line atomics to support LSE instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pan)] = .{\n        .llvm_name = \"pan\",\n        .description = \"Enables ARM v8.1 Privileged Access-Never extension (FEAT_PAN)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pan_rwv)] = .{\n        .llvm_name = \"pan-rwv\",\n        .description = \"Enable v8.2 PAN s1e1R and s1e1W Variants (FEAT_PAN2)\",\n        .dependencies = featureSet(&[_]Feature{\n            .pan,\n        }),\n    };\n    result[@intFromEnum(Feature.pauth)] = .{\n        .llvm_name = \"pauth\",\n        .description = \"Enable v8.3-A Pointer Authentication extension (FEAT_PAuth)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.perfmon)] = .{\n        .llvm_name = \"perfmon\",\n        .description = \"Enable Code Generation for ARMv8 PMUv3 Performance Monitors extension (FEAT_PMUv3)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.predictable_select_expensive)] = .{\n        .llvm_name = \"predictable-select-expensive\",\n        .description = \"Prefer likely predicted branches over selects\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.predres)] = .{\n        .llvm_name = \"predres\",\n        .description = \"Enable v8.5a execution and data prediction invalidation instructions (FEAT_SPECRES)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prfm_slc_target)] = .{\n        .llvm_name = \"prfm-slc-target\",\n        .description = \"Enable SLC target for PRFM instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rand)] = .{\n        .llvm_name = \"rand\",\n        .description = \"Enable Random Number generation instructions (FEAT_RNG)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ras)] = .{\n        .llvm_name = \"ras\",\n        .description = \"Enable ARMv8 Reliability, Availability and Serviceability Extensions (FEAT_RAS, FEAT_RASv1p1)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rasv2)] = .{\n        .llvm_name = \"rasv2\",\n        .description = \"Enable ARMv8.9-A Reliability, Availability and Serviceability Extensions (FEAT_RASv2)\",\n        .dependencies = featureSet(&[_]Feature{\n            .ras,\n        }),\n    };\n    result[@intFromEnum(Feature.rcpc)] = .{\n        .llvm_name = \"rcpc\",\n        .description = \"Enable support for RCPC extension (FEAT_LRCPC)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rcpc3)] = .{\n        .llvm_name = \"rcpc3\",\n        .description = \"Enable Armv8.9-A RCPC instructions for A64 and Advanced SIMD and floating-point instruction set (FEAT_LRCPC3)\",\n        .dependencies = featureSet(&[_]Feature{\n            .rcpc_immo,\n        }),\n    };\n    result[@intFromEnum(Feature.rcpc_immo)] = .{\n        .llvm_name = \"rcpc-immo\",\n        .description = \"Enable v8.4-A RCPC instructions with Immediate Offsets (FEAT_LRCPC2)\",\n        .dependencies = featureSet(&[_]Feature{\n            .rcpc,\n        }),\n    };\n    result[@intFromEnum(Feature.rdm)] = .{\n        .llvm_name = \"rdm\",\n        .description = \"Enable ARMv8.1 Rounding Double Multiply Add/Subtract instructions (FEAT_RDM)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x1)] = .{\n        .llvm_name = \"reserve-x1\",\n        .description = \"Reserve X1, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x10)] = .{\n        .llvm_name = \"reserve-x10\",\n        .description = \"Reserve X10, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x11)] = .{\n        .llvm_name = \"reserve-x11\",\n        .description = \"Reserve X11, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x12)] = .{\n        .llvm_name = \"reserve-x12\",\n        .description = \"Reserve X12, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x13)] = .{\n        .llvm_name = \"reserve-x13\",\n        .description = \"Reserve X13, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x14)] = .{\n        .llvm_name = \"reserve-x14\",\n        .description = \"Reserve X14, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x15)] = .{\n        .llvm_name = \"reserve-x15\",\n        .description = \"Reserve X15, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x18)] = .{\n        .llvm_name = \"reserve-x18\",\n        .description = \"Reserve X18, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x2)] = .{\n        .llvm_name = \"reserve-x2\",\n        .description = \"Reserve X2, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x20)] = .{\n        .llvm_name = \"reserve-x20\",\n        .description = \"Reserve X20, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x21)] = .{\n        .llvm_name = \"reserve-x21\",\n        .description = \"Reserve X21, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x22)] = .{\n        .llvm_name = \"reserve-x22\",\n        .description = \"Reserve X22, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x23)] = .{\n        .llvm_name = \"reserve-x23\",\n        .description = \"Reserve X23, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x24)] = .{\n        .llvm_name = \"reserve-x24\",\n        .description = \"Reserve X24, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x25)] = .{\n        .llvm_name = \"reserve-x25\",\n        .description = \"Reserve X25, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x26)] = .{\n        .llvm_name = \"reserve-x26\",\n        .description = \"Reserve X26, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x27)] = .{\n        .llvm_name = \"reserve-x27\",\n        .description = \"Reserve X27, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x28)] = .{\n        .llvm_name = \"reserve-x28\",\n        .description = \"Reserve X28, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x3)] = .{\n        .llvm_name = \"reserve-x3\",\n        .description = \"Reserve X3, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x30)] = .{\n        .llvm_name = \"reserve-x30\",\n        .description = \"Reserve X30, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x4)] = .{\n        .llvm_name = \"reserve-x4\",\n        .description = \"Reserve X4, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x5)] = .{\n        .llvm_name = \"reserve-x5\",\n        .description = \"Reserve X5, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x6)] = .{\n        .llvm_name = \"reserve-x6\",\n        .description = \"Reserve X6, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x7)] = .{\n        .llvm_name = \"reserve-x7\",\n        .description = \"Reserve X7, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x9)] = .{\n        .llvm_name = \"reserve-x9\",\n        .description = \"Reserve X9, making it unavailable as a GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rme)] = .{\n        .llvm_name = \"rme\",\n        .description = \"Enable Realm Management Extension (FEAT_RME)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sb)] = .{\n        .llvm_name = \"sb\",\n        .description = \"Enable v8.5 Speculation Barrier (FEAT_SB)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sel2)] = .{\n        .llvm_name = \"sel2\",\n        .description = \"Enable v8.4-A Secure Exception Level 2 extension (FEAT_SEL2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sha2)] = .{\n        .llvm_name = \"sha2\",\n        .description = \"Enable SHA1 and SHA256 support (FEAT_SHA1, FEAT_SHA256)\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.sha3)] = .{\n        .llvm_name = \"sha3\",\n        .description = \"Enable SHA512 and SHA3 support (FEAT_SHA3, FEAT_SHA512)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sha2,\n        }),\n    };\n    result[@intFromEnum(Feature.slow_misaligned_128store)] = .{\n        .llvm_name = \"slow-misaligned-128store\",\n        .description = \"Misaligned 128 bit stores are slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_paired_128)] = .{\n        .llvm_name = \"slow-paired-128\",\n        .description = \"Paired 128 bit loads and stores are slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_strqro_store)] = .{\n        .llvm_name = \"slow-strqro-store\",\n        .description = \"STR of Q register with register offset is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm4)] = .{\n        .llvm_name = \"sm4\",\n        .description = \"Enable SM3 and SM4 support (FEAT_SM4, FEAT_SM3)\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.sme)] = .{\n        .llvm_name = \"sme\",\n        .description = \"Enable Scalable Matrix Extension (SME) (FEAT_SME)\",\n        .dependencies = featureSet(&[_]Feature{\n            .bf16,\n            .use_scalar_inc_vl,\n        }),\n    };\n    result[@intFromEnum(Feature.sme2)] = .{\n        .llvm_name = \"sme2\",\n        .description = \"Enable Scalable Matrix Extension 2 (SME2) instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sme,\n        }),\n    };\n    result[@intFromEnum(Feature.sme2p1)] = .{\n        .llvm_name = \"sme2p1\",\n        .description = \"Enable Scalable Matrix Extension 2.1 (FEAT_SME2p1) instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sme2,\n        }),\n    };\n    result[@intFromEnum(Feature.sme_f16f16)] = .{\n        .llvm_name = \"sme-f16f16\",\n        .description = \"Enable SME2.1 non-widening Float16 instructions (FEAT_SME_F16F16)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sme_f64f64)] = .{\n        .llvm_name = \"sme-f64f64\",\n        .description = \"Enable Scalable Matrix Extension (SME) F64F64 instructions (FEAT_SME_F64F64)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sme,\n        }),\n    };\n    result[@intFromEnum(Feature.sme_i16i64)] = .{\n        .llvm_name = \"sme-i16i64\",\n        .description = \"Enable Scalable Matrix Extension (SME) I16I64 instructions (FEAT_SME_I16I64)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sme,\n        }),\n    };\n    result[@intFromEnum(Feature.spe)] = .{\n        .llvm_name = \"spe\",\n        .description = \"Enable Statistical Profiling extension (FEAT_SPE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.spe_eef)] = .{\n        .llvm_name = \"spe-eef\",\n        .description = \"Enable extra register in the Statistical Profiling Extension (FEAT_SPEv1p2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.specres2)] = .{\n        .llvm_name = \"specres2\",\n        .description = \"Enable Speculation Restriction Instruction (FEAT_SPECRES2)\",\n        .dependencies = featureSet(&[_]Feature{\n            .predres,\n        }),\n    };\n    result[@intFromEnum(Feature.specrestrict)] = .{\n        .llvm_name = \"specrestrict\",\n        .description = \"Enable architectural speculation restriction (FEAT_CSV2_2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ssbs)] = .{\n        .llvm_name = \"ssbs\",\n        .description = \"Enable Speculative Store Bypass Safe bit (FEAT_SSBS, FEAT_SSBS2)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.strict_align)] = .{\n        .llvm_name = \"strict-align\",\n        .description = \"Disallow all unaligned memory access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sve)] = .{\n        .llvm_name = \"sve\",\n        .description = \"Enable Scalable Vector Extension (SVE) instructions (FEAT_SVE)\",\n        .dependencies = featureSet(&[_]Feature{\n            .fullfp16,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2)] = .{\n        .llvm_name = \"sve2\",\n        .description = \"Enable Scalable Vector Extension 2 (SVE2) instructions (FEAT_SVE2)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sve,\n            .use_scalar_inc_vl,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2_aes)] = .{\n        .llvm_name = \"sve2-aes\",\n        .description = \"Enable AES SVE2 instructions (FEAT_SVE_AES, FEAT_SVE_PMULL128)\",\n        .dependencies = featureSet(&[_]Feature{\n            .aes,\n            .sve2,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2_bitperm)] = .{\n        .llvm_name = \"sve2-bitperm\",\n        .description = \"Enable bit permutation SVE2 instructions (FEAT_SVE_BitPerm)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sve2,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2_sha3)] = .{\n        .llvm_name = \"sve2-sha3\",\n        .description = \"Enable SHA3 SVE2 instructions (FEAT_SVE_SHA3)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sha3,\n            .sve2,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2_sm4)] = .{\n        .llvm_name = \"sve2-sm4\",\n        .description = \"Enable SM4 SVE2 instructions (FEAT_SVE_SM4)\",\n        .dependencies = featureSet(&[_]Feature{\n            .sm4,\n            .sve2,\n        }),\n    };\n    result[@intFromEnum(Feature.sve2p1)] = .{\n        .llvm_name = \"sve2p1\",\n        .description = \"Enable Scalable Vector Extension 2.1 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sve2,\n        }),\n    };\n    result[@intFromEnum(Feature.tagged_globals)] = .{\n        .llvm_name = \"tagged-globals\",\n        .description = \"Use an instruction sequence for taking the address of a global that allows a memory tag in the upper address bits\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.the)] = .{\n        .llvm_name = \"the\",\n        .description = \"Enable Armv8.9-A Translation Hardening Extension (FEAT_THE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tlb_rmi)] = .{\n        .llvm_name = \"tlb-rmi\",\n        .description = \"Enable v8.4-A TLB Range and Maintenance Instructions (FEAT_TLBIOS, FEAT_TLBIRANGE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tme)] = .{\n        .llvm_name = \"tme\",\n        .description = \"Enable Transactional Memory Extension (FEAT_TME)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tpidr_el1)] = .{\n        .llvm_name = \"tpidr-el1\",\n        .description = \"Permit use of TPIDR_EL1 for the TLS base\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tpidr_el2)] = .{\n        .llvm_name = \"tpidr-el2\",\n        .description = \"Permit use of TPIDR_EL2 for the TLS base\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tpidr_el3)] = .{\n        .llvm_name = \"tpidr-el3\",\n        .description = \"Permit use of TPIDR_EL3 for the TLS base\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tpidrro_el0)] = .{\n        .llvm_name = \"tpidrro-el0\",\n        .description = \"Permit use of TPIDRRO_EL0 for the TLS base\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tracev8_4)] = .{\n        .llvm_name = \"tracev8.4\",\n        .description = \"Enable v8.4-A Trace extension (FEAT_TRF)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.trbe)] = .{\n        .llvm_name = \"trbe\",\n        .description = \"Enable Trace Buffer Extension (FEAT_TRBE)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.uaops)] = .{\n        .llvm_name = \"uaops\",\n        .description = \"Enable v8.2 UAO PState (FEAT_UAO)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_experimental_zeroing_pseudos)] = .{\n        .llvm_name = \"use-experimental-zeroing-pseudos\",\n        .description = \"Hint to the compiler that the MOVPRFX instruction is merged with destructive operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_postra_scheduler)] = .{\n        .llvm_name = \"use-postra-scheduler\",\n        .description = \"Schedule again after register allocation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_reciprocal_square_root)] = .{\n        .llvm_name = \"use-reciprocal-square-root\",\n        .description = \"Use the reciprocal square root approximation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_scalar_inc_vl)] = .{\n        .llvm_name = \"use-scalar-inc-vl\",\n        .description = \"Prefer inc/dec over add+cnt\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v8_1a)] = .{\n        .llvm_name = \"v8.1a\",\n        .description = \"Support ARM v8.1a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .crc,\n            .lor,\n            .lse,\n            .pan,\n            .rdm,\n            .v8a,\n            .vh,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_2a)] = .{\n        .llvm_name = \"v8.2a\",\n        .description = \"Support ARM v8.2a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .ccpp,\n            .pan_rwv,\n            .ras,\n            .uaops,\n            .v8_1a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_3a)] = .{\n        .llvm_name = \"v8.3a\",\n        .description = \"Support ARM v8.3a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .ccidx,\n            .complxnum,\n            .jsconv,\n            .pauth,\n            .rcpc,\n            .v8_2a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_4a)] = .{\n        .llvm_name = \"v8.4a\",\n        .description = \"Support ARM v8.4a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .am,\n            .dit,\n            .dotprod,\n            .flagm,\n            .lse2,\n            .mpam,\n            .nv,\n            .rcpc_immo,\n            .sel2,\n            .tlb_rmi,\n            .tracev8_4,\n            .v8_3a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_5a)] = .{\n        .llvm_name = \"v8.5a\",\n        .description = \"Support ARM v8.5a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .altnzcv,\n            .bti,\n            .ccdp,\n            .fptoint,\n            .predres,\n            .sb,\n            .specrestrict,\n            .ssbs,\n            .v8_4a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_6a)] = .{\n        .llvm_name = \"v8.6a\",\n        .description = \"Support ARM v8.6a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .amvs,\n            .bf16,\n            .ecv,\n            .fgt,\n            .i8mm,\n            .v8_5a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_7a)] = .{\n        .llvm_name = \"v8.7a\",\n        .description = \"Support ARM v8.7a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hcx,\n            .v8_6a,\n            .wfxt,\n            .xs,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_8a)] = .{\n        .llvm_name = \"v8.8a\",\n        .description = \"Support ARM v8.8a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hbc,\n            .mops,\n            .nmi,\n            .v8_7a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_9a)] = .{\n        .llvm_name = \"v8.9a\",\n        .description = \"Support ARM v8.9a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .chk,\n            .clrbhb,\n            .cssc,\n            .prfm_slc_target,\n            .rasv2,\n            .specres2,\n            .v8_8a,\n        }),\n    };\n    result[@intFromEnum(Feature.v8a)] = .{\n        .llvm_name = \"v8a\",\n        .description = \"Support ARM v8.0a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .el2vmsa,\n            .el3,\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.v8r)] = .{\n        .llvm_name = \"v8r\",\n        .description = \"Support ARM v8r instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .ccidx,\n            .ccpp,\n            .complxnum,\n            .contextidr_el2,\n            .crc,\n            .dit,\n            .dotprod,\n            .flagm,\n            .jsconv,\n            .lse,\n            .pan_rwv,\n            .pauth,\n            .ras,\n            .rcpc_immo,\n            .rdm,\n            .sel2,\n            .specrestrict,\n            .tlb_rmi,\n            .tracev8_4,\n            .uaops,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_1a)] = .{\n        .llvm_name = \"v9.1a\",\n        .description = \"Support ARM v9.1a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .v8_6a,\n            .v9a,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_2a)] = .{\n        .llvm_name = \"v9.2a\",\n        .description = \"Support ARM v9.2a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .v8_7a,\n            .v9_1a,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_3a)] = .{\n        .llvm_name = \"v9.3a\",\n        .description = \"Support ARM v9.3a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .v8_8a,\n            .v9_2a,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_4a)] = .{\n        .llvm_name = \"v9.4a\",\n        .description = \"Support ARM v9.4a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .v8_9a,\n            .v9_3a,\n        }),\n    };\n    result[@intFromEnum(Feature.v9a)] = .{\n        .llvm_name = \"v9a\",\n        .description = \"Support ARM v9a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .mec,\n            .sve2,\n            .v8_5a,\n        }),\n    };\n    result[@intFromEnum(Feature.vh)] = .{\n        .llvm_name = \"vh\",\n        .description = \"Enables ARM v8.1 Virtual Host extension (FEAT_VHE)\",\n        .dependencies = featureSet(&[_]Feature{\n            .contextidr_el2,\n        }),\n    };\n    result[@intFromEnum(Feature.wfxt)] = .{\n        .llvm_name = \"wfxt\",\n        .description = \"Enable Armv8.7-A WFET and WFIT instruction (FEAT_WFxT)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xs)] = .{\n        .llvm_name = \"xs\",\n        .description = \"Enable Armv8.7-A limited-TLB-maintenance instruction (FEAT_XS)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zcm)] = .{\n        .llvm_name = \"zcm\",\n        .description = \"Has zero-cycle register moves\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zcz)] = .{\n        .llvm_name = \"zcz\",\n        .description = \"Has zero-cycle zeroing instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .zcz_gp,\n        }),\n    };\n    result[@intFromEnum(Feature.zcz_fp_workaround)] = .{\n        .llvm_name = \"zcz-fp-workaround\",\n        .description = \"The zero-cycle floating-point zeroing instruction has a bug\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zcz_gp)] = .{\n        .llvm_name = \"zcz-gp\",\n        .description = \"Has zero-cycle zeroing instructions for generic registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.norm)] = .{\n        .llvm_name = \"norm\",\n        .description = \"Enable support for norm instruction.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"16_bit_insts\")] = .{\n        .llvm_name = \"16-bit-insts\",\n        .description = \"Has i16/f16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.a16)] = .{\n        .llvm_name = \"a16\",\n        .description = \"Support A16 for 16-bit coordinates/gradients/lod/clamp/mip image operands\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.add_no_carry_insts)] = .{\n        .llvm_name = \"add-no-carry-insts\",\n        .description = \"Have VALU add/sub instructions without carry out\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aperture_regs)] = .{\n        .llvm_name = \"aperture-regs\",\n        .description = \"Has Memory Aperture Base and Size Registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.architected_flat_scratch)] = .{\n        .llvm_name = \"architected-flat-scratch\",\n        .description = \"Flat Scratch register is a readonly SPI initialized architected register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.architected_sgprs)] = .{\n        .llvm_name = \"architected-sgprs\",\n        .description = \"Enable the architected SGPRs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.atomic_buffer_global_pk_add_f16_insts)] = .{\n        .llvm_name = \"atomic-buffer-global-pk-add-f16-insts\",\n        .description = \"Has buffer_atomic_pk_add_f16 and global_atomic_pk_add_f16 instructions that can return original value\",\n        .dependencies = featureSet(&[_]Feature{\n            .flat_global_insts,\n        }),\n    };\n    result[@intFromEnum(Feature.atomic_buffer_global_pk_add_f16_no_rtn_insts)] = .{\n        .llvm_name = \"atomic-buffer-global-pk-add-f16-no-rtn-insts\",\n        .description = \"Has buffer_atomic_pk_add_f16 and global_atomic_pk_add_f16 instructions that don't return original value\",\n        .dependencies = featureSet(&[_]Feature{\n            .flat_global_insts,\n        }),\n    };\n    result[@intFromEnum(Feature.atomic_ds_pk_add_16_insts)] = .{\n        .llvm_name = \"atomic-ds-pk-add-16-insts\",\n        .description = \"Has ds_pk_add_bf16, ds_pk_add_f16, ds_pk_add_rtn_bf16, ds_pk_add_rtn_f16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.atomic_fadd_no_rtn_insts)] = .{\n        .llvm_name = \"atomic-fadd-no-rtn-insts\",\n        .description = \"Has buffer_atomic_add_f32 and global_atomic_add_f32 instructions that don't return original value\",\n        .dependencies = featureSet(&[_]Feature{\n            .flat_global_insts,\n        }),\n    };\n    result[@intFromEnum(Feature.atomic_fadd_rtn_insts)] = .{\n        .llvm_name = \"atomic-fadd-rtn-insts\",\n        .description = \"Has buffer_atomic_add_f32 and global_atomic_add_f32 instructions that return original value\",\n        .dependencies = featureSet(&[_]Feature{\n            .flat_global_insts,\n        }),\n    };\n    result[@intFromEnum(Feature.atomic_flat_pk_add_16_insts)] = .{\n        .llvm_name = \"atomic-flat-pk-add-16-insts\",\n        .description = \"Has flat_atomic_pk_add_f16 and flat_atomic_pk_add_bf16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.atomic_global_pk_add_bf16_inst)] = .{\n        .llvm_name = \"atomic-global-pk-add-bf16-inst\",\n        .description = \"Has global_atomic_pk_add_bf16 instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .flat_global_insts,\n        }),\n    };\n    result[@intFromEnum(Feature.auto_waitcnt_before_barrier)] = .{\n        .llvm_name = \"auto-waitcnt-before-barrier\",\n        .description = \"Hardware automatically inserts waitcnt before barrier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.back_off_barrier)] = .{\n        .llvm_name = \"back-off-barrier\",\n        .description = \"Hardware supports backing off s_barrier if an exception occurs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ci_insts)] = .{\n        .llvm_name = \"ci-insts\",\n        .description = \"Additional instructions for CI+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cumode)] = .{\n        .llvm_name = \"cumode\",\n        .description = \"Enable CU wavefront execution mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dl_insts)] = .{\n        .llvm_name = \"dl-insts\",\n        .description = \"Has v_fmac_f32 and v_xnor_b32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot10_insts)] = .{\n        .llvm_name = \"dot10-insts\",\n        .description = \"Has v_dot2_f32_f16 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot1_insts)] = .{\n        .llvm_name = \"dot1-insts\",\n        .description = \"Has v_dot4_i32_i8 and v_dot8_i32_i4 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot2_insts)] = .{\n        .llvm_name = \"dot2-insts\",\n        .description = \"Has v_dot2_i32_i16, v_dot2_u32_u16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot3_insts)] = .{\n        .llvm_name = \"dot3-insts\",\n        .description = \"Has v_dot8c_i32_i4 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot4_insts)] = .{\n        .llvm_name = \"dot4-insts\",\n        .description = \"Has v_dot2c_i32_i16 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot5_insts)] = .{\n        .llvm_name = \"dot5-insts\",\n        .description = \"Has v_dot2c_f32_f16 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot6_insts)] = .{\n        .llvm_name = \"dot6-insts\",\n        .description = \"Has v_dot4c_i32_i8 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot7_insts)] = .{\n        .llvm_name = \"dot7-insts\",\n        .description = \"Has v_dot4_u32_u8, v_dot8_u32_u4 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot8_insts)] = .{\n        .llvm_name = \"dot8-insts\",\n        .description = \"Has v_dot4_i32_iu8, v_dot8_i32_iu4 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dot9_insts)] = .{\n        .llvm_name = \"dot9-insts\",\n        .description = \"Has v_dot2_f16_f16, v_dot2_bf16_bf16, v_dot2_f32_bf16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dpp)] = .{\n        .llvm_name = \"dpp\",\n        .description = \"Support DPP (Data Parallel Primitives) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dpp8)] = .{\n        .llvm_name = \"dpp8\",\n        .description = \"Support DPP8 (Data Parallel Primitives) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dpp_64bit)] = .{\n        .llvm_name = \"dpp-64bit\",\n        .description = \"Support DPP (Data Parallel Primitives) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ds128)] = .{\n        .llvm_name = \"enable-ds128\",\n        .description = \"Use ds_{read|write}_b128\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ds_src2_insts)] = .{\n        .llvm_name = \"ds-src2-insts\",\n        .description = \"Has ds_*_src2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.extended_image_insts)] = .{\n        .llvm_name = \"extended-image-insts\",\n        .description = \"Support mips != 0, lod != 0, gather4, and get_lod\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_denormal_f32)] = .{\n        .llvm_name = \"fast-denormal-f32\",\n        .description = \"Enabling denormals does not cause f32 instructions to run at f64 rates\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_fmaf)] = .{\n        .llvm_name = \"fast-fmaf\",\n        .description = \"Assuming f32 fma is at least as fast as mul + add\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_address_space)] = .{\n        .llvm_name = \"flat-address-space\",\n        .description = \"Support flat address space\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_atomic_fadd_f32_inst)] = .{\n        .llvm_name = \"flat-atomic-fadd-f32-inst\",\n        .description = \"Has flat_atomic_add_f32 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_for_global)] = .{\n        .llvm_name = \"flat-for-global\",\n        .description = \"Force to generate flat instruction for global\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_global_insts)] = .{\n        .llvm_name = \"flat-global-insts\",\n        .description = \"Have global_* flat memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_inst_offsets)] = .{\n        .llvm_name = \"flat-inst-offsets\",\n        .description = \"Flat instructions have immediate offset addressing mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_scratch)] = .{\n        .llvm_name = \"enable-flat-scratch\",\n        .description = \"Use scratch_* flat memory instructions to access scratch\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_scratch_insts)] = .{\n        .llvm_name = \"flat-scratch-insts\",\n        .description = \"Have scratch_* flat memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.flat_segment_offset_bug)] = .{\n        .llvm_name = \"flat-segment-offset-bug\",\n        .description = \"GFX10 bug where inst_offset is ignored when flat instructions access global memory\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fma_mix_insts)] = .{\n        .llvm_name = \"fma-mix-insts\",\n        .description = \"Has v_fma_mix_f32, v_fma_mixlo_f16, v_fma_mixhi_f16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fmacf64_inst)] = .{\n        .llvm_name = \"fmacf64-inst\",\n        .description = \"Has v_fmac_f64 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fmaf)] = .{\n        .llvm_name = \"fmaf\",\n        .description = \"Enable single precision FMA (not as fast as mul+add, but fused)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.force_store_sc0_sc1)] = .{\n        .llvm_name = \"force-store-sc0-sc1\",\n        .description = \"Has SC0 and SC1 on stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp64)] = .{\n        .llvm_name = \"fp64\",\n        .description = \"Enable double precision operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp8_insts)] = .{\n        .llvm_name = \"fp8-insts\",\n        .description = \"Has fp8 and bf8 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.full_rate_64_ops)] = .{\n        .llvm_name = \"full-rate-64-ops\",\n        .description = \"Most fp64 instructions are full rate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.g16)] = .{\n        .llvm_name = \"g16\",\n        .description = \"Support G16 for 16-bit gradient image operands\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gcn3_encoding)] = .{\n        .llvm_name = \"gcn3-encoding\",\n        .description = \"Encoding format for VI\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.get_wave_id_inst)] = .{\n        .llvm_name = \"get-wave-id-inst\",\n        .description = \"Has s_get_waveid_in_workgroup instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx10)] = .{\n        .llvm_name = \"gfx10\",\n        .description = \"GFX10 GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"16_bit_insts\",\n            .a16,\n            .add_no_carry_insts,\n            .aperture_regs,\n            .ci_insts,\n            .dpp,\n            .dpp8,\n            .extended_image_insts,\n            .fast_denormal_f32,\n            .fast_fmaf,\n            .flat_address_space,\n            .flat_global_insts,\n            .flat_inst_offsets,\n            .flat_scratch_insts,\n            .fma_mix_insts,\n            .fp64,\n            .g16,\n            .gfx10_insts,\n            .gfx8_insts,\n            .gfx9_insts,\n            .image_insts,\n            .int_clamp_insts,\n            .inv_2pi_inline_imm,\n            .localmemorysize65536,\n            .mimg_r128,\n            .movrel,\n            .no_data_dep_hazard,\n            .no_sdst_cmpx,\n            .pk_fmac_f16_inst,\n            .s_memrealtime,\n            .s_memtime_inst,\n            .sdwa,\n            .sdwa_omod,\n            .sdwa_scalar,\n            .sdwa_sdst,\n            .unaligned_buffer_access,\n            .unaligned_ds_access,\n            .vop3_literal,\n            .vop3p,\n            .vscnt,\n        }),\n    };\n    result[@intFromEnum(Feature.gfx10_3_insts)] = .{\n        .llvm_name = \"gfx10-3-insts\",\n        .description = \"Additional instructions for GFX10.3\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx10_a_encoding)] = .{\n        .llvm_name = \"gfx10_a-encoding\",\n        .description = \"Has BVH ray tracing instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx10_b_encoding)] = .{\n        .llvm_name = \"gfx10_b-encoding\",\n        .description = \"Encoding format GFX10_B\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx10_insts)] = .{\n        .llvm_name = \"gfx10-insts\",\n        .description = \"Additional instructions for GFX10+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx11)] = .{\n        .llvm_name = \"gfx11\",\n        .description = \"GFX11 GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"16_bit_insts\",\n            .a16,\n            .add_no_carry_insts,\n            .aperture_regs,\n            .ci_insts,\n            .dpp,\n            .dpp8,\n            .extended_image_insts,\n            .fast_denormal_f32,\n            .fast_fmaf,\n            .flat_address_space,\n            .flat_global_insts,\n            .flat_inst_offsets,\n            .flat_scratch_insts,\n            .fma_mix_insts,\n            .fp64,\n            .g16,\n            .gfx10_3_insts,\n            .gfx10_a_encoding,\n            .gfx10_b_encoding,\n            .gfx10_insts,\n            .gfx11_insts,\n            .gfx8_insts,\n            .gfx9_insts,\n            .int_clamp_insts,\n            .inv_2pi_inline_imm,\n            .localmemorysize65536,\n            .mimg_r128,\n            .movrel,\n            .no_data_dep_hazard,\n            .no_sdst_cmpx,\n            .pk_fmac_f16_inst,\n            .true16,\n            .unaligned_buffer_access,\n            .unaligned_ds_access,\n            .vop3_literal,\n            .vop3p,\n            .vopd,\n            .vscnt,\n        }),\n    };\n    result[@intFromEnum(Feature.gfx11_full_vgprs)] = .{\n        .llvm_name = \"gfx11-full-vgprs\",\n        .description = \"GFX11 with 50% more physical VGPRs and 50% larger allocation granule than GFX10\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx11_insts)] = .{\n        .llvm_name = \"gfx11-insts\",\n        .description = \"Additional instructions for GFX11+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx7_gfx8_gfx9_insts)] = .{\n        .llvm_name = \"gfx7-gfx8-gfx9-insts\",\n        .description = \"Instructions shared in GFX7, GFX8, GFX9\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx8_insts)] = .{\n        .llvm_name = \"gfx8-insts\",\n        .description = \"Additional instructions for GFX8+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx9)] = .{\n        .llvm_name = \"gfx9\",\n        .description = \"GFX9 GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"16_bit_insts\",\n            .a16,\n            .add_no_carry_insts,\n            .aperture_regs,\n            .ci_insts,\n            .dpp,\n            .fast_denormal_f32,\n            .fast_fmaf,\n            .flat_address_space,\n            .flat_global_insts,\n            .flat_inst_offsets,\n            .flat_scratch_insts,\n            .fp64,\n            .gcn3_encoding,\n            .gfx7_gfx8_gfx9_insts,\n            .gfx8_insts,\n            .gfx9_insts,\n            .int_clamp_insts,\n            .inv_2pi_inline_imm,\n            .localmemorysize65536,\n            .negative_scratch_offset_bug,\n            .r128_a16,\n            .s_memrealtime,\n            .s_memtime_inst,\n            .scalar_atomics,\n            .scalar_flat_scratch_insts,\n            .scalar_stores,\n            .sdwa,\n            .sdwa_omod,\n            .sdwa_scalar,\n            .sdwa_sdst,\n            .unaligned_buffer_access,\n            .unaligned_ds_access,\n            .vgpr_index_mode,\n            .vop3p,\n            .wavefrontsize64,\n            .xnack_support,\n        }),\n    };\n    result[@intFromEnum(Feature.gfx90a_insts)] = .{\n        .llvm_name = \"gfx90a-insts\",\n        .description = \"Additional instructions for GFX90A+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx940_insts)] = .{\n        .llvm_name = \"gfx940-insts\",\n        .description = \"Additional instructions for GFX940+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfx9_insts)] = .{\n        .llvm_name = \"gfx9-insts\",\n        .description = \"Additional instructions for GFX9+\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.half_rate_64_ops)] = .{\n        .llvm_name = \"half-rate-64-ops\",\n        .description = \"Most fp64 instructions are half rate instead of quarter\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.image_gather4_d16_bug)] = .{\n        .llvm_name = \"image-gather4-d16-bug\",\n        .description = \"Image Gather4 D16 hardware bug\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.image_insts)] = .{\n        .llvm_name = \"image-insts\",\n        .description = \"Support image instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.image_store_d16_bug)] = .{\n        .llvm_name = \"image-store-d16-bug\",\n        .description = \"Image Store D16 hardware bug\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.inst_fwd_prefetch_bug)] = .{\n        .llvm_name = \"inst-fwd-prefetch-bug\",\n        .description = \"S_INST_PREFETCH instruction causes shader to hang\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.int_clamp_insts)] = .{\n        .llvm_name = \"int-clamp-insts\",\n        .description = \"Support clamp for integer destination\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.inv_2pi_inline_imm)] = .{\n        .llvm_name = \"inv-2pi-inline-imm\",\n        .description = \"Has 1 / (2 * pi) as inline immediate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lds_branch_vmem_war_hazard)] = .{\n        .llvm_name = \"lds-branch-vmem-war-hazard\",\n        .description = \"Switching between LDS and VMEM-tex not waiting VM_VSRC=0\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lds_misaligned_bug)] = .{\n        .llvm_name = \"lds-misaligned-bug\",\n        .description = \"Some GFX10 bug with multi-dword LDS and flat access that is not naturally aligned in WGP mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ldsbankcount16)] = .{\n        .llvm_name = \"ldsbankcount16\",\n        .description = \"The number of LDS banks per compute unit.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ldsbankcount32)] = .{\n        .llvm_name = \"ldsbankcount32\",\n        .description = \"The number of LDS banks per compute unit.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.load_store_opt)] = .{\n        .llvm_name = \"load-store-opt\",\n        .description = \"Enable SI load/store optimizer pass\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.localmemorysize32768)] = .{\n        .llvm_name = \"localmemorysize32768\",\n        .description = \"The size of local memory in bytes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.localmemorysize65536)] = .{\n        .llvm_name = \"localmemorysize65536\",\n        .description = \"The size of local memory in bytes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mad_intra_fwd_bug)] = .{\n        .llvm_name = \"mad-intra-fwd-bug\",\n        .description = \"MAD_U64/I64 intra instruction forwarding bug\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mad_mac_f32_insts)] = .{\n        .llvm_name = \"mad-mac-f32-insts\",\n        .description = \"Has v_mad_f32/v_mac_f32/v_madak_f32/v_madmk_f32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mad_mix_insts)] = .{\n        .llvm_name = \"mad-mix-insts\",\n        .description = \"Has v_mad_mix_f32, v_mad_mixlo_f16, v_mad_mixhi_f16 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mai_insts)] = .{\n        .llvm_name = \"mai-insts\",\n        .description = \"Has mAI instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.max_private_element_size_16)] = .{\n        .llvm_name = \"max-private-element-size-16\",\n        .description = \"Maximum private access size may be 16\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.max_private_element_size_4)] = .{\n        .llvm_name = \"max-private-element-size-4\",\n        .description = \"Maximum private access size may be 4\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.max_private_element_size_8)] = .{\n        .llvm_name = \"max-private-element-size-8\",\n        .description = \"Maximum private access size may be 8\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mfma_inline_literal_bug)] = .{\n        .llvm_name = \"mfma-inline-literal-bug\",\n        .description = \"MFMA cannot use inline literal as SrcC\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mimg_r128)] = .{\n        .llvm_name = \"mimg-r128\",\n        .description = \"Support 128-bit texture resources\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.movrel)] = .{\n        .llvm_name = \"movrel\",\n        .description = \"Has v_movrel*_b32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.negative_scratch_offset_bug)] = .{\n        .llvm_name = \"negative-scratch-offset-bug\",\n        .description = \"Negative immediate offsets in scratch instructions with an SGPR offset page fault on GFX9\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.negative_unaligned_scratch_offset_bug)] = .{\n        .llvm_name = \"negative-unaligned-scratch-offset-bug\",\n        .description = \"Scratch instructions with a VGPR offset and a negative immediate offset that is not a multiple of 4 read wrong memory on GFX10\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_data_dep_hazard)] = .{\n        .llvm_name = \"no-data-dep-hazard\",\n        .description = \"Does not need SW waitstates\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_sdst_cmpx)] = .{\n        .llvm_name = \"no-sdst-cmpx\",\n        .description = \"V_CMPX does not write VCC/SGPR in addition to EXEC\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nsa_clause_bug)] = .{\n        .llvm_name = \"nsa-clause-bug\",\n        .description = \"MIMG-NSA in a hard clause has unpredictable results on GFX10.1\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nsa_encoding)] = .{\n        .llvm_name = \"nsa-encoding\",\n        .description = \"Support NSA encoding for image instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nsa_to_vmem_bug)] = .{\n        .llvm_name = \"nsa-to-vmem-bug\",\n        .description = \"MIMG-NSA followed by VMEM fail if EXEC_LO or EXEC_HI equals zero\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.offset_3f_bug)] = .{\n        .llvm_name = \"offset-3f-bug\",\n        .description = \"Branch offset of 3f hardware bug\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.packed_fp32_ops)] = .{\n        .llvm_name = \"packed-fp32-ops\",\n        .description = \"Support packed fp32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.packed_tid)] = .{\n        .llvm_name = \"packed-tid\",\n        .description = \"Workitem IDs are packed into v0 at kernel launch\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.partial_nsa_encoding)] = .{\n        .llvm_name = \"partial-nsa-encoding\",\n        .description = \"Support partial NSA encoding for image instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pk_fmac_f16_inst)] = .{\n        .llvm_name = \"pk-fmac-f16-inst\",\n        .description = \"Has v_pk_fmac_f16 instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.promote_alloca)] = .{\n        .llvm_name = \"promote-alloca\",\n        .description = \"Enable promote alloca pass\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prt_strict_null)] = .{\n        .llvm_name = \"enable-prt-strict-null\",\n        .description = \"Enable zeroing of result registers for sparse texture fetches\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.r128_a16)] = .{\n        .llvm_name = \"r128-a16\",\n        .description = \"Support gfx9-style A16 for 16-bit coordinates/gradients/lod/clamp/mip image operands, where a16 is aliased with r128\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.s_memrealtime)] = .{\n        .llvm_name = \"s-memrealtime\",\n        .description = \"Has s_memrealtime instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.s_memtime_inst)] = .{\n        .llvm_name = \"s-memtime-inst\",\n        .description = \"Has s_memtime instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.scalar_atomics)] = .{\n        .llvm_name = \"scalar-atomics\",\n        .description = \"Has atomic scalar memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.scalar_flat_scratch_insts)] = .{\n        .llvm_name = \"scalar-flat-scratch-insts\",\n        .description = \"Have s_scratch_* flat memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.scalar_stores)] = .{\n        .llvm_name = \"scalar-stores\",\n        .description = \"Has store scalar memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa)] = .{\n        .llvm_name = \"sdwa\",\n        .description = \"Support SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa_mav)] = .{\n        .llvm_name = \"sdwa-mav\",\n        .description = \"Support v_mac_f32/f16 with SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa_omod)] = .{\n        .llvm_name = \"sdwa-omod\",\n        .description = \"Support OMod with SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa_out_mods_vopc)] = .{\n        .llvm_name = \"sdwa-out-mods-vopc\",\n        .description = \"Support clamp for VOPC with SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa_scalar)] = .{\n        .llvm_name = \"sdwa-scalar\",\n        .description = \"Support scalar register with SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sdwa_sdst)] = .{\n        .llvm_name = \"sdwa-sdst\",\n        .description = \"Support scalar dst for VOPC with SDWA (Sub-DWORD Addressing) extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sea_islands)] = .{\n        .llvm_name = \"sea-islands\",\n        .description = \"SEA_ISLANDS GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .ci_insts,\n            .ds_src2_insts,\n            .extended_image_insts,\n            .flat_address_space,\n            .fp64,\n            .gfx7_gfx8_gfx9_insts,\n            .image_insts,\n            .localmemorysize65536,\n            .mad_mac_f32_insts,\n            .mimg_r128,\n            .movrel,\n            .s_memtime_inst,\n            .trig_reduced_range,\n            .unaligned_buffer_access,\n            .wavefrontsize64,\n        }),\n    };\n    result[@intFromEnum(Feature.sgpr_init_bug)] = .{\n        .llvm_name = \"sgpr-init-bug\",\n        .description = \"VI SGPR initialization bug requiring a fixed SGPR allocation size\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.shader_cycles_register)] = .{\n        .llvm_name = \"shader-cycles-register\",\n        .description = \"Has SHADER_CYCLES hardware register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.si_scheduler)] = .{\n        .llvm_name = \"si-scheduler\",\n        .description = \"Enable SI Machine Scheduler\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.smem_to_vector_write_hazard)] = .{\n        .llvm_name = \"smem-to-vector-write-hazard\",\n        .description = \"s_load_dword followed by v_cmp page faults\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.southern_islands)] = .{\n        .llvm_name = \"southern-islands\",\n        .description = \"SOUTHERN_ISLANDS GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .ds_src2_insts,\n            .extended_image_insts,\n            .fp64,\n            .image_insts,\n            .ldsbankcount32,\n            .localmemorysize32768,\n            .mad_mac_f32_insts,\n            .mimg_r128,\n            .movrel,\n            .s_memtime_inst,\n            .trig_reduced_range,\n            .wavefrontsize64,\n        }),\n    };\n    result[@intFromEnum(Feature.sramecc)] = .{\n        .llvm_name = \"sramecc\",\n        .description = \"Enable SRAMECC\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sramecc_support)] = .{\n        .llvm_name = \"sramecc-support\",\n        .description = \"Hardware supports SRAMECC\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tgsplit)] = .{\n        .llvm_name = \"tgsplit\",\n        .description = \"Enable threadgroup split execution\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.trap_handler)] = .{\n        .llvm_name = \"trap-handler\",\n        .description = \"Trap handler support\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.trig_reduced_range)] = .{\n        .llvm_name = \"trig-reduced-range\",\n        .description = \"Requires use of fract on arguments to trig instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.true16)] = .{\n        .llvm_name = \"true16\",\n        .description = \"True 16-bit operand instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_access_mode)] = .{\n        .llvm_name = \"unaligned-access-mode\",\n        .description = \"Enable unaligned global, local and region loads and stores if the hardware supports it\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_buffer_access)] = .{\n        .llvm_name = \"unaligned-buffer-access\",\n        .description = \"Hardware supports unaligned global loads and stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_ds_access)] = .{\n        .llvm_name = \"unaligned-ds-access\",\n        .description = \"Hardware supports unaligned local and region loads and stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_scratch_access)] = .{\n        .llvm_name = \"unaligned-scratch-access\",\n        .description = \"Support unaligned scratch loads and stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unpacked_d16_vmem)] = .{\n        .llvm_name = \"unpacked-d16-vmem\",\n        .description = \"Has unpacked d16 vmem instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unsafe_ds_offset_folding)] = .{\n        .llvm_name = \"unsafe-ds-offset-folding\",\n        .description = \"Force using DS instruction immediate offsets on SI\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.user_sgpr_init16_bug)] = .{\n        .llvm_name = \"user-sgpr-init16-bug\",\n        .description = \"Bug requiring at least 16 user+system SGPRs to be enabled\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.valu_trans_use_hazard)] = .{\n        .llvm_name = \"valu-trans-use-hazard\",\n        .description = \"Hazard when TRANS instructions are closely followed by a use of the result\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vcmpx_exec_war_hazard)] = .{\n        .llvm_name = \"vcmpx-exec-war-hazard\",\n        .description = \"V_CMPX WAR hazard on EXEC (V_CMPX issue ONLY)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vcmpx_permlane_hazard)] = .{\n        .llvm_name = \"vcmpx-permlane-hazard\",\n        .description = \"TODO: describe me\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vgpr_index_mode)] = .{\n        .llvm_name = \"vgpr-index-mode\",\n        .description = \"Has VGPR mode register indexing\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vmem_to_scalar_write_hazard)] = .{\n        .llvm_name = \"vmem-to-scalar-write-hazard\",\n        .description = \"VMEM instruction followed by scalar writing to EXEC mask, M0 or SGPR leads to incorrect execution.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.volcanic_islands)] = .{\n        .llvm_name = \"volcanic-islands\",\n        .description = \"VOLCANIC_ISLANDS GPU generation\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"16_bit_insts\",\n            .ci_insts,\n            .dpp,\n            .ds_src2_insts,\n            .extended_image_insts,\n            .fast_denormal_f32,\n            .flat_address_space,\n            .fp64,\n            .gcn3_encoding,\n            .gfx7_gfx8_gfx9_insts,\n            .gfx8_insts,\n            .image_insts,\n            .int_clamp_insts,\n            .inv_2pi_inline_imm,\n            .localmemorysize65536,\n            .mad_mac_f32_insts,\n            .mimg_r128,\n            .movrel,\n            .s_memrealtime,\n            .s_memtime_inst,\n            .scalar_stores,\n            .sdwa,\n            .sdwa_mav,\n            .sdwa_out_mods_vopc,\n            .trig_reduced_range,\n            .unaligned_buffer_access,\n            .vgpr_index_mode,\n            .wavefrontsize64,\n        }),\n    };\n    result[@intFromEnum(Feature.vop3_literal)] = .{\n        .llvm_name = \"vop3-literal\",\n        .description = \"Can use one literal in VOP3\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vop3p)] = .{\n        .llvm_name = \"vop3p\",\n        .description = \"Has VOP3P packed instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vopd)] = .{\n        .llvm_name = \"vopd\",\n        .description = \"Has VOPD dual issue wave32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vscnt)] = .{\n        .llvm_name = \"vscnt\",\n        .description = \"Has separate store vscnt counter\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.wavefrontsize16)] = .{\n        .llvm_name = \"wavefrontsize16\",\n        .description = \"The number of threads per wavefront\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.wavefrontsize32)] = .{\n        .llvm_name = \"wavefrontsize32\",\n        .description = \"The number of threads per wavefront\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.wavefrontsize64)] = .{\n        .llvm_name = \"wavefrontsize64\",\n        .description = \"The number of threads per wavefront\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xnack)] = .{\n        .llvm_name = \"xnack\",\n        .description = \"Enable XNACK support\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xnack_support)] = .{\n        .llvm_name = \"xnack-support\",\n        .description = \"Hardware supports XNACK\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    @setEvalBranchQuota(10000);\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"32bit\")] = .{\n        .llvm_name = \"32bit\",\n        .description = \"Prefer 32-bit Thumb instrs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"8msecext\")] = .{\n        .llvm_name = \"8msecext\",\n        .description = \"Enable support for ARMv8-M Security Extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.a76)] = .{\n        .llvm_name = \"a76\",\n        .description = \"Cortex-A76 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aapcs_frame_chain)] = .{\n        .llvm_name = \"aapcs-frame-chain\",\n        .description = \"Create an AAPCS compliant frame chain\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aapcs_frame_chain_leaf)] = .{\n        .llvm_name = \"aapcs-frame-chain-leaf\",\n        .description = \"Create an AAPCS compliant frame chain for leaf functions\",\n        .dependencies = featureSet(&[_]Feature{\n            .aapcs_frame_chain,\n        }),\n    };\n    result[@intFromEnum(Feature.aclass)] = .{\n        .llvm_name = \"aclass\",\n        .description = \"Is application profile ('A' series)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.acquire_release)] = .{\n        .llvm_name = \"acquire-release\",\n        .description = \"Has v8 acquire/release (lda/ldaex  etc) instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aes)] = .{\n        .llvm_name = \"aes\",\n        .description = \"Enable AES support\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.atomics_32)] = .{\n        .llvm_name = \"atomics-32\",\n        .description = \"Assume that lock-free 32-bit atomics are available\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.avoid_movs_shop)] = .{\n        .llvm_name = \"avoid-movs-shop\",\n        .description = \"Avoid movs instructions with shifter operand\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.avoid_partial_cpsr)] = .{\n        .llvm_name = \"avoid-partial-cpsr\",\n        .description = \"Avoid CPSR partial update for OOO execution\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.bf16)] = .{\n        .llvm_name = \"bf16\",\n        .description = \"Enable support for BFloat16 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.big_endian_instructions)] = .{\n        .llvm_name = \"big-endian-instructions\",\n        .description = \"Expect instructions to be stored big-endian.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cde)] = .{\n        .llvm_name = \"cde\",\n        .description = \"Support CDE instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8m_main,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp0)] = .{\n        .llvm_name = \"cdecp0\",\n        .description = \"Coprocessor 0 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp1)] = .{\n        .llvm_name = \"cdecp1\",\n        .description = \"Coprocessor 1 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp2)] = .{\n        .llvm_name = \"cdecp2\",\n        .description = \"Coprocessor 2 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp3)] = .{\n        .llvm_name = \"cdecp3\",\n        .description = \"Coprocessor 3 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp4)] = .{\n        .llvm_name = \"cdecp4\",\n        .description = \"Coprocessor 4 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp5)] = .{\n        .llvm_name = \"cdecp5\",\n        .description = \"Coprocessor 5 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp6)] = .{\n        .llvm_name = \"cdecp6\",\n        .description = \"Coprocessor 6 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cdecp7)] = .{\n        .llvm_name = \"cdecp7\",\n        .description = \"Coprocessor 7 ISA is CDEv1\",\n        .dependencies = featureSet(&[_]Feature{\n            .cde,\n        }),\n    };\n    result[@intFromEnum(Feature.cheap_predicable_cpsr)] = .{\n        .llvm_name = \"cheap-predicable-cpsr\",\n        .description = \"Disable +1 predication cost for instructions updating CPSR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.clrbhb)] = .{\n        .llvm_name = \"clrbhb\",\n        .description = \"Enable Clear BHB instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crc)] = .{\n        .llvm_name = \"crc\",\n        .description = \"Enable support for CRC instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crypto)] = .{\n        .llvm_name = \"crypto\",\n        .description = \"Enable support for Cryptography extensions\",\n        .dependencies = featureSet(&[_]Feature{\n            .aes,\n            .sha2,\n        }),\n    };\n    result[@intFromEnum(Feature.d32)] = .{\n        .llvm_name = \"d32\",\n        .description = \"Extend FP to 32 double registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.db)] = .{\n        .llvm_name = \"db\",\n        .description = \"Has data barrier (dmb/dsb) instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dfb)] = .{\n        .llvm_name = \"dfb\",\n        .description = \"Has full data barrier (dfb) instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.disable_postra_scheduler)] = .{\n        .llvm_name = \"disable-postra-scheduler\",\n        .description = \"Don't schedule again after register allocation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dont_widen_vmovs)] = .{\n        .llvm_name = \"dont-widen-vmovs\",\n        .description = \"Don't widen VMOVS to VMOVD\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dotprod)] = .{\n        .llvm_name = \"dotprod\",\n        .description = \"Enable support for dot product instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.dsp)] = .{\n        .llvm_name = \"dsp\",\n        .description = \"Supports DSP instructions in ARM and/or Thumb2\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.execute_only)] = .{\n        .llvm_name = \"execute-only\",\n        .description = \"Enable the generation of execute only code.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.expand_fp_mlx)] = .{\n        .llvm_name = \"expand-fp-mlx\",\n        .description = \"Expand VFP/NEON MLA/MLS instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.exynos)] = .{\n        .llvm_name = \"exynos\",\n        .description = \"Samsung Exynos processors\",\n        .dependencies = featureSet(&[_]Feature{\n            .crc,\n            .crypto,\n            .expand_fp_mlx,\n            .fuse_aes,\n            .fuse_literals,\n            .hwdiv,\n            .hwdiv_arm,\n            .prof_unpr,\n            .ret_addr_stack,\n            .slow_fp_brcc,\n            .slow_vdup32,\n            .slow_vgetlni32,\n            .slowfpvfmx,\n            .slowfpvmlx,\n            .splat_vfp_neon,\n            .wide_stride_vfp,\n            .zcz,\n        }),\n    };\n    result[@intFromEnum(Feature.fix_cmse_cve_2021_35465)] = .{\n        .llvm_name = \"fix-cmse-cve-2021-35465\",\n        .description = \"Mitigate against the cve-2021-35465 security vulnurability\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fix_cortex_a57_aes_1742098)] = .{\n        .llvm_name = \"fix-cortex-a57-aes-1742098\",\n        .description = \"Work around Cortex-A57 Erratum 1742098 / Cortex-A72 Erratum 1655431 (AES)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp16)] = .{\n        .llvm_name = \"fp16\",\n        .description = \"Enable half-precision floating point\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp16fml)] = .{\n        .llvm_name = \"fp16fml\",\n        .description = \"Enable full half-precision floating point fml instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fullfp16,\n        }),\n    };\n    result[@intFromEnum(Feature.fp64)] = .{\n        .llvm_name = \"fp64\",\n        .description = \"Floating point unit supports double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpregs64,\n        }),\n    };\n    result[@intFromEnum(Feature.fp_armv8)] = .{\n        .llvm_name = \"fp-armv8\",\n        .description = \"Enable ARMv8 FP\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8d16,\n            .fp_armv8sp,\n            .vfp4,\n        }),\n    };\n    result[@intFromEnum(Feature.fp_armv8d16)] = .{\n        .llvm_name = \"fp-armv8d16\",\n        .description = \"Enable ARMv8 FP with only 16 d-registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8d16sp,\n            .vfp4d16,\n        }),\n    };\n    result[@intFromEnum(Feature.fp_armv8d16sp)] = .{\n        .llvm_name = \"fp-armv8d16sp\",\n        .description = \"Enable ARMv8 FP with only 16 d-registers and no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp4d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.fp_armv8sp)] = .{\n        .llvm_name = \"fp-armv8sp\",\n        .description = \"Enable ARMv8 FP with no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8d16sp,\n            .vfp4sp,\n        }),\n    };\n    result[@intFromEnum(Feature.fpao)] = .{\n        .llvm_name = \"fpao\",\n        .description = \"Enable fast computation of positive address offsets\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpregs)] = .{\n        .llvm_name = \"fpregs\",\n        .description = \"Enable FP registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpregs16)] = .{\n        .llvm_name = \"fpregs16\",\n        .description = \"Enable 16-bit FP registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpregs,\n        }),\n    };\n    result[@intFromEnum(Feature.fpregs64)] = .{\n        .llvm_name = \"fpregs64\",\n        .description = \"Enable 64-bit FP registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpregs,\n        }),\n    };\n    result[@intFromEnum(Feature.fullfp16)] = .{\n        .llvm_name = \"fullfp16\",\n        .description = \"Enable full half-precision floating point\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp_armv8d16sp,\n            .fpregs16,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_aes)] = .{\n        .llvm_name = \"fuse-aes\",\n        .description = \"CPU fuses AES crypto operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fuse_literals)] = .{\n        .llvm_name = \"fuse-literals\",\n        .description = \"CPU fuses literal generation operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_blr)] = .{\n        .llvm_name = \"harden-sls-blr\",\n        .description = \"Harden against straight line speculation across indirect calls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_nocomdat)] = .{\n        .llvm_name = \"harden-sls-nocomdat\",\n        .description = \"Generate thunk code for SLS mitigation in the normal text section\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_retbr)] = .{\n        .llvm_name = \"harden-sls-retbr\",\n        .description = \"Harden against straight line speculation across RETurn and BranchRegister instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.has_v4t)] = .{\n        .llvm_name = \"v4t\",\n        .description = \"Support ARM v4T instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.has_v5t)] = .{\n        .llvm_name = \"v5t\",\n        .description = \"Support ARM v5T instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v4t,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v5te)] = .{\n        .llvm_name = \"v5te\",\n        .description = \"Support ARM v5TE, v5TEj, and v5TExp instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v5t,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v6)] = .{\n        .llvm_name = \"v6\",\n        .description = \"Support ARM v6 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v5te,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v6k)] = .{\n        .llvm_name = \"v6k\",\n        .description = \"Support ARM v6k instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v6m)] = .{\n        .llvm_name = \"v6m\",\n        .description = \"Support ARM v6M instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v6t2)] = .{\n        .llvm_name = \"v6t2\",\n        .description = \"Support ARM v6t2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6k,\n            .has_v8m,\n            .thumb2,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v7)] = .{\n        .llvm_name = \"v7\",\n        .description = \"Support ARM v7 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6t2,\n            .has_v7clrex,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v7clrex)] = .{\n        .llvm_name = \"v7clrex\",\n        .description = \"Has v7 clrex instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.has_v8)] = .{\n        .llvm_name = \"v8\",\n        .description = \"Support ARM v8 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .acquire_release,\n            .has_v7,\n            .perfmon,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_1a)] = .{\n        .llvm_name = \"v8.1a\",\n        .description = \"Support ARM v8.1a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_1m_main)] = .{\n        .llvm_name = \"v8.1m.main\",\n        .description = \"Support ARM v8-1M Mainline instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8m_main,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_2a)] = .{\n        .llvm_name = \"v8.2a\",\n        .description = \"Support ARM v8.2a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_1a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_3a)] = .{\n        .llvm_name = \"v8.3a\",\n        .description = \"Support ARM v8.3a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_2a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_4a)] = .{\n        .llvm_name = \"v8.4a\",\n        .description = \"Support ARM v8.4a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .dotprod,\n            .has_v8_3a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_5a)] = .{\n        .llvm_name = \"v8.5a\",\n        .description = \"Support ARM v8.5a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_4a,\n            .sb,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_6a)] = .{\n        .llvm_name = \"v8.6a\",\n        .description = \"Support ARM v8.6a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .bf16,\n            .has_v8_5a,\n            .i8mm,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_7a)] = .{\n        .llvm_name = \"v8.7a\",\n        .description = \"Support ARM v8.7a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_6a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_8a)] = .{\n        .llvm_name = \"v8.8a\",\n        .description = \"Support ARM v8.8a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_7a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8_9a)] = .{\n        .llvm_name = \"v8.9a\",\n        .description = \"Support ARM v8.9a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .clrbhb,\n            .has_v8_8a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8m)] = .{\n        .llvm_name = \"v8m\",\n        .description = \"Support ARM v8M Baseline instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6m,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v8m_main)] = .{\n        .llvm_name = \"v8m.main\",\n        .description = \"Support ARM v8M Mainline instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v7,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v9_1a)] = .{\n        .llvm_name = \"v9.1a\",\n        .description = \"Support ARM v9.1a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_6a,\n            .has_v9a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v9_2a)] = .{\n        .llvm_name = \"v9.2a\",\n        .description = \"Support ARM v9.2a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_7a,\n            .has_v9_1a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v9_3a)] = .{\n        .llvm_name = \"v9.3a\",\n        .description = \"Support ARM v9.3a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_8a,\n            .has_v9_2a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v9_4a)] = .{\n        .llvm_name = \"v9.4a\",\n        .description = \"Support ARM v9.4a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_9a,\n            .has_v9_3a,\n        }),\n    };\n    result[@intFromEnum(Feature.has_v9a)] = .{\n        .llvm_name = \"v9a\",\n        .description = \"Support ARM v9a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v8_5a,\n        }),\n    };\n    result[@intFromEnum(Feature.hwdiv)] = .{\n        .llvm_name = \"hwdiv\",\n        .description = \"Enable divide instructions in Thumb\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hwdiv_arm)] = .{\n        .llvm_name = \"hwdiv-arm\",\n        .description = \"Enable divide instructions in ARM mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.i8mm)] = .{\n        .llvm_name = \"i8mm\",\n        .description = \"Enable Matrix Multiply Int8 Extension\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.iwmmxt)] = .{\n        .llvm_name = \"iwmmxt\",\n        .description = \"ARMv5te architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v5te,\n        }),\n    };\n    result[@intFromEnum(Feature.iwmmxt2)] = .{\n        .llvm_name = \"iwmmxt2\",\n        .description = \"ARMv5te architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v5te,\n        }),\n    };\n    result[@intFromEnum(Feature.lob)] = .{\n        .llvm_name = \"lob\",\n        .description = \"Enable Low Overhead Branch extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.long_calls)] = .{\n        .llvm_name = \"long-calls\",\n        .description = \"Generate calls via indirect call instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.loop_align)] = .{\n        .llvm_name = \"loop-align\",\n        .description = \"Prefer 32-bit alignment for loops\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.m3)] = .{\n        .llvm_name = \"m3\",\n        .description = \"Cortex-M3 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mclass)] = .{\n        .llvm_name = \"mclass\",\n        .description = \"Is microcontroller profile ('M' series)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mp)] = .{\n        .llvm_name = \"mp\",\n        .description = \"Supports Multiprocessing extension\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.muxed_units)] = .{\n        .llvm_name = \"muxed-units\",\n        .description = \"Has muxed AGU and NEON/FPU\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mve)] = .{\n        .llvm_name = \"mve\",\n        .description = \"Support M-Class Vector Extension with integer ops\",\n        .dependencies = featureSet(&[_]Feature{\n            .dsp,\n            .fpregs16,\n            .fpregs64,\n            .has_v8_1m_main,\n        }),\n    };\n    result[@intFromEnum(Feature.mve1beat)] = .{\n        .llvm_name = \"mve1beat\",\n        .description = \"Model MVE instructions as a 1 beat per tick architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mve2beat)] = .{\n        .llvm_name = \"mve2beat\",\n        .description = \"Model MVE instructions as a 2 beats per tick architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mve4beat)] = .{\n        .llvm_name = \"mve4beat\",\n        .description = \"Model MVE instructions as a 4 beats per tick architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mve_fp)] = .{\n        .llvm_name = \"mve.fp\",\n        .description = \"Support M-Class Vector Extension with integer and floating ops\",\n        .dependencies = featureSet(&[_]Feature{\n            .fullfp16,\n            .mve,\n        }),\n    };\n    result[@intFromEnum(Feature.nacl_trap)] = .{\n        .llvm_name = \"nacl-trap\",\n        .description = \"NaCl trap\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.neon)] = .{\n        .llvm_name = \"neon\",\n        .description = \"Enable NEON instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp3,\n        }),\n    };\n    result[@intFromEnum(Feature.neon_fpmovs)] = .{\n        .llvm_name = \"neon-fpmovs\",\n        .description = \"Convert VMOVSR, VMOVRS, VMOVS to NEON\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.neonfp)] = .{\n        .llvm_name = \"neonfp\",\n        .description = \"Use NEON for single precision FP\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_branch_predictor)] = .{\n        .llvm_name = \"no-branch-predictor\",\n        .description = \"Has no branch predictor\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bti_at_return_twice)] = .{\n        .llvm_name = \"no-bti-at-return-twice\",\n        .description = \"Don't place a BTI instruction after a return-twice\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_movt)] = .{\n        .llvm_name = \"no-movt\",\n        .description = \"Don't use movt/movw pairs for 32-bit imms\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_neg_immediates)] = .{\n        .llvm_name = \"no-neg-immediates\",\n        .description = \"Convert immediates and instructions to their negated or complemented equivalent when the immediate does not fit in the encoding.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.noarm)] = .{\n        .llvm_name = \"noarm\",\n        .description = \"Does not support ARM mode execution\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nonpipelined_vfp)] = .{\n        .llvm_name = \"nonpipelined-vfp\",\n        .description = \"VFP instructions are not pipelined\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pacbti)] = .{\n        .llvm_name = \"pacbti\",\n        .description = \"Enable Pointer Authentication and Branch Target Identification\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.perfmon)] = .{\n        .llvm_name = \"perfmon\",\n        .description = \"Enable support for Performance Monitor extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_ishst)] = .{\n        .llvm_name = \"prefer-ishst\",\n        .description = \"Prefer ISHST barriers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_vmovsr)] = .{\n        .llvm_name = \"prefer-vmovsr\",\n        .description = \"Prefer VMOVSR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prof_unpr)] = .{\n        .llvm_name = \"prof-unpr\",\n        .description = \"Is profitable to unpredicate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.r4)] = .{\n        .llvm_name = \"r4\",\n        .description = \"Cortex-R4 ARM processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ras)] = .{\n        .llvm_name = \"ras\",\n        .description = \"Enable Reliability, Availability and Serviceability extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rclass)] = .{\n        .llvm_name = \"rclass\",\n        .description = \"Is realtime profile ('R' series)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.read_tp_tpidrprw)] = .{\n        .llvm_name = \"read-tp-tpidrprw\",\n        .description = \"Reading thread pointer from TPIDRPRW register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.read_tp_tpidruro)] = .{\n        .llvm_name = \"read-tp-tpidruro\",\n        .description = \"Reading thread pointer from TPIDRURO register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.read_tp_tpidrurw)] = .{\n        .llvm_name = \"read-tp-tpidrurw\",\n        .description = \"Reading thread pointer from TPIDRURW register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_r9)] = .{\n        .llvm_name = \"reserve-r9\",\n        .description = \"Reserve R9, making it unavailable as GPR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ret_addr_stack)] = .{\n        .llvm_name = \"ret-addr-stack\",\n        .description = \"Has return address stack\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sb)] = .{\n        .llvm_name = \"sb\",\n        .description = \"Enable v8.5a Speculation Barrier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sha2)] = .{\n        .llvm_name = \"sha2\",\n        .description = \"Enable SHA1 and SHA256 support\",\n        .dependencies = featureSet(&[_]Feature{\n            .neon,\n        }),\n    };\n    result[@intFromEnum(Feature.slow_fp_brcc)] = .{\n        .llvm_name = \"slow-fp-brcc\",\n        .description = \"FP compare + branch is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_load_D_subreg)] = .{\n        .llvm_name = \"slow-load-D-subreg\",\n        .description = \"Loading into D subregs is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_odd_reg)] = .{\n        .llvm_name = \"slow-odd-reg\",\n        .description = \"VLDM/VSTM starting with an odd register is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_vdup32)] = .{\n        .llvm_name = \"slow-vdup32\",\n        .description = \"Has slow VDUP32 - prefer VMOV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_vgetlni32)] = .{\n        .llvm_name = \"slow-vgetlni32\",\n        .description = \"Has slow VGETLNi32 - prefer VMOV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slowfpvfmx)] = .{\n        .llvm_name = \"slowfpvfmx\",\n        .description = \"Disable VFP / NEON FMA instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slowfpvmlx)] = .{\n        .llvm_name = \"slowfpvmlx\",\n        .description = \"Disable VFP / NEON MAC instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_float)] = .{\n        .llvm_name = \"soft-float\",\n        .description = \"Use software floating point features.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.splat_vfp_neon)] = .{\n        .llvm_name = \"splat-vfp-neon\",\n        .description = \"Splat register from VFP to NEON\",\n        .dependencies = featureSet(&[_]Feature{\n            .dont_widen_vmovs,\n        }),\n    };\n    result[@intFromEnum(Feature.strict_align)] = .{\n        .llvm_name = \"strict-align\",\n        .description = \"Disallow all unaligned memory access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.swift)] = .{\n        .llvm_name = \"swift\",\n        .description = \"Swift ARM processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.thumb2)] = .{\n        .llvm_name = \"thumb2\",\n        .description = \"Enable Thumb2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.thumb_mode)] = .{\n        .llvm_name = \"thumb-mode\",\n        .description = \"Thumb mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.trustzone)] = .{\n        .llvm_name = \"trustzone\",\n        .description = \"Enable support for TrustZone security extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_mipipeliner)] = .{\n        .llvm_name = \"use-mipipeliner\",\n        .description = \"Use the MachinePipeliner\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_misched)] = .{\n        .llvm_name = \"use-misched\",\n        .description = \"Use the MachineScheduler\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v2)] = .{\n        .llvm_name = null,\n        .description = \"ARMv2 architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v2a)] = .{\n        .llvm_name = null,\n        .description = \"ARMv2a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v3)] = .{\n        .llvm_name = null,\n        .description = \"ARMv3 architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v3m)] = .{\n        .llvm_name = null,\n        .description = \"ARMv3m architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v4)] = .{\n        .llvm_name = \"armv4\",\n        .description = \"ARMv4 architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v4t)] = .{\n        .llvm_name = \"armv4t\",\n        .description = \"ARMv4t architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v4t,\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v5t)] = .{\n        .llvm_name = \"armv5t\",\n        .description = \"ARMv5t architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v5t,\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v5te)] = .{\n        .llvm_name = \"armv5te\",\n        .description = \"ARMv5te architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v5te,\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v5tej)] = .{\n        .llvm_name = \"armv5tej\",\n        .description = \"ARMv5tej architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v5te,\n            .strict_align,\n        }),\n    };\n    result[@intFromEnum(Feature.v6)] = .{\n        .llvm_name = \"armv6\",\n        .description = \"ARMv6 architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .dsp,\n            .has_v6,\n        }),\n    };\n    result[@intFromEnum(Feature.v6j)] = .{\n        .llvm_name = \"armv6j\",\n        .description = \"ARMv7a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v6,\n        }),\n    };\n    result[@intFromEnum(Feature.v6k)] = .{\n        .llvm_name = \"armv6k\",\n        .description = \"ARMv6k architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6k,\n        }),\n    };\n    result[@intFromEnum(Feature.v6kz)] = .{\n        .llvm_name = \"armv6kz\",\n        .description = \"ARMv6kz architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .has_v6k,\n            .trustzone,\n        }),\n    };\n    result[@intFromEnum(Feature.v6m)] = .{\n        .llvm_name = \"armv6-m\",\n        .description = \"ARMv6m architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .db,\n            .has_v6m,\n            .mclass,\n            .noarm,\n            .strict_align,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v6sm)] = .{\n        .llvm_name = \"armv6s-m\",\n        .description = \"ARMv6sm architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .db,\n            .has_v6m,\n            .mclass,\n            .noarm,\n            .strict_align,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v6t2)] = .{\n        .llvm_name = \"armv6t2\",\n        .description = \"ARMv6t2 architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .dsp,\n            .has_v6t2,\n        }),\n    };\n    result[@intFromEnum(Feature.v7a)] = .{\n        .llvm_name = \"armv7-a\",\n        .description = \"ARMv7a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .db,\n            .dsp,\n            .has_v7,\n            .neon,\n            .perfmon,\n        }),\n    };\n    result[@intFromEnum(Feature.v7em)] = .{\n        .llvm_name = \"armv7e-m\",\n        .description = \"ARMv7em architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .db,\n            .dsp,\n            .has_v7,\n            .hwdiv,\n            .mclass,\n            .noarm,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v7k)] = .{\n        .llvm_name = \"armv7k\",\n        .description = \"ARMv7a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v7a,\n        }),\n    };\n    result[@intFromEnum(Feature.v7m)] = .{\n        .llvm_name = \"armv7-m\",\n        .description = \"ARMv7m architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .db,\n            .has_v7,\n            .hwdiv,\n            .mclass,\n            .noarm,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v7r)] = .{\n        .llvm_name = \"armv7-r\",\n        .description = \"ARMv7r architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .db,\n            .dsp,\n            .has_v7,\n            .hwdiv,\n            .perfmon,\n            .rclass,\n        }),\n    };\n    result[@intFromEnum(Feature.v7s)] = .{\n        .llvm_name = \"armv7s\",\n        .description = \"ARMv7a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v7a,\n        }),\n    };\n    result[@intFromEnum(Feature.v7ve)] = .{\n        .llvm_name = \"armv7ve\",\n        .description = \"ARMv7ve architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .db,\n            .dsp,\n            .has_v7,\n            .mp,\n            .neon,\n            .perfmon,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_1a)] = .{\n        .llvm_name = \"armv8.1-a\",\n        .description = \"ARMv81a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_1a,\n            .mp,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_1m_main)] = .{\n        .llvm_name = \"armv8.1-m.main\",\n        .description = \"ARMv81mMainline architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"8msecext\",\n            .acquire_release,\n            .db,\n            .has_v8_1m_main,\n            .hwdiv,\n            .lob,\n            .mclass,\n            .noarm,\n            .ras,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_2a)] = .{\n        .llvm_name = \"armv8.2-a\",\n        .description = \"ARMv82a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_2a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_3a)] = .{\n        .llvm_name = \"armv8.3-a\",\n        .description = \"ARMv83a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_3a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_4a)] = .{\n        .llvm_name = \"armv8.4-a\",\n        .description = \"ARMv84a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_4a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_5a)] = .{\n        .llvm_name = \"armv8.5-a\",\n        .description = \"ARMv85a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_5a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_6a)] = .{\n        .llvm_name = \"armv8.6-a\",\n        .description = \"ARMv86a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_6a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_7a)] = .{\n        .llvm_name = \"armv8.7-a\",\n        .description = \"ARMv87a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_7a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_8a)] = .{\n        .llvm_name = \"armv8.8-a\",\n        .description = \"ARMv88a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_8a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8_9a)] = .{\n        .llvm_name = \"armv8.9-a\",\n        .description = \"ARMv89a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8_9a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8a)] = .{\n        .llvm_name = \"armv8-a\",\n        .description = \"ARMv8a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v8,\n            .mp,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v8m)] = .{\n        .llvm_name = \"armv8-m.base\",\n        .description = \"ARMv8mBaseline architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"8msecext\",\n            .acquire_release,\n            .db,\n            .has_v7clrex,\n            .has_v8m,\n            .hwdiv,\n            .mclass,\n            .noarm,\n            .strict_align,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v8m_main)] = .{\n        .llvm_name = \"armv8-m.main\",\n        .description = \"ARMv8mMainline architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"8msecext\",\n            .acquire_release,\n            .db,\n            .has_v8m_main,\n            .hwdiv,\n            .mclass,\n            .noarm,\n            .thumb_mode,\n        }),\n    };\n    result[@intFromEnum(Feature.v8r)] = .{\n        .llvm_name = \"armv8-r\",\n        .description = \"ARMv8r architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .crc,\n            .db,\n            .dfb,\n            .dsp,\n            .fp_armv8,\n            .has_v8,\n            .mp,\n            .neon,\n            .rclass,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_1a)] = .{\n        .llvm_name = \"armv9.1-a\",\n        .description = \"ARMv91a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v9_1a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_2a)] = .{\n        .llvm_name = \"armv9.2-a\",\n        .description = \"ARMv92a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v9_2a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_3a)] = .{\n        .llvm_name = \"armv9.3-a\",\n        .description = \"ARMv93a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .crypto,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v9_3a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v9_4a)] = .{\n        .llvm_name = \"armv9.4-a\",\n        .description = \"ARMv94a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v9_4a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.v9a)] = .{\n        .llvm_name = \"armv9-a\",\n        .description = \"ARMv9a architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .aclass,\n            .crc,\n            .db,\n            .dsp,\n            .fp_armv8,\n            .has_v9a,\n            .mp,\n            .ras,\n            .trustzone,\n            .virtualization,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp2)] = .{\n        .llvm_name = \"vfp2\",\n        .description = \"Enable VFP2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp64,\n            .vfp2sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp2sp)] = .{\n        .llvm_name = \"vfp2sp\",\n        .description = \"Enable VFP2 instructions with no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpregs,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp3)] = .{\n        .llvm_name = \"vfp3\",\n        .description = \"Enable VFP3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp3d16,\n            .vfp3sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp3d16)] = .{\n        .llvm_name = \"vfp3d16\",\n        .description = \"Enable VFP3 instructions with only 16 d-registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp2,\n            .vfp3d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp3d16sp)] = .{\n        .llvm_name = \"vfp3d16sp\",\n        .description = \"Enable VFP3 instructions with only 16 d-registers and no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp2sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp3sp)] = .{\n        .llvm_name = \"vfp3sp\",\n        .description = \"Enable VFP3 instructions with no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .d32,\n            .vfp3d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp4)] = .{\n        .llvm_name = \"vfp4\",\n        .description = \"Enable VFP4 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp3,\n            .vfp4d16,\n            .vfp4sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp4d16)] = .{\n        .llvm_name = \"vfp4d16\",\n        .description = \"Enable VFP4 instructions with only 16 d-registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp3d16,\n            .vfp4d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp4d16sp)] = .{\n        .llvm_name = \"vfp4d16sp\",\n        .description = \"Enable VFP4 instructions with only 16 d-registers and no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp16,\n            .vfp3d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.vfp4sp)] = .{\n        .llvm_name = \"vfp4sp\",\n        .description = \"Enable VFP4 instructions with no double precision\",\n        .dependencies = featureSet(&[_]Feature{\n            .vfp3sp,\n            .vfp4d16sp,\n        }),\n    };\n    result[@intFromEnum(Feature.virtualization)] = .{\n        .llvm_name = \"virtualization\",\n        .description = \"Supports Virtualization extension\",\n        .dependencies = featureSet(&[_]Feature{\n            .hwdiv,\n            .hwdiv_arm,\n        }),\n    };\n    result[@intFromEnum(Feature.vldn_align)] = .{\n        .llvm_name = \"vldn-align\",\n        .description = \"Check for VLDn unaligned access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vmlx_forwarding)] = .{\n        .llvm_name = \"vmlx-forwarding\",\n        .description = \"Has multiplier accumulator forwarding\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vmlx_hazards)] = .{\n        .llvm_name = \"vmlx-hazards\",\n        .description = \"Has VMLx hazards\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.wide_stride_vfp)] = .{\n        .llvm_name = \"wide-stride-vfp\",\n        .description = \"Use a wide stride when allocating VFP registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xscale)] = .{\n        .llvm_name = \"xscale\",\n        .description = \"ARMv5te architecture\",\n        .dependencies = featureSet(&[_]Feature{\n            .v5te,\n        }),\n    };\n    result[@intFromEnum(Feature.zcz)] = .{\n        .llvm_name = \"zcz\",\n        .description = \"Has zero-cycle zeroing instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.addsubiw)] = .{\n        .llvm_name = \"addsubiw\",\n        .description = \"Enable 16-bit register-immediate addition and subtraction instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.avr0)] = .{\n        .llvm_name = \"avr0\",\n        .description = \"The device is a part of the avr0 family\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.avr1)] = .{\n        .llvm_name = \"avr1\",\n        .description = \"The device is a part of the avr1 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr0,\n            .lpm,\n            .memmappedregs,\n        }),\n    };\n    result[@intFromEnum(Feature.avr2)] = .{\n        .llvm_name = \"avr2\",\n        .description = \"The device is a part of the avr2 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .addsubiw,\n            .avr1,\n            .ijmpcall,\n            .sram,\n        }),\n    };\n    result[@intFromEnum(Feature.avr25)] = .{\n        .llvm_name = \"avr25\",\n        .description = \"The device is a part of the avr25 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr2,\n            .@\"break\",\n            .lpmx,\n            .movw,\n            .spm,\n        }),\n    };\n    result[@intFromEnum(Feature.avr3)] = .{\n        .llvm_name = \"avr3\",\n        .description = \"The device is a part of the avr3 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr2,\n            .jmpcall,\n        }),\n    };\n    result[@intFromEnum(Feature.avr31)] = .{\n        .llvm_name = \"avr31\",\n        .description = \"The device is a part of the avr31 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr3,\n            .elpm,\n        }),\n    };\n    result[@intFromEnum(Feature.avr35)] = .{\n        .llvm_name = \"avr35\",\n        .description = \"The device is a part of the avr35 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr3,\n            .@\"break\",\n            .lpmx,\n            .movw,\n            .spm,\n        }),\n    };\n    result[@intFromEnum(Feature.avr4)] = .{\n        .llvm_name = \"avr4\",\n        .description = \"The device is a part of the avr4 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr2,\n            .@\"break\",\n            .lpmx,\n            .movw,\n            .mul,\n            .spm,\n        }),\n    };\n    result[@intFromEnum(Feature.avr5)] = .{\n        .llvm_name = \"avr5\",\n        .description = \"The device is a part of the avr5 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr3,\n            .@\"break\",\n            .lpmx,\n            .movw,\n            .mul,\n            .spm,\n        }),\n    };\n    result[@intFromEnum(Feature.avr51)] = .{\n        .llvm_name = \"avr51\",\n        .description = \"The device is a part of the avr51 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr5,\n            .elpm,\n            .elpmx,\n        }),\n    };\n    result[@intFromEnum(Feature.avr6)] = .{\n        .llvm_name = \"avr6\",\n        .description = \"The device is a part of the avr6 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr51,\n            .eijmpcall,\n        }),\n    };\n    result[@intFromEnum(Feature.avrtiny)] = .{\n        .llvm_name = \"avrtiny\",\n        .description = \"The device is a part of the avrtiny family\",\n        .dependencies = featureSet(&[_]Feature{\n            .avr0,\n            .@\"break\",\n            .smallstack,\n            .sram,\n            .tinyencoding,\n        }),\n    };\n    result[@intFromEnum(Feature.@\"break\")] = .{\n        .llvm_name = \"break\",\n        .description = \"The device supports the `BREAK` debugging instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.des)] = .{\n        .llvm_name = \"des\",\n        .description = \"The device supports the `DES k` encryption instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.eijmpcall)] = .{\n        .llvm_name = \"eijmpcall\",\n        .description = \"The device supports the `EIJMP`/`EICALL` instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.elpm)] = .{\n        .llvm_name = \"elpm\",\n        .description = \"The device supports the ELPM instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.elpmx)] = .{\n        .llvm_name = \"elpmx\",\n        .description = \"The device supports the `ELPM Rd, Z[+]` instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ijmpcall)] = .{\n        .llvm_name = \"ijmpcall\",\n        .description = \"The device supports `IJMP`/`ICALL`instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.jmpcall)] = .{\n        .llvm_name = \"jmpcall\",\n        .description = \"The device supports the `JMP` and `CALL` instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lowbytefirst)] = .{\n        .llvm_name = \"lowbytefirst\",\n        .description = \"Do the low byte first when writing a 16-bit port or storing a 16-bit word\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lpm)] = .{\n        .llvm_name = \"lpm\",\n        .description = \"The device supports the `LPM` instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lpmx)] = .{\n        .llvm_name = \"lpmx\",\n        .description = \"The device supports the `LPM Rd, Z[+]` instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.memmappedregs)] = .{\n        .llvm_name = \"memmappedregs\",\n        .description = \"The device has CPU registers mapped in data address space\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.movw)] = .{\n        .llvm_name = \"movw\",\n        .description = \"The device supports the 16-bit MOVW instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mul)] = .{\n        .llvm_name = \"mul\",\n        .description = \"The device supports the multiplication instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rmw)] = .{\n        .llvm_name = \"rmw\",\n        .description = \"The device supports the read-write-modify instructions: XCH, LAS, LAC, LAT\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.smallstack)] = .{\n        .llvm_name = \"smallstack\",\n        .description = \"The device has an 8-bit stack pointer\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.special)] = .{\n        .llvm_name = \"special\",\n        .description = \"Enable use of the entire instruction set - used for debugging\",\n        .dependencies = featureSet(&[_]Feature{\n            .addsubiw,\n            .@\"break\",\n            .des,\n            .eijmpcall,\n            .elpm,\n            .elpmx,\n            .ijmpcall,\n            .jmpcall,\n            .lpm,\n            .lpmx,\n            .memmappedregs,\n            .movw,\n            .mul,\n            .rmw,\n            .spm,\n            .spmx,\n            .sram,\n        }),\n    };\n    result[@intFromEnum(Feature.spm)] = .{\n        .llvm_name = \"spm\",\n        .description = \"The device supports the `SPM` instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.spmx)] = .{\n        .llvm_name = \"spmx\",\n        .description = \"The device supports the `SPM Z+` instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sram)] = .{\n        .llvm_name = \"sram\",\n        .description = \"The device has random access memory\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tinyencoding)] = .{\n        .llvm_name = \"tinyencoding\",\n        .description = \"The device has Tiny core specific instruction encodings\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xmega)] = .{\n        .llvm_name = \"xmega\",\n        .description = \"The device is a part of the xmega family\",\n        .dependencies = featureSet(&[_]Feature{\n            .addsubiw,\n            .avr0,\n            .@\"break\",\n            .des,\n            .eijmpcall,\n            .elpm,\n            .elpmx,\n            .ijmpcall,\n            .jmpcall,\n            .lowbytefirst,\n            .lpm,\n            .lpmx,\n            .movw,\n            .mul,\n            .spm,\n            .spmx,\n            .sram,\n        }),\n    };\n    result[@intFromEnum(Feature.xmega3)] = .{\n        .llvm_name = \"xmega3\",\n        .description = \"The device is a part of the xmega3 family\",\n        .dependencies = featureSet(&[_]Feature{\n            .addsubiw,\n            .avr0,\n            .@\"break\",\n            .ijmpcall,\n            .jmpcall,\n            .lowbytefirst,\n            .lpm,\n            .lpmx,\n            .movw,\n            .mul,\n            .sram,\n        }),\n    };\n    result[@intFromEnum(Feature.xmegau)] = .{\n        .llvm_name = \"xmegau\",\n        .description = \"The device is a part of the xmegau family\",\n        .dependencies = featureSet(&[_]Feature{\n            .rmw,\n            .xmega,\n        }),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.alu32)] = .{\n        .llvm_name = \"alu32\",\n        .description = \"Enable ALU32 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dummy)] = .{\n        .llvm_name = \"dummy\",\n        .description = \"unused feature\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dwarfris)] = .{\n        .llvm_name = \"dwarfris\",\n        .description = \"Disable MCAsmInfo DwarfUsesRelocationsAcrossSections\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"10e60\")] = .{\n        .llvm_name = \"10e60\",\n        .description = \"Support CSKY 10e60 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"7e10\",\n        }),\n    };\n    result[@intFromEnum(Feature.@\"2e3\")] = .{\n        .llvm_name = \"2e3\",\n        .description = \"Support CSKY 2e3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .e2,\n        }),\n    };\n    result[@intFromEnum(Feature.@\"3e3r1\")] = .{\n        .llvm_name = \"3e3r1\",\n        .description = \"Support CSKY 3e3r1 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"3e3r2\")] = .{\n        .llvm_name = \"3e3r2\",\n        .description = \"Support CSKY 3e3r2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"3e3r1\",\n            .doloop,\n        }),\n    };\n    result[@intFromEnum(Feature.@\"3e3r3\")] = .{\n        .llvm_name = \"3e3r3\",\n        .description = \"Support CSKY 3e3r3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .doloop,\n        }),\n    };\n    result[@intFromEnum(Feature.@\"3e7\")] = .{\n        .llvm_name = \"3e7\",\n        .description = \"Support CSKY 3e7 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"2e3\",\n        }),\n    };\n    result[@intFromEnum(Feature.@\"7e10\")] = .{\n        .llvm_name = \"7e10\",\n        .description = \"Support CSKY 7e10 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"3e7\",\n        }),\n    };\n    result[@intFromEnum(Feature.btst16)] = .{\n        .llvm_name = \"btst16\",\n        .description = \"Use the 16-bit btsti instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cache)] = .{\n        .llvm_name = \"cache\",\n        .description = \"Enable cache\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ccrt)] = .{\n        .llvm_name = \"ccrt\",\n        .description = \"Use CSKY compiler runtime\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck801)] = .{\n        .llvm_name = \"ck801\",\n        .description = \"CSKY ck801 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck802)] = .{\n        .llvm_name = \"ck802\",\n        .description = \"CSKY ck802 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck803)] = .{\n        .llvm_name = \"ck803\",\n        .description = \"CSKY ck803 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck803s)] = .{\n        .llvm_name = \"ck803s\",\n        .description = \"CSKY ck803s processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck804)] = .{\n        .llvm_name = \"ck804\",\n        .description = \"CSKY ck804 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck805)] = .{\n        .llvm_name = \"ck805\",\n        .description = \"CSKY ck805 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck807)] = .{\n        .llvm_name = \"ck807\",\n        .description = \"CSKY ck807 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck810)] = .{\n        .llvm_name = \"ck810\",\n        .description = \"CSKY ck810 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck810v)] = .{\n        .llvm_name = \"ck810v\",\n        .description = \"CSKY ck810v processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck860)] = .{\n        .llvm_name = \"ck860\",\n        .description = \"CSKY ck860 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ck860v)] = .{\n        .llvm_name = \"ck860v\",\n        .description = \"CSKY ck860v processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.constpool)] = .{\n        .llvm_name = \"constpool\",\n        .description = \"Dump the constant pool by compiler\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.doloop)] = .{\n        .llvm_name = \"doloop\",\n        .description = \"Enable doloop instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dsp1e2)] = .{\n        .llvm_name = \"dsp1e2\",\n        .description = \"Support CSKY dsp1e2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dsp_silan)] = .{\n        .llvm_name = \"dsp_silan\",\n        .description = \"Enable DSP Silan instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dspe60)] = .{\n        .llvm_name = \"dspe60\",\n        .description = \"Support CSKY dspe60 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dspv2)] = .{\n        .llvm_name = \"dspv2\",\n        .description = \"Enable DSP V2.0 instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.e1)] = .{\n        .llvm_name = \"e1\",\n        .description = \"Support CSKY e1 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .elrw,\n        }),\n    };\n    result[@intFromEnum(Feature.e2)] = .{\n        .llvm_name = \"e2\",\n        .description = \"Support CSKY e2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .e1,\n        }),\n    };\n    result[@intFromEnum(Feature.edsp)] = .{\n        .llvm_name = \"edsp\",\n        .description = \"Enable DSP instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.elrw)] = .{\n        .llvm_name = \"elrw\",\n        .description = \"Use the extend LRW instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fdivdu)] = .{\n        .llvm_name = \"fdivdu\",\n        .description = \"Enable float divide instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.float1e2)] = .{\n        .llvm_name = \"float1e2\",\n        .description = \"Support CSKY float1e2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.float1e3)] = .{\n        .llvm_name = \"float1e3\",\n        .description = \"Support CSKY float1e3 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.float3e4)] = .{\n        .llvm_name = \"float3e4\",\n        .description = \"Support CSKY float3e4 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.float7e60)] = .{\n        .llvm_name = \"float7e60\",\n        .description = \"Support CSKY float7e60 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.floate1)] = .{\n        .llvm_name = \"floate1\",\n        .description = \"Support CSKY floate1 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv2_df)] = .{\n        .llvm_name = \"fpuv2_df\",\n        .description = \"Enable FPUv2 double float instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv2_sf)] = .{\n        .llvm_name = \"fpuv2_sf\",\n        .description = \"Enable FPUv2 single float instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv3_df)] = .{\n        .llvm_name = \"fpuv3_df\",\n        .description = \"Enable FPUv3 double float instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv3_hf)] = .{\n        .llvm_name = \"fpuv3_hf\",\n        .description = \"Enable FPUv3 half precision operate instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv3_hi)] = .{\n        .llvm_name = \"fpuv3_hi\",\n        .description = \"Enable FPUv3 half word converting instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpuv3_sf)] = .{\n        .llvm_name = \"fpuv3_sf\",\n        .description = \"Enable FPUv3 single float instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hard_float)] = .{\n        .llvm_name = \"hard-float\",\n        .description = \"Use hard floating point features\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hard_float_abi)] = .{\n        .llvm_name = \"hard-float-abi\",\n        .description = \"Use hard floating point ABI to pass args\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hard_tp)] = .{\n        .llvm_name = \"hard-tp\",\n        .description = \"Enable TLS Pointer register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.high_registers)] = .{\n        .llvm_name = \"high-registers\",\n        .description = \"Enable r16-r31 registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hwdiv)] = .{\n        .llvm_name = \"hwdiv\",\n        .description = \"Enable divide instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.istack)] = .{\n        .llvm_name = \"istack\",\n        .description = \"Enable interrput attribute\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.java)] = .{\n        .llvm_name = \"java\",\n        .description = \"Enable java instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mp)] = .{\n        .llvm_name = \"mp\",\n        .description = \"Support CSKY mp instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"2e3\",\n        }),\n    };\n    result[@intFromEnum(Feature.mp1e2)] = .{\n        .llvm_name = \"mp1e2\",\n        .description = \"Support CSKY mp1e2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"3e7\",\n        }),\n    };\n    result[@intFromEnum(Feature.multiple_stld)] = .{\n        .llvm_name = \"multiple_stld\",\n        .description = \"Enable multiple load/store instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nvic)] = .{\n        .llvm_name = \"nvic\",\n        .description = \"Enable NVIC\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pushpop)] = .{\n        .llvm_name = \"pushpop\",\n        .description = \"Enable push/pop instrutions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.smart)] = .{\n        .llvm_name = \"smart\",\n        .description = \"Let CPU work in Smart Mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_tp)] = .{\n        .llvm_name = \"soft-tp\",\n        .description = \"Disable TLS Pointer register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.stack_size)] = .{\n        .llvm_name = \"stack-size\",\n        .description = \"Output stack size information\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.trust)] = .{\n        .llvm_name = \"trust\",\n        .description = \"Enable trust instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vdsp2e3)] = .{\n        .llvm_name = \"vdsp2e3\",\n        .description = \"Support CSKY vdsp2e3 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vdsp2e60f)] = .{\n        .llvm_name = \"vdsp2e60f\",\n        .description = \"Support CSKY vdsp2e60f instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vdspv1)] = .{\n        .llvm_name = \"vdspv1\",\n        .description = \"Enable 128bit vdsp-v1 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vdspv2)] = .{\n        .llvm_name = \"vdspv2\",\n        .description = \"Enable vdsp-v2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.audio)] = .{\n        .llvm_name = \"audio\",\n        .description = \"Hexagon Audio extension instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cabac)] = .{\n        .llvm_name = \"cabac\",\n        .description = \"Emit the CABAC instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.compound)] = .{\n        .llvm_name = \"compound\",\n        .description = \"Use compound instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.duplex)] = .{\n        .llvm_name = \"duplex\",\n        .description = \"Enable generation of duplex instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hvx)] = .{\n        .llvm_name = \"hvx\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hvx_ieee_fp)] = .{\n        .llvm_name = \"hvx-ieee-fp\",\n        .description = \"Hexagon HVX IEEE floating point instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hvx_length128b)] = .{\n        .llvm_name = \"hvx-length128b\",\n        .description = \"Hexagon HVX 128B instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvx,\n        }),\n    };\n    result[@intFromEnum(Feature.hvx_length64b)] = .{\n        .llvm_name = \"hvx-length64b\",\n        .description = \"Hexagon HVX 64B instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvx,\n        }),\n    };\n    result[@intFromEnum(Feature.hvx_qfloat)] = .{\n        .llvm_name = \"hvx-qfloat\",\n        .description = \"Hexagon HVX QFloating point instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hvxv60)] = .{\n        .llvm_name = \"hvxv60\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvx,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv62)] = .{\n        .llvm_name = \"hvxv62\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv60,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv65)] = .{\n        .llvm_name = \"hvxv65\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv62,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv66)] = .{\n        .llvm_name = \"hvxv66\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv65,\n            .zreg,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv67)] = .{\n        .llvm_name = \"hvxv67\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv66,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv68)] = .{\n        .llvm_name = \"hvxv68\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv67,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv69)] = .{\n        .llvm_name = \"hvxv69\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv68,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv71)] = .{\n        .llvm_name = \"hvxv71\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv69,\n        }),\n    };\n    result[@intFromEnum(Feature.hvxv73)] = .{\n        .llvm_name = \"hvxv73\",\n        .description = \"Hexagon HVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hvxv71,\n        }),\n    };\n    result[@intFromEnum(Feature.long_calls)] = .{\n        .llvm_name = \"long-calls\",\n        .description = \"Use constant-extended calls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mem_noshuf)] = .{\n        .llvm_name = \"mem_noshuf\",\n        .description = \"Supports mem_noshuf feature\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.memops)] = .{\n        .llvm_name = \"memops\",\n        .description = \"Use memop instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.noreturn_stack_elim)] = .{\n        .llvm_name = \"noreturn-stack-elim\",\n        .description = \"Eliminate stack allocation in a noreturn function when possible\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nvj)] = .{\n        .llvm_name = \"nvj\",\n        .description = \"Support for new-value jumps\",\n        .dependencies = featureSet(&[_]Feature{\n            .packets,\n        }),\n    };\n    result[@intFromEnum(Feature.nvs)] = .{\n        .llvm_name = \"nvs\",\n        .description = \"Support for new-value stores\",\n        .dependencies = featureSet(&[_]Feature{\n            .packets,\n        }),\n    };\n    result[@intFromEnum(Feature.packets)] = .{\n        .llvm_name = \"packets\",\n        .description = \"Support for instruction packets\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prev65)] = .{\n        .llvm_name = \"prev65\",\n        .description = \"Support features deprecated in v65\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserved_r19)] = .{\n        .llvm_name = \"reserved-r19\",\n        .description = \"Reserve register R19\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.small_data)] = .{\n        .llvm_name = \"small-data\",\n        .description = \"Allow GP-relative addressing of global variables\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tinycore)] = .{\n        .llvm_name = \"tinycore\",\n        .description = \"Hexagon Tiny Core\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unsafe_fp)] = .{\n        .llvm_name = \"unsafe-fp\",\n        .description = \"Use unsafe FP math\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v5)] = .{\n        .llvm_name = \"v5\",\n        .description = \"Enable Hexagon V5 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v55)] = .{\n        .llvm_name = \"v55\",\n        .description = \"Enable Hexagon V55 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v60)] = .{\n        .llvm_name = \"v60\",\n        .description = \"Enable Hexagon V60 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v62)] = .{\n        .llvm_name = \"v62\",\n        .description = \"Enable Hexagon V62 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v65)] = .{\n        .llvm_name = \"v65\",\n        .description = \"Enable Hexagon V65 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v66)] = .{\n        .llvm_name = \"v66\",\n        .description = \"Enable Hexagon V66 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v67)] = .{\n        .llvm_name = \"v67\",\n        .description = \"Enable Hexagon V67 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v68)] = .{\n        .llvm_name = \"v68\",\n        .description = \"Enable Hexagon V68 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v69)] = .{\n        .llvm_name = \"v69\",\n        .description = \"Enable Hexagon V69 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v71)] = .{\n        .llvm_name = \"v71\",\n        .description = \"Enable Hexagon V71 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v73)] = .{\n        .llvm_name = \"v73\",\n        .description = \"Enable Hexagon V73 architecture\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zreg)] = .{\n        .llvm_name = \"zreg\",\n        .description = \"Hexagon ZReg extension instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"32bit\")] = .{\n        .llvm_name = \"32bit\",\n        .description = \"LA32 Basic Integer and Privilege Instruction Set\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"64bit\")] = .{\n        .llvm_name = \"64bit\",\n        .description = \"LA64 Basic Integer and Privilege Instruction Set\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.d)] = .{\n        .llvm_name = \"d\",\n        .description = \"'D' (Double-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.f)] = .{\n        .llvm_name = \"f\",\n        .description = \"'F' (Single-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.la_global_with_abs)] = .{\n        .llvm_name = \"la-global-with-abs\",\n        .description = \"Expand la.global as la.abs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.la_global_with_pcrel)] = .{\n        .llvm_name = \"la-global-with-pcrel\",\n        .description = \"Expand la.global as la.pcrel\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.la_local_with_abs)] = .{\n        .llvm_name = \"la-local-with-abs\",\n        .description = \"Expand la.local as la.abs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lasx)] = .{\n        .llvm_name = \"lasx\",\n        .description = \"'LASX' (Loongson Advanced SIMD Extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .lsx,\n        }),\n    };\n    result[@intFromEnum(Feature.lbt)] = .{\n        .llvm_name = \"lbt\",\n        .description = \"'LBT' (Loongson Binary Translation Extension)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lsx)] = .{\n        .llvm_name = \"lsx\",\n        .description = \"'LSX' (Loongson SIMD Extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .d,\n        }),\n    };\n    result[@intFromEnum(Feature.lvz)] = .{\n        .llvm_name = \"lvz\",\n        .description = \"'LVZ' (Loongson Virtualization Extension)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ual)] = .{\n        .llvm_name = \"ual\",\n        .description = \"Allow memory accesses to be unaligned\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.isa_68000)] = .{\n        .llvm_name = \"isa-68000\",\n        .description = \"Is M68000 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.isa_68010)] = .{\n        .llvm_name = \"isa-68010\",\n        .description = \"Is M68010 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68000,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_68020)] = .{\n        .llvm_name = \"isa-68020\",\n        .description = \"Is M68020 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68010,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_68030)] = .{\n        .llvm_name = \"isa-68030\",\n        .description = \"Is M68030 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68020,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_68040)] = .{\n        .llvm_name = \"isa-68040\",\n        .description = \"Is M68040 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68030,\n            .isa_68882,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_68060)] = .{\n        .llvm_name = \"isa-68060\",\n        .description = \"Is M68060 ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68040,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_68881)] = .{\n        .llvm_name = \"isa-68881\",\n        .description = \"Is M68881 (FPU) ISA supported\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.isa_68882)] = .{\n        .llvm_name = \"isa-68882\",\n        .description = \"Is M68882 (FPU) ISA supported\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_68881,\n        }),\n    };\n    result[@intFromEnum(Feature.reserve_a0)] = .{\n        .llvm_name = \"reserve-a0\",\n        .description = \"Reserve A0 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a1)] = .{\n        .llvm_name = \"reserve-a1\",\n        .description = \"Reserve A1 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a2)] = .{\n        .llvm_name = \"reserve-a2\",\n        .description = \"Reserve A2 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a3)] = .{\n        .llvm_name = \"reserve-a3\",\n        .description = \"Reserve A3 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a4)] = .{\n        .llvm_name = \"reserve-a4\",\n        .description = \"Reserve A4 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a5)] = .{\n        .llvm_name = \"reserve-a5\",\n        .description = \"Reserve A5 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_a6)] = .{\n        .llvm_name = \"reserve-a6\",\n        .description = \"Reserve A6 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d0)] = .{\n        .llvm_name = \"reserve-d0\",\n        .description = \"Reserve D0 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d1)] = .{\n        .llvm_name = \"reserve-d1\",\n        .description = \"Reserve D1 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d2)] = .{\n        .llvm_name = \"reserve-d2\",\n        .description = \"Reserve D2 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d3)] = .{\n        .llvm_name = \"reserve-d3\",\n        .description = \"Reserve D3 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d4)] = .{\n        .llvm_name = \"reserve-d4\",\n        .description = \"Reserve D4 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d5)] = .{\n        .llvm_name = \"reserve-d5\",\n        .description = \"Reserve D5 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d6)] = .{\n        .llvm_name = \"reserve-d6\",\n        .description = \"Reserve D6 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_d7)] = .{\n        .llvm_name = \"reserve-d7\",\n        .description = \"Reserve D7 register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.abs2008)] = .{\n        .llvm_name = \"abs2008\",\n        .description = \"Disable IEEE 754-2008 abs.fmt mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cnmips)] = .{\n        .llvm_name = \"cnmips\",\n        .description = \"Octeon cnMIPS Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips64r2,\n        }),\n    };\n    result[@intFromEnum(Feature.cnmipsp)] = .{\n        .llvm_name = \"cnmipsp\",\n        .description = \"Octeon+ cnMIPS Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .cnmips,\n        }),\n    };\n    result[@intFromEnum(Feature.crc)] = .{\n        .llvm_name = \"crc\",\n        .description = \"Mips R6 CRC ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dsp)] = .{\n        .llvm_name = \"dsp\",\n        .description = \"Mips DSP ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dspr2)] = .{\n        .llvm_name = \"dspr2\",\n        .description = \"Mips DSP-R2 ASE\",\n        .dependencies = featureSet(&[_]Feature{\n            .dsp,\n        }),\n    };\n    result[@intFromEnum(Feature.dspr3)] = .{\n        .llvm_name = \"dspr3\",\n        .description = \"Mips DSP-R3 ASE\",\n        .dependencies = featureSet(&[_]Feature{\n            .dspr2,\n        }),\n    };\n    result[@intFromEnum(Feature.eva)] = .{\n        .llvm_name = \"eva\",\n        .description = \"Mips EVA ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp64)] = .{\n        .llvm_name = \"fp64\",\n        .description = \"Support 64-bit FP registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fpxx)] = .{\n        .llvm_name = \"fpxx\",\n        .description = \"Support for FPXX\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ginv)] = .{\n        .llvm_name = \"ginv\",\n        .description = \"Mips Global Invalidate ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gp64)] = .{\n        .llvm_name = \"gp64\",\n        .description = \"General Purpose Registers are 64-bit wide\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.long_calls)] = .{\n        .llvm_name = \"long-calls\",\n        .description = \"Disable use of the jal instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.micromips)] = .{\n        .llvm_name = \"micromips\",\n        .description = \"microMips mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips1)] = .{\n        .llvm_name = \"mips1\",\n        .description = \"Mips I ISA Support [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips16)] = .{\n        .llvm_name = \"mips16\",\n        .description = \"Mips16 mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips2)] = .{\n        .llvm_name = \"mips2\",\n        .description = \"Mips II ISA Support [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips1,\n        }),\n    };\n    result[@intFromEnum(Feature.mips3)] = .{\n        .llvm_name = \"mips3\",\n        .description = \"MIPS III ISA Support [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{\n            .fp64,\n            .gp64,\n            .mips2,\n            .mips3_32,\n            .mips3_32r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips32)] = .{\n        .llvm_name = \"mips32\",\n        .description = \"Mips32 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips2,\n            .mips3_32,\n            .mips4_32,\n        }),\n    };\n    result[@intFromEnum(Feature.mips32r2)] = .{\n        .llvm_name = \"mips32r2\",\n        .description = \"Mips32r2 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32,\n            .mips3_32r2,\n            .mips4_32r2,\n            .mips5_32r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips32r3)] = .{\n        .llvm_name = \"mips32r3\",\n        .description = \"Mips32r3 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips32r5)] = .{\n        .llvm_name = \"mips32r5\",\n        .description = \"Mips32r5 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r3,\n        }),\n    };\n    result[@intFromEnum(Feature.mips32r6)] = .{\n        .llvm_name = \"mips32r6\",\n        .description = \"Mips32r6 ISA Support [experimental]\",\n        .dependencies = featureSet(&[_]Feature{\n            .abs2008,\n            .fp64,\n            .mips32r5,\n            .nan2008,\n        }),\n    };\n    result[@intFromEnum(Feature.mips3_32)] = .{\n        .llvm_name = \"mips3_32\",\n        .description = \"Subset of MIPS-III that is also in MIPS32 [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips3_32r2)] = .{\n        .llvm_name = \"mips3_32r2\",\n        .description = \"Subset of MIPS-III that is also in MIPS32r2 [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips3d)] = .{\n        .llvm_name = \"mips3d\",\n        .description = \"Mips 3D ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips4)] = .{\n        .llvm_name = \"mips4\",\n        .description = \"MIPS IV ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips3,\n            .mips4_32,\n            .mips4_32r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips4_32)] = .{\n        .llvm_name = \"mips4_32\",\n        .description = \"Subset of MIPS-IV that is also in MIPS32 [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips4_32r2)] = .{\n        .llvm_name = \"mips4_32r2\",\n        .description = \"Subset of MIPS-IV that is also in MIPS32r2 [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips5)] = .{\n        .llvm_name = \"mips5\",\n        .description = \"MIPS V ISA Support [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips4,\n            .mips5_32r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips5_32r2)] = .{\n        .llvm_name = \"mips5_32r2\",\n        .description = \"Subset of MIPS-V that is also in MIPS32r2 [highly experimental]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mips64)] = .{\n        .llvm_name = \"mips64\",\n        .description = \"Mips64 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32,\n            .mips5,\n        }),\n    };\n    result[@intFromEnum(Feature.mips64r2)] = .{\n        .llvm_name = \"mips64r2\",\n        .description = \"Mips64r2 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r2,\n            .mips64,\n        }),\n    };\n    result[@intFromEnum(Feature.mips64r3)] = .{\n        .llvm_name = \"mips64r3\",\n        .description = \"Mips64r3 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r3,\n            .mips64r2,\n        }),\n    };\n    result[@intFromEnum(Feature.mips64r5)] = .{\n        .llvm_name = \"mips64r5\",\n        .description = \"Mips64r5 ISA Support\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r5,\n            .mips64r3,\n        }),\n    };\n    result[@intFromEnum(Feature.mips64r6)] = .{\n        .llvm_name = \"mips64r6\",\n        .description = \"Mips64r6 ISA Support [experimental]\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r6,\n            .mips64r5,\n        }),\n    };\n    result[@intFromEnum(Feature.msa)] = .{\n        .llvm_name = \"msa\",\n        .description = \"Mips MSA ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mt)] = .{\n        .llvm_name = \"mt\",\n        .description = \"Mips MT ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nan2008)] = .{\n        .llvm_name = \"nan2008\",\n        .description = \"IEEE 754-2008 NaN encoding\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.noabicalls)] = .{\n        .llvm_name = \"noabicalls\",\n        .description = \"Disable SVR4-style position-independent code\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nomadd4)] = .{\n        .llvm_name = \"nomadd4\",\n        .description = \"Disable 4-operand madd.fmt and related instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nooddspreg)] = .{\n        .llvm_name = \"nooddspreg\",\n        .description = \"Disable odd numbered single-precision registers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.p5600)] = .{\n        .llvm_name = \"p5600\",\n        .description = \"The P5600 Processor\",\n        .dependencies = featureSet(&[_]Feature{\n            .mips32r5,\n        }),\n    };\n    result[@intFromEnum(Feature.ptr64)] = .{\n        .llvm_name = \"ptr64\",\n        .description = \"Pointers are 64-bit wide\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.single_float)] = .{\n        .llvm_name = \"single-float\",\n        .description = \"Only supports single precision float\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_float)] = .{\n        .llvm_name = \"soft-float\",\n        .description = \"Does not support floating point instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sym32)] = .{\n        .llvm_name = \"sym32\",\n        .description = \"Symbols are 32 bit on Mips64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_indirect_jump_hazard)] = .{\n        .llvm_name = \"use-indirect-jump-hazard\",\n        .description = \"Use indirect jump guards to prevent certain speculation based attacks\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_tcc_in_div)] = .{\n        .llvm_name = \"use-tcc-in-div\",\n        .description = \"Force the assembler to use trapping\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vfpu)] = .{\n        .llvm_name = \"vfpu\",\n        .description = \"Enable vector FPU instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.virt)] = .{\n        .llvm_name = \"virt\",\n        .description = \"Mips Virtualization ASE\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xgot)] = .{\n        .llvm_name = \"xgot\",\n        .description = \"Assume 32-bit GOT\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.ext)] = .{\n        .llvm_name = \"ext\",\n        .description = \"Enable MSP430-X extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hwmult16)] = .{\n        .llvm_name = \"hwmult16\",\n        .description = \"Enable 16-bit hardware multiplier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hwmult32)] = .{\n        .llvm_name = \"hwmult32\",\n        .description = \"Enable 32-bit hardware multiplier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hwmultf5)] = .{\n        .llvm_name = \"hwmultf5\",\n        .description = \"Enable F5 series hardware multiplier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.ptx32)] = .{\n        .llvm_name = \"ptx32\",\n        .description = \"Use PTX version 32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx40)] = .{\n        .llvm_name = \"ptx40\",\n        .description = \"Use PTX version 40\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx41)] = .{\n        .llvm_name = \"ptx41\",\n        .description = \"Use PTX version 41\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx42)] = .{\n        .llvm_name = \"ptx42\",\n        .description = \"Use PTX version 42\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx43)] = .{\n        .llvm_name = \"ptx43\",\n        .description = \"Use PTX version 43\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx50)] = .{\n        .llvm_name = \"ptx50\",\n        .description = \"Use PTX version 50\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx60)] = .{\n        .llvm_name = \"ptx60\",\n        .description = \"Use PTX version 60\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx61)] = .{\n        .llvm_name = \"ptx61\",\n        .description = \"Use PTX version 61\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx63)] = .{\n        .llvm_name = \"ptx63\",\n        .description = \"Use PTX version 63\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx64)] = .{\n        .llvm_name = \"ptx64\",\n        .description = \"Use PTX version 64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx65)] = .{\n        .llvm_name = \"ptx65\",\n        .description = \"Use PTX version 65\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx70)] = .{\n        .llvm_name = \"ptx70\",\n        .description = \"Use PTX version 70\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx71)] = .{\n        .llvm_name = \"ptx71\",\n        .description = \"Use PTX version 71\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx72)] = .{\n        .llvm_name = \"ptx72\",\n        .description = \"Use PTX version 72\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx73)] = .{\n        .llvm_name = \"ptx73\",\n        .description = \"Use PTX version 73\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx74)] = .{\n        .llvm_name = \"ptx74\",\n        .description = \"Use PTX version 74\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx75)] = .{\n        .llvm_name = \"ptx75\",\n        .description = \"Use PTX version 75\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx76)] = .{\n        .llvm_name = \"ptx76\",\n        .description = \"Use PTX version 76\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx77)] = .{\n        .llvm_name = \"ptx77\",\n        .description = \"Use PTX version 77\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx78)] = .{\n        .llvm_name = \"ptx78\",\n        .description = \"Use PTX version 78\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx80)] = .{\n        .llvm_name = \"ptx80\",\n        .description = \"Use PTX version 80\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptx81)] = .{\n        .llvm_name = \"ptx81\",\n        .description = \"Use PTX version 81\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_20)] = .{\n        .llvm_name = \"sm_20\",\n        .description = \"Target SM 20\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_21)] = .{\n        .llvm_name = \"sm_21\",\n        .description = \"Target SM 21\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_30)] = .{\n        .llvm_name = \"sm_30\",\n        .description = \"Target SM 30\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_32)] = .{\n        .llvm_name = \"sm_32\",\n        .description = \"Target SM 32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_35)] = .{\n        .llvm_name = \"sm_35\",\n        .description = \"Target SM 35\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_37)] = .{\n        .llvm_name = \"sm_37\",\n        .description = \"Target SM 37\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_50)] = .{\n        .llvm_name = \"sm_50\",\n        .description = \"Target SM 50\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_52)] = .{\n        .llvm_name = \"sm_52\",\n        .description = \"Target SM 52\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_53)] = .{\n        .llvm_name = \"sm_53\",\n        .description = \"Target SM 53\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_60)] = .{\n        .llvm_name = \"sm_60\",\n        .description = \"Target SM 60\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_61)] = .{\n        .llvm_name = \"sm_61\",\n        .description = \"Target SM 61\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_62)] = .{\n        .llvm_name = \"sm_62\",\n        .description = \"Target SM 62\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_70)] = .{\n        .llvm_name = \"sm_70\",\n        .description = \"Target SM 70\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_72)] = .{\n        .llvm_name = \"sm_72\",\n        .description = \"Target SM 72\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_75)] = .{\n        .llvm_name = \"sm_75\",\n        .description = \"Target SM 75\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_80)] = .{\n        .llvm_name = \"sm_80\",\n        .description = \"Target SM 80\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_86)] = .{\n        .llvm_name = \"sm_86\",\n        .description = \"Target SM 86\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_87)] = .{\n        .llvm_name = \"sm_87\",\n        .description = \"Target SM 87\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_89)] = .{\n        .llvm_name = \"sm_89\",\n        .description = \"Target SM 89\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm_90)] = .{\n        .llvm_name = \"sm_90\",\n        .description = \"Target SM 90\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"64bit\")] = .{\n        .llvm_name = \"64bit\",\n        .description = \"Enable 64-bit instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"64bitregs\")] = .{\n        .llvm_name = \"64bitregs\",\n        .description = \"Enable 64-bit registers usage for ppc32 [beta]\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aix)] = .{\n        .llvm_name = \"aix\",\n        .description = \"AIX OS\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.allow_unaligned_fp_access)] = .{\n        .llvm_name = \"allow-unaligned-fp-access\",\n        .description = \"CPU does not trap on unaligned FP access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.altivec)] = .{\n        .llvm_name = \"altivec\",\n        .description = \"Enable Altivec instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.booke)] = .{\n        .llvm_name = \"booke\",\n        .description = \"Enable Book E instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .icbt,\n        }),\n    };\n    result[@intFromEnum(Feature.bpermd)] = .{\n        .llvm_name = \"bpermd\",\n        .description = \"Enable the bpermd instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cmpb)] = .{\n        .llvm_name = \"cmpb\",\n        .description = \"Enable the cmpb instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crbits)] = .{\n        .llvm_name = \"crbits\",\n        .description = \"Use condition-register bits individually\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crypto)] = .{\n        .llvm_name = \"crypto\",\n        .description = \"Enable POWER8 Crypto instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .power8_altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.direct_move)] = .{\n        .llvm_name = \"direct-move\",\n        .description = \"Enable Power8 direct move instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .vsx,\n        }),\n    };\n    result[@intFromEnum(Feature.e500)] = .{\n        .llvm_name = \"e500\",\n        .description = \"Enable E500/E500mc instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.efpu2)] = .{\n        .llvm_name = \"efpu2\",\n        .description = \"Enable Embedded Floating-Point APU 2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .spe,\n        }),\n    };\n    result[@intFromEnum(Feature.extdiv)] = .{\n        .llvm_name = \"extdiv\",\n        .description = \"Enable extended divide instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_MFLR)] = .{\n        .llvm_name = \"fast-MFLR\",\n        .description = \"MFLR is a fast instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fcpsgn)] = .{\n        .llvm_name = \"fcpsgn\",\n        .description = \"Enable the fcpsgn instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.float128)] = .{\n        .llvm_name = \"float128\",\n        .description = \"Enable the __float128 data type for IEEE-754R Binary128.\",\n        .dependencies = featureSet(&[_]Feature{\n            .vsx,\n        }),\n    };\n    result[@intFromEnum(Feature.fpcvt)] = .{\n        .llvm_name = \"fpcvt\",\n        .description = \"Enable fc[ft]* (unsigned and single-precision) and lfiwzx instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.fprnd)] = .{\n        .llvm_name = \"fprnd\",\n        .description = \"Enable the fri[mnpz] instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.fpu)] = .{\n        .llvm_name = \"fpu\",\n        .description = \"Enable classic FPU instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hard_float,\n        }),\n    };\n    result[@intFromEnum(Feature.fre)] = .{\n        .llvm_name = \"fre\",\n        .description = \"Enable the fre instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.fres)] = .{\n        .llvm_name = \"fres\",\n        .description = \"Enable the fres instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.frsqrte)] = .{\n        .llvm_name = \"frsqrte\",\n        .description = \"Enable the frsqrte instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.frsqrtes)] = .{\n        .llvm_name = \"frsqrtes\",\n        .description = \"Enable the frsqrtes instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.fsqrt)] = .{\n        .llvm_name = \"fsqrt\",\n        .description = \"Enable the fsqrt instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_add_logical)] = .{\n        .llvm_name = \"fuse-add-logical\",\n        .description = \"Target supports Add with Logical Operations fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_addi_load)] = .{\n        .llvm_name = \"fuse-addi-load\",\n        .description = \"Power8 Addi-Load fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_addis_load)] = .{\n        .llvm_name = \"fuse-addis-load\",\n        .description = \"Power8 Addis-Load fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_arith_add)] = .{\n        .llvm_name = \"fuse-arith-add\",\n        .description = \"Target supports Arithmetic Operations with Add fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_back2back)] = .{\n        .llvm_name = \"fuse-back2back\",\n        .description = \"Target supports general back to back fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_cmp)] = .{\n        .llvm_name = \"fuse-cmp\",\n        .description = \"Target supports Comparison Operations fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_logical)] = .{\n        .llvm_name = \"fuse-logical\",\n        .description = \"Target supports Logical Operations fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_logical_add)] = .{\n        .llvm_name = \"fuse-logical-add\",\n        .description = \"Target supports Logical with Add Operations fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_sha3)] = .{\n        .llvm_name = \"fuse-sha3\",\n        .description = \"Target supports SHA3 assist fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_store)] = .{\n        .llvm_name = \"fuse-store\",\n        .description = \"Target supports store clustering\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_wideimm)] = .{\n        .llvm_name = \"fuse-wideimm\",\n        .description = \"Target supports Wide-Immediate fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fuse_zeromove)] = .{\n        .llvm_name = \"fuse-zeromove\",\n        .description = \"Target supports move to SPR with branch fusion\",\n        .dependencies = featureSet(&[_]Feature{\n            .fusion,\n        }),\n    };\n    result[@intFromEnum(Feature.fusion)] = .{\n        .llvm_name = \"fusion\",\n        .description = \"Target supports instruction fusion\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hard_float)] = .{\n        .llvm_name = \"hard-float\",\n        .description = \"Enable floating-point instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.htm)] = .{\n        .llvm_name = \"htm\",\n        .description = \"Enable Hardware Transactional Memory instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.icbt)] = .{\n        .llvm_name = \"icbt\",\n        .description = \"Enable icbt instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.invariant_function_descriptors)] = .{\n        .llvm_name = \"invariant-function-descriptors\",\n        .description = \"Assume function descriptors are invariant\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.isa_future_instructions)] = .{\n        .llvm_name = \"isa-future-instructions\",\n        .description = \"Enable instructions for Future ISA.\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v31_instructions,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_v206_instructions)] = .{\n        .llvm_name = \"isa-v206-instructions\",\n        .description = \"Enable instructions in ISA 2.06.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.isa_v207_instructions)] = .{\n        .llvm_name = \"isa-v207-instructions\",\n        .description = \"Enable instructions in ISA 2.07.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.isa_v30_instructions)] = .{\n        .llvm_name = \"isa-v30-instructions\",\n        .description = \"Enable instructions in ISA 3.0.\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v207_instructions,\n        }),\n    };\n    result[@intFromEnum(Feature.isa_v31_instructions)] = .{\n        .llvm_name = \"isa-v31-instructions\",\n        .description = \"Enable instructions in ISA 3.1.\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v30_instructions,\n        }),\n    };\n    result[@intFromEnum(Feature.isel)] = .{\n        .llvm_name = \"isel\",\n        .description = \"Enable the isel instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ldbrx)] = .{\n        .llvm_name = \"ldbrx\",\n        .description = \"Enable the ldbrx instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lfiwax)] = .{\n        .llvm_name = \"lfiwax\",\n        .description = \"Enable the lfiwax instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.longcall)] = .{\n        .llvm_name = \"longcall\",\n        .description = \"Always use indirect calls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mfocrf)] = .{\n        .llvm_name = \"mfocrf\",\n        .description = \"Enable the MFOCRF instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mma)] = .{\n        .llvm_name = \"mma\",\n        .description = \"Enable MMA instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .paired_vector_memops,\n            .power8_vector,\n            .power9_altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.modern_aix_as)] = .{\n        .llvm_name = \"modern-aix-as\",\n        .description = \"AIX system assembler is modern enough to support new mnes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.msync)] = .{\n        .llvm_name = \"msync\",\n        .description = \"Has only the msync instruction instead of sync\",\n        .dependencies = featureSet(&[_]Feature{\n            .booke,\n        }),\n    };\n    result[@intFromEnum(Feature.paired_vector_memops)] = .{\n        .llvm_name = \"paired-vector-memops\",\n        .description = \"32Byte load and store instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v30_instructions,\n        }),\n    };\n    result[@intFromEnum(Feature.partword_atomics)] = .{\n        .llvm_name = \"partword-atomics\",\n        .description = \"Enable l[bh]arx and st[bh]cx.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pcrelative_memops)] = .{\n        .llvm_name = \"pcrelative-memops\",\n        .description = \"Enable PC relative Memory Ops\",\n        .dependencies = featureSet(&[_]Feature{\n            .prefix_instrs,\n        }),\n    };\n    result[@intFromEnum(Feature.popcntd)] = .{\n        .llvm_name = \"popcntd\",\n        .description = \"Enable the popcnt[dw] instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.power10_vector)] = .{\n        .llvm_name = \"power10-vector\",\n        .description = \"Enable POWER10 vector instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v31_instructions,\n            .power9_vector,\n        }),\n    };\n    result[@intFromEnum(Feature.power8_altivec)] = .{\n        .llvm_name = \"power8-altivec\",\n        .description = \"Enable POWER8 Altivec instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.power8_vector)] = .{\n        .llvm_name = \"power8-vector\",\n        .description = \"Enable POWER8 vector instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .power8_altivec,\n            .vsx,\n        }),\n    };\n    result[@intFromEnum(Feature.power9_altivec)] = .{\n        .llvm_name = \"power9-altivec\",\n        .description = \"Enable POWER9 Altivec instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .isa_v30_instructions,\n            .power8_altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.power9_vector)] = .{\n        .llvm_name = \"power9-vector\",\n        .description = \"Enable POWER9 vector instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .power8_vector,\n            .power9_altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.ppc4xx)] = .{\n        .llvm_name = \"ppc4xx\",\n        .description = \"Enable PPC 4xx instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ppc6xx)] = .{\n        .llvm_name = \"ppc6xx\",\n        .description = \"Enable PPC 6xx instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ppc_postra_sched)] = .{\n        .llvm_name = \"ppc-postra-sched\",\n        .description = \"Use PowerPC post-RA scheduling strategy\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ppc_prera_sched)] = .{\n        .llvm_name = \"ppc-prera-sched\",\n        .description = \"Use PowerPC pre-RA scheduling strategy\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.predictable_select_expensive)] = .{\n        .llvm_name = \"predictable-select-expensive\",\n        .description = \"Prefer likely predicted branches over selects\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefix_instrs)] = .{\n        .llvm_name = \"prefix-instrs\",\n        .description = \"Enable prefixed instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .power8_vector,\n            .power9_altivec,\n        }),\n    };\n    result[@intFromEnum(Feature.privileged)] = .{\n        .llvm_name = \"privileged\",\n        .description = \"Add privileged instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.quadword_atomics)] = .{\n        .llvm_name = \"quadword-atomics\",\n        .description = \"Enable lqarx and stqcx.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.recipprec)] = .{\n        .llvm_name = \"recipprec\",\n        .description = \"Assume higher precision reciprocal estimates\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rop_protect)] = .{\n        .llvm_name = \"rop-protect\",\n        .description = \"Add ROP protect\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.secure_plt)] = .{\n        .llvm_name = \"secure-plt\",\n        .description = \"Enable secure plt mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_popcntd)] = .{\n        .llvm_name = \"slow-popcntd\",\n        .description = \"Has slow popcnt[dw] instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.spe)] = .{\n        .llvm_name = \"spe\",\n        .description = \"Enable SPE instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .hard_float,\n        }),\n    };\n    result[@intFromEnum(Feature.stfiwx)] = .{\n        .llvm_name = \"stfiwx\",\n        .description = \"Enable the stfiwx instruction\",\n        .dependencies = featureSet(&[_]Feature{\n            .fpu,\n        }),\n    };\n    result[@intFromEnum(Feature.two_const_nr)] = .{\n        .llvm_name = \"two-const-nr\",\n        .description = \"Requires two constant Newton-Raphson computation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vectors_use_two_units)] = .{\n        .llvm_name = \"vectors-use-two-units\",\n        .description = \"Vectors use two units\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vsx)] = .{\n        .llvm_name = \"vsx\",\n        .description = \"Enable VSX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .altivec,\n        }),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"32bit\")] = .{\n        .llvm_name = \"32bit\",\n        .description = \"Implements RV32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"64bit\")] = .{\n        .llvm_name = \"64bit\",\n        .description = \"Implements RV64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.a)] = .{\n        .llvm_name = \"a\",\n        .description = \"'A' (Atomic Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.c)] = .{\n        .llvm_name = \"c\",\n        .description = \"'C' (Compressed Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.d)] = .{\n        .llvm_name = \"d\",\n        .description = \"'D' (Double-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.dlen_factor_2)] = .{\n        .llvm_name = \"dlen-factor-2\",\n        .description = \"Vector unit DLEN(data path width) is half of VLEN\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.e)] = .{\n        .llvm_name = \"e\",\n        .description = \"Implements RV{32,64}E (provides 16 rather than 32 GPRs)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_smaia)] = .{\n        .llvm_name = \"experimental-smaia\",\n        .description = \"'Smaia' (Smaia encompasses all added CSRs and all modifications to interrupt response behavior that the AIA specifies for a hart, over all privilege levels.)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_ssaia)] = .{\n        .llvm_name = \"experimental-ssaia\",\n        .description = \"'Ssaia' (Ssaia is essentially the same as Smaia except excluding the machine-level CSRs and behavior not directly visible to supervisor level.)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zacas)] = .{\n        .llvm_name = \"experimental-zacas\",\n        .description = \"'Zacas' (Atomic Compare-And-Swap Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zfa)] = .{\n        .llvm_name = \"experimental-zfa\",\n        .description = \"'Zfa' (Additional Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.experimental_zfbfmin)] = .{\n        .llvm_name = \"experimental-zfbfmin\",\n        .description = \"'Zfbfmin' (Scalar BF16 Converts)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.experimental_zicond)] = .{\n        .llvm_name = \"experimental-zicond\",\n        .description = \"'Zicond' (Integer Conditional Operations)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zihintntl)] = .{\n        .llvm_name = \"experimental-zihintntl\",\n        .description = \"'Zihintntl' (Non-Temporal Locality Hints)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_ztso)] = .{\n        .llvm_name = \"experimental-ztso\",\n        .description = \"'Ztso' (Memory Model - Total Store Order)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvbb)] = .{\n        .llvm_name = \"experimental-zvbb\",\n        .description = \"'Zvbb' (Vector Bit-manipulation used in Cryptography)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvbc)] = .{\n        .llvm_name = \"experimental-zvbc\",\n        .description = \"'Zvbc' (Vector Carryless Multiplication)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvfbfmin)] = .{\n        .llvm_name = \"experimental-zvfbfmin\",\n        .description = \"'Zvbfmin' (Vector BF16 Converts)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve32f,\n        }),\n    };\n    result[@intFromEnum(Feature.experimental_zvfbfwma)] = .{\n        .llvm_name = \"experimental-zvfbfwma\",\n        .description = \"'Zvfbfwma' (Vector BF16 widening mul-add)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve32f,\n        }),\n    };\n    result[@intFromEnum(Feature.experimental_zvkg)] = .{\n        .llvm_name = \"experimental-zvkg\",\n        .description = \"'Zvkg' (Vector GCM instructions for Cryptography)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvkn)] = .{\n        .llvm_name = \"experimental-zvkn\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvkned, Zvknhb, Zvbb, Zvbc, and Zvkt.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvknc)] = .{\n        .llvm_name = \"experimental-zvknc\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvkn and Zvbc.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvkned)] = .{\n        .llvm_name = \"experimental-zvkned\",\n        .description = \"'Zvkned' (Vector AES Encryption & Decryption (Single Round))\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvkng)] = .{\n        .llvm_name = \"experimental-zvkng\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvkn and Zvkg.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvknha)] = .{\n        .llvm_name = \"experimental-zvknha\",\n        .description = \"'Zvknha' (Vector SHA-2 (SHA-256 only))\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvknhb)] = .{\n        .llvm_name = \"experimental-zvknhb\",\n        .description = \"'Zvknhb' (Vector SHA-2 (SHA-256 and SHA-512))\",\n        .dependencies = featureSet(&[_]Feature{\n            .experimental_zvknha,\n        }),\n    };\n    result[@intFromEnum(Feature.experimental_zvks)] = .{\n        .llvm_name = \"experimental-zvks\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvksed, Zvksh, Zvbb, Zvbc, and Zvkt.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvksc)] = .{\n        .llvm_name = \"experimental-zvksc\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvks and Zvbc.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvksed)] = .{\n        .llvm_name = \"experimental-zvksed\",\n        .description = \"'Zvksed' (SM4 Block Cipher Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvksg)] = .{\n        .llvm_name = \"experimental-zvksg\",\n        .description = \"This extension is shorthand for the following set of other extensions: Zvks and Zvkg.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvksh)] = .{\n        .llvm_name = \"experimental-zvksh\",\n        .description = \"'Zvksh' (SM3 Hash Function Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.experimental_zvkt)] = .{\n        .llvm_name = \"experimental-zvkt\",\n        .description = \"'Zvkt' (Vector Data-Independent Execution Latency)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.f)] = .{\n        .llvm_name = \"f\",\n        .description = \"'F' (Single-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zicsr,\n        }),\n    };\n    result[@intFromEnum(Feature.forced_atomics)] = .{\n        .llvm_name = \"forced-atomics\",\n        .description = \"Assume that lock-free native-width atomics are available\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.h)] = .{\n        .llvm_name = \"h\",\n        .description = \"'H' (Hypervisor)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lui_addi_fusion)] = .{\n        .llvm_name = \"lui-addi-fusion\",\n        .description = \"Enable LUI+ADDI macrofusion\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.m)] = .{\n        .llvm_name = \"m\",\n        .description = \"'M' (Integer Multiplication and Division)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_default_unroll)] = .{\n        .llvm_name = \"no-default-unroll\",\n        .description = \"Disable default unroll preference.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_optimized_zero_stride_load)] = .{\n        .llvm_name = \"no-optimized-zero-stride-load\",\n        .description = \"Hasn't optimized (perform fewer memory operations)zero-stride vector load\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_rvc_hints)] = .{\n        .llvm_name = \"no-rvc-hints\",\n        .description = \"Disable RVC Hint Instructions.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.relax)] = .{\n        .llvm_name = \"relax\",\n        .description = \"Enable Linker relaxation.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x1)] = .{\n        .llvm_name = \"reserve-x1\",\n        .description = \"Reserve X1\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x10)] = .{\n        .llvm_name = \"reserve-x10\",\n        .description = \"Reserve X10\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x11)] = .{\n        .llvm_name = \"reserve-x11\",\n        .description = \"Reserve X11\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x12)] = .{\n        .llvm_name = \"reserve-x12\",\n        .description = \"Reserve X12\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x13)] = .{\n        .llvm_name = \"reserve-x13\",\n        .description = \"Reserve X13\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x14)] = .{\n        .llvm_name = \"reserve-x14\",\n        .description = \"Reserve X14\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x15)] = .{\n        .llvm_name = \"reserve-x15\",\n        .description = \"Reserve X15\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x16)] = .{\n        .llvm_name = \"reserve-x16\",\n        .description = \"Reserve X16\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x17)] = .{\n        .llvm_name = \"reserve-x17\",\n        .description = \"Reserve X17\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x18)] = .{\n        .llvm_name = \"reserve-x18\",\n        .description = \"Reserve X18\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x19)] = .{\n        .llvm_name = \"reserve-x19\",\n        .description = \"Reserve X19\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x2)] = .{\n        .llvm_name = \"reserve-x2\",\n        .description = \"Reserve X2\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x20)] = .{\n        .llvm_name = \"reserve-x20\",\n        .description = \"Reserve X20\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x21)] = .{\n        .llvm_name = \"reserve-x21\",\n        .description = \"Reserve X21\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x22)] = .{\n        .llvm_name = \"reserve-x22\",\n        .description = \"Reserve X22\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x23)] = .{\n        .llvm_name = \"reserve-x23\",\n        .description = \"Reserve X23\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x24)] = .{\n        .llvm_name = \"reserve-x24\",\n        .description = \"Reserve X24\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x25)] = .{\n        .llvm_name = \"reserve-x25\",\n        .description = \"Reserve X25\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x26)] = .{\n        .llvm_name = \"reserve-x26\",\n        .description = \"Reserve X26\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x27)] = .{\n        .llvm_name = \"reserve-x27\",\n        .description = \"Reserve X27\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x28)] = .{\n        .llvm_name = \"reserve-x28\",\n        .description = \"Reserve X28\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x29)] = .{\n        .llvm_name = \"reserve-x29\",\n        .description = \"Reserve X29\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x3)] = .{\n        .llvm_name = \"reserve-x3\",\n        .description = \"Reserve X3\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x30)] = .{\n        .llvm_name = \"reserve-x30\",\n        .description = \"Reserve X30\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x31)] = .{\n        .llvm_name = \"reserve-x31\",\n        .description = \"Reserve X31\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x4)] = .{\n        .llvm_name = \"reserve-x4\",\n        .description = \"Reserve X4\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x5)] = .{\n        .llvm_name = \"reserve-x5\",\n        .description = \"Reserve X5\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x6)] = .{\n        .llvm_name = \"reserve-x6\",\n        .description = \"Reserve X6\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x7)] = .{\n        .llvm_name = \"reserve-x7\",\n        .description = \"Reserve X7\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x8)] = .{\n        .llvm_name = \"reserve-x8\",\n        .description = \"Reserve X8\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reserve_x9)] = .{\n        .llvm_name = \"reserve-x9\",\n        .description = \"Reserve X9\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.save_restore)] = .{\n        .llvm_name = \"save-restore\",\n        .description = \"Enable save/restore.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.seq_cst_trailing_fence)] = .{\n        .llvm_name = \"seq-cst-trailing-fence\",\n        .description = \"Enable trailing fence for seq-cst store.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.short_forward_branch_opt)] = .{\n        .llvm_name = \"short-forward-branch-opt\",\n        .description = \"Enable short forward branch optimization\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.svinval)] = .{\n        .llvm_name = \"svinval\",\n        .description = \"'Svinval' (Fine-Grained Address-Translation Cache Invalidation)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.svnapot)] = .{\n        .llvm_name = \"svnapot\",\n        .description = \"'Svnapot' (NAPOT Translation Contiguity)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.svpbmt)] = .{\n        .llvm_name = \"svpbmt\",\n        .description = \"'Svpbmt' (Page-Based Memory Types)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tagged_globals)] = .{\n        .llvm_name = \"tagged-globals\",\n        .description = \"Use an instruction sequence for taking the address of a global that allows a memory tag in the upper address bits\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_scalar_mem)] = .{\n        .llvm_name = \"unaligned-scalar-mem\",\n        .description = \"Has reasonably performant unaligned scalar loads and stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.unaligned_vector_mem)] = .{\n        .llvm_name = \"unaligned-vector-mem\",\n        .description = \"Has reasonably performant unaligned vector loads and stores\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v)] = .{\n        .llvm_name = \"v\",\n        .description = \"'V' (Vector Extension for Application Processors)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve64d,\n            .zvl128b,\n        }),\n    };\n    result[@intFromEnum(Feature.xcvbitmanip)] = .{\n        .llvm_name = \"xcvbitmanip\",\n        .description = \"'XCVbitmanip' (CORE-V Bit Manipulation)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xcvmac)] = .{\n        .llvm_name = \"xcvmac\",\n        .description = \"'XCVmac' (CORE-V Multiply-Accumulate)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xsfcie)] = .{\n        .llvm_name = \"xsfcie\",\n        .description = \"'XSfcie' (SiFive Custom Instruction Extension SCIE.)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xsfvcp)] = .{\n        .llvm_name = \"xsfvcp\",\n        .description = \"'XSfvcp' (SiFive Custom Vector Coprocessor Interface Instructions)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve32x,\n        }),\n    };\n    result[@intFromEnum(Feature.xtheadba)] = .{\n        .llvm_name = \"xtheadba\",\n        .description = \"'xtheadba' (T-Head address calculation instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadbb)] = .{\n        .llvm_name = \"xtheadbb\",\n        .description = \"'xtheadbb' (T-Head basic bit-manipulation instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadbs)] = .{\n        .llvm_name = \"xtheadbs\",\n        .description = \"'xtheadbs' (T-Head single-bit instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadcmo)] = .{\n        .llvm_name = \"xtheadcmo\",\n        .description = \"'xtheadcmo' (T-Head cache management instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadcondmov)] = .{\n        .llvm_name = \"xtheadcondmov\",\n        .description = \"'xtheadcondmov' (T-Head conditional move instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadfmemidx)] = .{\n        .llvm_name = \"xtheadfmemidx\",\n        .description = \"'xtheadfmemidx' (T-Head FP Indexed Memory Operations)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.xtheadmac)] = .{\n        .llvm_name = \"xtheadmac\",\n        .description = \"'xtheadmac' (T-Head Multiply-Accumulate Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadmemidx)] = .{\n        .llvm_name = \"xtheadmemidx\",\n        .description = \"'xtheadmemidx' (T-Head Indexed Memory Operations)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadmempair)] = .{\n        .llvm_name = \"xtheadmempair\",\n        .description = \"'xtheadmempair' (T-Head two-GPR Memory Operations)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadsync)] = .{\n        .llvm_name = \"xtheadsync\",\n        .description = \"'xtheadsync' (T-Head multicore synchronization instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xtheadvdot)] = .{\n        .llvm_name = \"xtheadvdot\",\n        .description = \"'xtheadvdot' (T-Head Vector Extensions for Dot)\",\n        .dependencies = featureSet(&[_]Feature{\n            .v,\n        }),\n    };\n    result[@intFromEnum(Feature.xventanacondops)] = .{\n        .llvm_name = \"xventanacondops\",\n        .description = \"'XVentanaCondOps' (Ventana Conditional Ops)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zawrs)] = .{\n        .llvm_name = \"zawrs\",\n        .description = \"'Zawrs' (Wait on Reservation Set)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zba)] = .{\n        .llvm_name = \"zba\",\n        .description = \"'Zba' (Address Generation Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbb)] = .{\n        .llvm_name = \"zbb\",\n        .description = \"'Zbb' (Basic Bit-Manipulation)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbc)] = .{\n        .llvm_name = \"zbc\",\n        .description = \"'Zbc' (Carry-Less Multiplication)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbkb)] = .{\n        .llvm_name = \"zbkb\",\n        .description = \"'Zbkb' (Bitmanip instructions for Cryptography)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbkc)] = .{\n        .llvm_name = \"zbkc\",\n        .description = \"'Zbkc' (Carry-less multiply instructions for Cryptography)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbkx)] = .{\n        .llvm_name = \"zbkx\",\n        .description = \"'Zbkx' (Crossbar permutation instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zbs)] = .{\n        .llvm_name = \"zbs\",\n        .description = \"'Zbs' (Single-Bit Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zca)] = .{\n        .llvm_name = \"zca\",\n        .description = \"'Zca' (part of the C extension, excluding compressed floating point loads/stores)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zcb)] = .{\n        .llvm_name = \"zcb\",\n        .description = \"'Zcb' (Compressed basic bit manipulation instructions)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zca,\n        }),\n    };\n    result[@intFromEnum(Feature.zcd)] = .{\n        .llvm_name = \"zcd\",\n        .description = \"'Zcd' (Compressed Double-Precision Floating-Point Instructions)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zca,\n        }),\n    };\n    result[@intFromEnum(Feature.zce)] = .{\n        .llvm_name = \"zce\",\n        .description = \"'Zce' (Compressed extensions for microcontrollers)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zcb,\n            .zcmp,\n            .zcmt,\n        }),\n    };\n    result[@intFromEnum(Feature.zcf)] = .{\n        .llvm_name = \"zcf\",\n        .description = \"'Zcf' (Compressed Single-Precision Floating-Point Instructions)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zca,\n        }),\n    };\n    result[@intFromEnum(Feature.zcmp)] = .{\n        .llvm_name = \"zcmp\",\n        .description = \"'Zcmp' (sequenced instuctions for code-size reduction)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zca,\n        }),\n    };\n    result[@intFromEnum(Feature.zcmt)] = .{\n        .llvm_name = \"zcmt\",\n        .description = \"'Zcmt' (table jump instuctions for code-size reduction)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zca,\n            .zicsr,\n        }),\n    };\n    result[@intFromEnum(Feature.zdinx)] = .{\n        .llvm_name = \"zdinx\",\n        .description = \"'Zdinx' (Double in Integer)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zfinx,\n        }),\n    };\n    result[@intFromEnum(Feature.zfh)] = .{\n        .llvm_name = \"zfh\",\n        .description = \"'Zfh' (Half-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.zfhmin)] = .{\n        .llvm_name = \"zfhmin\",\n        .description = \"'Zfhmin' (Half-Precision Floating-Point Minimal)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n        }),\n    };\n    result[@intFromEnum(Feature.zfinx)] = .{\n        .llvm_name = \"zfinx\",\n        .description = \"'Zfinx' (Float in Integer)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zicsr,\n        }),\n    };\n    result[@intFromEnum(Feature.zhinx)] = .{\n        .llvm_name = \"zhinx\",\n        .description = \"'Zhinx' (Half Float in Integer)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zfinx,\n        }),\n    };\n    result[@intFromEnum(Feature.zhinxmin)] = .{\n        .llvm_name = \"zhinxmin\",\n        .description = \"'Zhinxmin' (Half Float in Integer Minimal)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zfinx,\n        }),\n    };\n    result[@intFromEnum(Feature.zicbom)] = .{\n        .llvm_name = \"zicbom\",\n        .description = \"'Zicbom' (Cache-Block Management Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zicbop)] = .{\n        .llvm_name = \"zicbop\",\n        .description = \"'Zicbop' (Cache-Block Prefetch Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zicboz)] = .{\n        .llvm_name = \"zicboz\",\n        .description = \"'Zicboz' (Cache-Block Zero Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zicntr)] = .{\n        .llvm_name = \"zicntr\",\n        .description = \"'Zicntr' (Base Counters and Timers)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zicsr,\n        }),\n    };\n    result[@intFromEnum(Feature.zicsr)] = .{\n        .llvm_name = \"zicsr\",\n        .description = \"'zicsr' (CSRs)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zifencei)] = .{\n        .llvm_name = \"zifencei\",\n        .description = \"'Zifencei' (fence.i)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zihintpause)] = .{\n        .llvm_name = \"zihintpause\",\n        .description = \"'Zihintpause' (Pause Hint)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zihpm)] = .{\n        .llvm_name = \"zihpm\",\n        .description = \"'Zihpm' (Hardware Performance Counters)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zicsr,\n        }),\n    };\n    result[@intFromEnum(Feature.zk)] = .{\n        .llvm_name = \"zk\",\n        .description = \"'Zk' (Standard scalar cryptography extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zkn,\n            .zkr,\n            .zkt,\n        }),\n    };\n    result[@intFromEnum(Feature.zkn)] = .{\n        .llvm_name = \"zkn\",\n        .description = \"'Zkn' (NIST Algorithm Suite)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zbkb,\n            .zbkc,\n            .zbkx,\n            .zknd,\n            .zkne,\n            .zknh,\n        }),\n    };\n    result[@intFromEnum(Feature.zknd)] = .{\n        .llvm_name = \"zknd\",\n        .description = \"'Zknd' (NIST Suite: AES Decryption)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zkne)] = .{\n        .llvm_name = \"zkne\",\n        .description = \"'Zkne' (NIST Suite: AES Encryption)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zknh)] = .{\n        .llvm_name = \"zknh\",\n        .description = \"'Zknh' (NIST Suite: Hash Function Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zkr)] = .{\n        .llvm_name = \"zkr\",\n        .description = \"'Zkr' (Entropy Source Extension)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zks)] = .{\n        .llvm_name = \"zks\",\n        .description = \"'Zks' (ShangMi Algorithm Suite)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zbkb,\n            .zbkc,\n            .zbkx,\n            .zksed,\n            .zksh,\n        }),\n    };\n    result[@intFromEnum(Feature.zksed)] = .{\n        .llvm_name = \"zksed\",\n        .description = \"'Zksed' (ShangMi Suite: SM4 Block Cipher Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zksh)] = .{\n        .llvm_name = \"zksh\",\n        .description = \"'Zksh' (ShangMi Suite: SM3 Hash Function Instructions)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zkt)] = .{\n        .llvm_name = \"zkt\",\n        .description = \"'Zkt' (Data Independent Execution Latency)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zmmul)] = .{\n        .llvm_name = \"zmmul\",\n        .description = \"'Zmmul' (Integer Multiplication)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zve32f)] = .{\n        .llvm_name = \"zve32f\",\n        .description = \"'Zve32f' (Vector Extensions for Embedded Processors with maximal 32 EEW and F extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .f,\n            .zve32x,\n        }),\n    };\n    result[@intFromEnum(Feature.zve32x)] = .{\n        .llvm_name = \"zve32x\",\n        .description = \"'Zve32x' (Vector Extensions for Embedded Processors with maximal 32 EEW)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zicsr,\n            .zvl32b,\n        }),\n    };\n    result[@intFromEnum(Feature.zve64d)] = .{\n        .llvm_name = \"zve64d\",\n        .description = \"'Zve64d' (Vector Extensions for Embedded Processors with maximal 64 EEW, F and D extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .d,\n            .zve64f,\n        }),\n    };\n    result[@intFromEnum(Feature.zve64f)] = .{\n        .llvm_name = \"zve64f\",\n        .description = \"'Zve64f' (Vector Extensions for Embedded Processors with maximal 64 EEW and F extension)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve32f,\n            .zve64x,\n        }),\n    };\n    result[@intFromEnum(Feature.zve64x)] = .{\n        .llvm_name = \"zve64x\",\n        .description = \"'Zve64x' (Vector Extensions for Embedded Processors with maximal 64 EEW)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zve32x,\n            .zvl64b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvfh)] = .{\n        .llvm_name = \"zvfh\",\n        .description = \"'Zvfh' (Vector Half-Precision Floating-Point)\",\n        .dependencies = featureSet(&[_]Feature{\n            .zfhmin,\n            .zve32f,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl1024b)] = .{\n        .llvm_name = \"zvl1024b\",\n        .description = \"'Zvl' (Minimum Vector Length) 1024\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl512b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl128b)] = .{\n        .llvm_name = \"zvl128b\",\n        .description = \"'Zvl' (Minimum Vector Length) 128\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl64b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl16384b)] = .{\n        .llvm_name = \"zvl16384b\",\n        .description = \"'Zvl' (Minimum Vector Length) 16384\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl8192b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl2048b)] = .{\n        .llvm_name = \"zvl2048b\",\n        .description = \"'Zvl' (Minimum Vector Length) 2048\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl1024b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl256b)] = .{\n        .llvm_name = \"zvl256b\",\n        .description = \"'Zvl' (Minimum Vector Length) 256\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl128b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl32768b)] = .{\n        .llvm_name = \"zvl32768b\",\n        .description = \"'Zvl' (Minimum Vector Length) 32768\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl16384b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl32b)] = .{\n        .llvm_name = \"zvl32b\",\n        .description = \"'Zvl' (Minimum Vector Length) 32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.zvl4096b)] = .{\n        .llvm_name = \"zvl4096b\",\n        .description = \"'Zvl' (Minimum Vector Length) 4096\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl2048b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl512b)] = .{\n        .llvm_name = \"zvl512b\",\n        .description = \"'Zvl' (Minimum Vector Length) 512\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl256b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl64b)] = .{\n        .llvm_name = \"zvl64b\",\n        .description = \"'Zvl' (Minimum Vector Length) 64\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl32b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl65536b)] = .{\n        .llvm_name = \"zvl65536b\",\n        .description = \"'Zvl' (Minimum Vector Length) 65536\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl32768b,\n        }),\n    };\n    result[@intFromEnum(Feature.zvl8192b)] = .{\n        .llvm_name = \"zvl8192b\",\n        .description = \"'Zvl' (Minimum Vector Length) 8192\",\n        .dependencies = featureSet(&[_]Feature{\n            .zvl4096b,\n        }),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.deprecated_v8)] = .{\n        .llvm_name = \"deprecated-v8\",\n        .description = \"Enable deprecated V8 instructions in V9 mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.detectroundchange)] = .{\n        .llvm_name = \"detectroundchange\",\n        .description = \"LEON3 erratum detection: Detects any rounding mode change request: use only the round-to-nearest rounding mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fixallfdivsqrt)] = .{\n        .llvm_name = \"fixallfdivsqrt\",\n        .description = \"LEON erratum fix: Fix FDIVS/FDIVD/FSQRTS/FSQRTD instructions with NOPs and floating-point store\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hard_quad_float)] = .{\n        .llvm_name = \"hard-quad-float\",\n        .description = \"Enable quad-word floating point instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hasleoncasa)] = .{\n        .llvm_name = \"hasleoncasa\",\n        .description = \"Enable CASA instruction for LEON3 and LEON4 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hasumacsmac)] = .{\n        .llvm_name = \"hasumacsmac\",\n        .description = \"Enable UMAC and SMAC for LEON3 and LEON4 processors\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.insertnopload)] = .{\n        .llvm_name = \"insertnopload\",\n        .description = \"LEON3 erratum fix: Insert a NOP instruction after every single-cycle load instruction when the next instruction is another load/store instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.leon)] = .{\n        .llvm_name = \"leon\",\n        .description = \"Enable LEON extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.leoncyclecounter)] = .{\n        .llvm_name = \"leoncyclecounter\",\n        .description = \"Use the Leon cycle counter register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.leonpwrpsr)] = .{\n        .llvm_name = \"leonpwrpsr\",\n        .description = \"Enable the PWRPSR instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_fmuls)] = .{\n        .llvm_name = \"no-fmuls\",\n        .description = \"Disable the fmuls instruction.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_fsmuld)] = .{\n        .llvm_name = \"no-fsmuld\",\n        .description = \"Disable the fsmuld instruction.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.popc)] = .{\n        .llvm_name = \"popc\",\n        .description = \"Use the popc (population count) instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_float)] = .{\n        .llvm_name = \"soft-float\",\n        .description = \"Use software emulation for floating point\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_mul_div)] = .{\n        .llvm_name = \"soft-mul-div\",\n        .description = \"Use software emulation for integer multiply and divide\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v9)] = .{\n        .llvm_name = \"v9\",\n        .description = \"Enable SPARC-V9 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vis)] = .{\n        .llvm_name = \"vis\",\n        .description = \"Enable UltraSPARC Visual Instruction Set extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vis2)] = .{\n        .llvm_name = \"vis2\",\n        .description = \"Enable Visual Instruction Set extensions II\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vis3)] = .{\n        .llvm_name = \"vis3\",\n        .description = \"Enable Visual Instruction Set extensions III\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    @setEvalBranchQuota(2000);\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.v1_1)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V version 1.1\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.v1_2)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V version 1.2\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_1,\n        }),\n    };\n    result[@intFromEnum(Feature.v1_3)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V version 1.3\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_2,\n        }),\n    };\n    result[@intFromEnum(Feature.v1_4)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V version 1.4\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.v1_5)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V version 1.5\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_shader_fragment_mask)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_shader_fragment_mask\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_gpu_shader_int16)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_gpu_shader_int16\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_gpu_shader_half_float)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_gpu_shader_half_float\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_texture_gather_bias_lod)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_texture_gather_bias_lod\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_shader_ballot)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_shader_ballot\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_gcn_shader)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_gcn_shader\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_shader_image_load_store_lod)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_shader_image_load_store_lod\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_shader_explicit_vertex_parameter)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_shader_explicit_vertex_parameter\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_shader_trinary_minmax)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_shader_trinary_minmax\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_AMD_gpu_shader_half_float_fetch)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_AMD_gpu_shader_half_float_fetch\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_GOOGLE_hlsl_functionality1)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_GOOGLE_hlsl_functionality1\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_GOOGLE_user_type)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_GOOGLE_user_type\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_GOOGLE_decorate_string)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_GOOGLE_decorate_string\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_demote_to_helper_invocation)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_demote_to_helper_invocation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_descriptor_indexing)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_descriptor_indexing\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_fragment_fully_covered)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_fragment_fully_covered\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_shader_stencil_export)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_shader_stencil_export\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_physical_storage_buffer)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_physical_storage_buffer\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_shader_atomic_float_add)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_shader_atomic_float_add\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_shader_atomic_float_min_max)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_shader_atomic_float_min_max\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_shader_image_int64)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_shader_image_int64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_fragment_shader_interlock)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_fragment_shader_interlock\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_fragment_invocation_density)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_fragment_invocation_density\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_EXT_shader_viewport_index_layer)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_EXT_shader_viewport_index_layer\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_loop_fuse)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_loop_fuse\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_dsp_control)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_dsp_control\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_reg)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_reg\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_memory_accesses)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_memory_accesses\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_loop_controls)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_loop_controls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_io_pipes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_io_pipes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_unstructured_loop_controls)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_unstructured_loop_controls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_blocking_pipes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_blocking_pipes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_device_side_avc_motion_estimation)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_device_side_avc_motion_estimation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_memory_attributes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_memory_attributes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fp_fast_math_mode)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fp_fast_math_mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_media_block_io)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_media_block_io\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_shader_integer_functions2)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_shader_integer_functions2\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_subgroups)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_subgroups\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_fpga_cluster_attributes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_fpga_cluster_attributes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_kernel_attributes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_kernel_attributes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_INTEL_arbitrary_precision_integers)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_INTEL_arbitrary_precision_integers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_8bit_storage)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_8bit_storage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_shader_clock)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_shader_clock\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_device_group)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_device_group\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_16bit_storage)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_16bit_storage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_variable_pointers)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_variable_pointers\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_no_integer_wrap_decoration)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_no_integer_wrap_decoration\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_subgroup_vote)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_subgroup_vote\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_multiview)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_multiview\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_shader_ballot)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_shader_ballot\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_vulkan_memory_model)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_vulkan_memory_model\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_physical_storage_buffer)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_physical_storage_buffer\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_workgroup_memory_explicit_layout)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_workgroup_memory_explicit_layout\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_fragment_shading_rate)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_fragment_shading_rate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_shader_atomic_counter_ops)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_shader_atomic_counter_ops\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_shader_draw_parameters)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_shader_draw_parameters\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_storage_buffer_storage_class)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_storage_buffer_storage_class\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_linkonce_odr)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_linkonce_odr\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_terminate_invocation)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_terminate_invocation\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_non_semantic_info)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_non_semantic_info\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_post_depth_coverage)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_post_depth_coverage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_expect_assume)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_expect_assume\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_ray_tracing)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_ray_tracing\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_ray_query)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_ray_query\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_KHR_float_controls)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_KHR_float_controls\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_viewport_array2)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_viewport_array2\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_shader_subgroup_partitioned)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_shader_subgroup_partitioned\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NVX_multiview_per_view_attributes)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NVX_multiview_per_view_attributes\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_ray_tracing)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_ray_tracing\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_shader_image_footprint)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_shader_image_footprint\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_shading_rate)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_shading_rate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_stereo_view_rendering)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_stereo_view_rendering\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_compute_shader_derivatives)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_compute_shader_derivatives\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_shader_sm_builtins)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_shader_sm_builtins\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_mesh_shader)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_mesh_shader\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_geometry_shader_passthrough)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_geometry_shader_passthrough\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_fragment_shader_barycentric)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_fragment_shader_barycentric\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_cooperative_matrix)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_cooperative_matrix\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SPV_NV_sample_mask_override_coverage)] = .{\n        .llvm_name = null,\n        .description = \"SPIR-V extension SPV_NV_sample_mask_override_coverage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Matrix)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Matrix\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Shader)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Shader\",\n        .dependencies = featureSet(&[_]Feature{\n            .Matrix,\n        }),\n    };\n    result[@intFromEnum(Feature.Geometry)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Geometry\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Tessellation)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Tessellation\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Addresses)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Addresses\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Linkage)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Linkage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Kernel)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Kernel\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Vector16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Vector16\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.Float16Buffer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Float16Buffer\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.Float16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Float16\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Float64)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Float64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Int64)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Int64\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Int64Atomics)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Int64Atomics\",\n        .dependencies = featureSet(&[_]Feature{\n            .Int64,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageBasic)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageBasic\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageReadWrite)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageReadWrite\",\n        .dependencies = featureSet(&[_]Feature{\n            .ImageBasic,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageMipmap)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageMipmap\",\n        .dependencies = featureSet(&[_]Feature{\n            .ImageBasic,\n        }),\n    };\n    result[@intFromEnum(Feature.Pipes)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Pipes\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.Groups)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Groups\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.DeviceEnqueue)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DeviceEnqueue\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.LiteralSampler)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability LiteralSampler\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.AtomicStorage)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicStorage\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Int16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Int16\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.TessellationPointSize)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability TessellationPointSize\",\n        .dependencies = featureSet(&[_]Feature{\n            .Tessellation,\n        }),\n    };\n    result[@intFromEnum(Feature.GeometryPointSize)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GeometryPointSize\",\n        .dependencies = featureSet(&[_]Feature{\n            .Geometry,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageGatherExtended)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageGatherExtended\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageMultisample)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageMultisample\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformBufferArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformBufferArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledImageArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledImageArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageBufferArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageBufferArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ClipDistance)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ClipDistance\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.CullDistance)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability CullDistance\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageCubeArray)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageCubeArray\",\n        .dependencies = featureSet(&[_]Feature{\n            .SampledCubeArray,\n        }),\n    };\n    result[@intFromEnum(Feature.SampleRateShading)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampleRateShading\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageRect)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageRect\",\n        .dependencies = featureSet(&[_]Feature{\n            .SampledRect,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledRect)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledRect\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.GenericPointer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GenericPointer\",\n        .dependencies = featureSet(&[_]Feature{\n            .Addresses,\n        }),\n    };\n    result[@intFromEnum(Feature.Int8)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Int8\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.InputAttachment)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InputAttachment\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SparseResidency)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SparseResidency\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.MinLod)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability MinLod\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Sampled1D)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Sampled1D\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.Image1D)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Image1D\",\n        .dependencies = featureSet(&[_]Feature{\n            .Sampled1D,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledCubeArray)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledCubeArray\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledBuffer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledBuffer\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ImageBuffer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageBuffer\",\n        .dependencies = featureSet(&[_]Feature{\n            .SampledBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageMSArray)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageMSArray\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageExtendedFormats)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageExtendedFormats\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageQuery)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageQuery\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.DerivativeControl)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DerivativeControl\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.InterpolationFunction)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InterpolationFunction\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.TransformFeedback)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability TransformFeedback\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.GeometryStreams)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GeometryStreams\",\n        .dependencies = featureSet(&[_]Feature{\n            .Geometry,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageReadWithoutFormat)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageReadWithoutFormat\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageWriteWithoutFormat)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageWriteWithoutFormat\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.MultiViewport)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability MultiViewport\",\n        .dependencies = featureSet(&[_]Feature{\n            .Geometry,\n        }),\n    };\n    result[@intFromEnum(Feature.SubgroupDispatch)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupDispatch\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_1,\n            .DeviceEnqueue,\n        }),\n    };\n    result[@intFromEnum(Feature.NamedBarrier)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability NamedBarrier\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_1,\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.PipeStorage)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability PipeStorage\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_1,\n            .Pipes,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniform)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniform\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformVote)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformVote\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformArithmetic)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformArithmetic\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformBallot)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformBallot\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformShuffle)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformShuffle\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformShuffleRelative)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformShuffleRelative\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformClustered)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformClustered\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformQuad)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformQuad\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .GroupNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderLayer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderLayer\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderViewportIndex)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderViewportIndex\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentShadingRateKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentShadingRateKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SubgroupBallotKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupBallotKHR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.DrawParameters)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DrawParameters\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.WorkgroupMemoryExplicitLayoutKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability WorkgroupMemoryExplicitLayoutKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.WorkgroupMemoryExplicitLayout8BitAccessKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability WorkgroupMemoryExplicitLayout8BitAccessKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .WorkgroupMemoryExplicitLayoutKHR,\n        }),\n    };\n    result[@intFromEnum(Feature.WorkgroupMemoryExplicitLayout16BitAccessKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability WorkgroupMemoryExplicitLayout16BitAccessKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SubgroupVoteKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupVoteKHR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.StorageBuffer16BitAccess)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageBuffer16BitAccess\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageUniformBufferBlock16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageUniformBufferBlock16\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformAndStorageBuffer16BitAccess)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformAndStorageBuffer16BitAccess\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .StorageBuffer16BitAccess,\n            .StorageUniformBufferBlock16,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageUniform16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageUniform16\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .StorageBuffer16BitAccess,\n            .StorageUniformBufferBlock16,\n        }),\n    };\n    result[@intFromEnum(Feature.StoragePushConstant16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StoragePushConstant16\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageInputOutput16)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageInputOutput16\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.DeviceGroup)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DeviceGroup\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n        }),\n    };\n    result[@intFromEnum(Feature.MultiView)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability MultiView\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.VariablePointersStorageBuffer)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VariablePointersStorageBuffer\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.VariablePointers)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VariablePointers\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_3,\n            .VariablePointersStorageBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.AtomicStorageOps)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicStorageOps\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SampleMaskPostDepthCoverage)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampleMaskPostDepthCoverage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.StorageBuffer8BitAccess)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageBuffer8BitAccess\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformAndStorageBuffer8BitAccess)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformAndStorageBuffer8BitAccess\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .StorageBuffer8BitAccess,\n        }),\n    };\n    result[@intFromEnum(Feature.StoragePushConstant8)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StoragePushConstant8\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.DenormPreserve)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DenormPreserve\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.DenormFlushToZero)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DenormFlushToZero\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.SignedZeroInfNanPreserve)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SignedZeroInfNanPreserve\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.RoundingModeRTE)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RoundingModeRTE\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.RoundingModeRTZ)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RoundingModeRTZ\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_4,\n        }),\n    };\n    result[@intFromEnum(Feature.RayQueryProvisionalKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayQueryProvisionalKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.RayQueryKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayQueryKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.RayTraversalPrimitiveCullingKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayTraversalPrimitiveCullingKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .RayQueryKHR,\n            .RayTracingKHR,\n        }),\n    };\n    result[@intFromEnum(Feature.RayTracingKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayTracingKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Float16ImageAMD)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Float16ImageAMD\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageGatherBiasLodAMD)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageGatherBiasLodAMD\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentMaskAMD)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentMaskAMD\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.StencilExportEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StencilExportEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageReadWriteLodAMD)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageReadWriteLodAMD\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.Int64ImageEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability Int64ImageEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderClockKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderClockKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SampleMaskOverrideCoverageNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampleMaskOverrideCoverageNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .SampleRateShading,\n        }),\n    };\n    result[@intFromEnum(Feature.GeometryShaderPassthroughNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GeometryShaderPassthroughNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Geometry,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderViewportIndexLayerEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderViewportIndexLayerEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .MultiViewport,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderViewportIndexLayerNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderViewportIndexLayerNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .MultiViewport,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderViewportMaskNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderViewportMaskNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .ShaderViewportIndexLayerNV,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderStereoViewNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderStereoViewNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .ShaderViewportMaskNV,\n        }),\n    };\n    result[@intFromEnum(Feature.PerViewAttributesNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability PerViewAttributesNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .MultiView,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentFullyCoveredEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentFullyCoveredEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.MeshShadingNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability MeshShadingNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ImageFootprintNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ImageFootprintNV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FragmentBarycentricNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentBarycentricNV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ComputeDerivativeGroupQuadsNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ComputeDerivativeGroupQuadsNV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FragmentDensityEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentDensityEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ShadingRateNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShadingRateNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.GroupNonUniformPartitionedNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability GroupNonUniformPartitionedNV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ShaderNonUniform)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderNonUniform\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderNonUniformEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderNonUniformEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.RuntimeDescriptorArray)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RuntimeDescriptorArray\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.RuntimeDescriptorArrayEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RuntimeDescriptorArrayEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.InputAttachmentArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InputAttachmentArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .InputAttachment,\n        }),\n    };\n    result[@intFromEnum(Feature.InputAttachmentArrayDynamicIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InputAttachmentArrayDynamicIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .InputAttachment,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformTexelBufferArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformTexelBufferArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .SampledBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformTexelBufferArrayDynamicIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformTexelBufferArrayDynamicIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .SampledBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageTexelBufferArrayDynamicIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageTexelBufferArrayDynamicIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ImageBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageTexelBufferArrayDynamicIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageTexelBufferArrayDynamicIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ImageBuffer,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformBufferArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformBufferArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformBufferArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformBufferArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledImageArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledImageArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.SampledImageArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SampledImageArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageBufferArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageBufferArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageBufferArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageBufferArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageImageArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageImageArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.InputAttachmentArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InputAttachmentArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .InputAttachment,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.InputAttachmentArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability InputAttachmentArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .InputAttachment,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformTexelBufferArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformTexelBufferArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .SampledBuffer,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.UniformTexelBufferArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UniformTexelBufferArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .SampledBuffer,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageTexelBufferArrayNonUniformIndexing)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageTexelBufferArrayNonUniformIndexing\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ImageBuffer,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.StorageTexelBufferArrayNonUniformIndexingEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability StorageTexelBufferArrayNonUniformIndexingEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .ImageBuffer,\n            .ShaderNonUniform,\n        }),\n    };\n    result[@intFromEnum(Feature.RayTracingNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayTracingNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.VulkanMemoryModel)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VulkanMemoryModel\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.VulkanMemoryModelKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VulkanMemoryModelKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.VulkanMemoryModelDeviceScope)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VulkanMemoryModelDeviceScope\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.VulkanMemoryModelDeviceScopeKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VulkanMemoryModelDeviceScopeKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n        }),\n    };\n    result[@intFromEnum(Feature.PhysicalStorageBufferAddresses)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability PhysicalStorageBufferAddresses\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.PhysicalStorageBufferAddressesEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability PhysicalStorageBufferAddressesEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .v1_5,\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ComputeDerivativeGroupLinearNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ComputeDerivativeGroupLinearNV\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.RayTracingProvisionalKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RayTracingProvisionalKHR\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.CooperativeMatrixNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability CooperativeMatrixNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentShaderSampleInterlockEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentShaderSampleInterlockEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentShaderShadingRateInterlockEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentShaderShadingRateInterlockEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.ShaderSMBuiltinsNV)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ShaderSMBuiltinsNV\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.FragmentShaderPixelInterlockEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FragmentShaderPixelInterlockEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.DemoteToHelperInvocationEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability DemoteToHelperInvocationEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.SubgroupShuffleINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupShuffleINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupBufferBlockIOINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupBufferBlockIOINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupImageBlockIOINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupImageBlockIOINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupImageMediaBlockIOINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupImageMediaBlockIOINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.RoundToInfinityINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability RoundToInfinityINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FloatingPointModeINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FloatingPointModeINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.IntegerFunctions2INTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability IntegerFunctions2INTEL\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.FunctionPointersINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FunctionPointersINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.IndirectReferencesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability IndirectReferencesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.AsmINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AsmINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.AtomicFloat32MinMaxEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicFloat32MinMaxEXT\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.AtomicFloat64MinMaxEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicFloat64MinMaxEXT\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.AtomicFloat16MinMaxEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicFloat16MinMaxEXT\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.VectorComputeINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VectorComputeINTEL\",\n        .dependencies = featureSet(&[_]Feature{\n            .VectorAnyINTEL,\n        }),\n    };\n    result[@intFromEnum(Feature.VectorAnyINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VectorAnyINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ExpectAssumeKHR)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ExpectAssumeKHR\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupAvcMotionEstimationINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupAvcMotionEstimationINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupAvcMotionEstimationIntraINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupAvcMotionEstimationIntraINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.SubgroupAvcMotionEstimationChromaINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability SubgroupAvcMotionEstimationChromaINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.VariableLengthArrayINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability VariableLengthArrayINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FunctionFloatControlINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FunctionFloatControlINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGAMemoryAttributesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGAMemoryAttributesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPFastMathModeINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPFastMathModeINTEL\",\n        .dependencies = featureSet(&[_]Feature{\n            .Kernel,\n        }),\n    };\n    result[@intFromEnum(Feature.ArbitraryPrecisionIntegersINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability ArbitraryPrecisionIntegersINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.UnstructuredLoopControlsINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability UnstructuredLoopControlsINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGALoopControlsINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGALoopControlsINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.KernelAttributesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability KernelAttributesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGAKernelAttributesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGAKernelAttributesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGAMemoryAccessesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGAMemoryAccessesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGAClusterAttributesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGAClusterAttributesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.LoopFuseINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability LoopFuseINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGABufferLocationINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGABufferLocationINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.USMStorageClassesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability USMStorageClassesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.IOPipesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability IOPipesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.BlockingPipesINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability BlockingPipesINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.FPGARegINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability FPGARegINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.AtomicFloat32AddEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicFloat32AddEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.AtomicFloat64AddEXT)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability AtomicFloat64AddEXT\",\n        .dependencies = featureSet(&[_]Feature{\n            .Shader,\n        }),\n    };\n    result[@intFromEnum(Feature.LongConstantCompositeINTEL)] = .{\n        .llvm_name = null,\n        .description = \"Enable SPIR-V capability LongConstantCompositeINTEL\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.bear_enhancement)] = .{\n        .llvm_name = \"bear-enhancement\",\n        .description = \"Assume that the BEAR-enhancement facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.deflate_conversion)] = .{\n        .llvm_name = \"deflate-conversion\",\n        .description = \"Assume that the deflate-conversion facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dfp_packed_conversion)] = .{\n        .llvm_name = \"dfp-packed-conversion\",\n        .description = \"Assume that the DFP packed-conversion facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.dfp_zoned_conversion)] = .{\n        .llvm_name = \"dfp-zoned-conversion\",\n        .description = \"Assume that the DFP zoned-conversion facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.distinct_ops)] = .{\n        .llvm_name = \"distinct-ops\",\n        .description = \"Assume that the distinct-operands facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.enhanced_dat_2)] = .{\n        .llvm_name = \"enhanced-dat-2\",\n        .description = \"Assume that the enhanced-DAT facility 2 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.enhanced_sort)] = .{\n        .llvm_name = \"enhanced-sort\",\n        .description = \"Assume that the enhanced-sort facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.execution_hint)] = .{\n        .llvm_name = \"execution-hint\",\n        .description = \"Assume that the execution-hint facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_serialization)] = .{\n        .llvm_name = \"fast-serialization\",\n        .description = \"Assume that the fast-serialization facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fp_extension)] = .{\n        .llvm_name = \"fp-extension\",\n        .description = \"Assume that the floating-point extension facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.guarded_storage)] = .{\n        .llvm_name = \"guarded-storage\",\n        .description = \"Assume that the guarded-storage facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.high_word)] = .{\n        .llvm_name = \"high-word\",\n        .description = \"Assume that the high-word facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.insert_reference_bits_multiple)] = .{\n        .llvm_name = \"insert-reference-bits-multiple\",\n        .description = \"Assume that the insert-reference-bits-multiple facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.interlocked_access1)] = .{\n        .llvm_name = \"interlocked-access1\",\n        .description = \"Assume that interlocked-access facility 1 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.load_and_trap)] = .{\n        .llvm_name = \"load-and-trap\",\n        .description = \"Assume that the load-and-trap facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.load_and_zero_rightmost_byte)] = .{\n        .llvm_name = \"load-and-zero-rightmost-byte\",\n        .description = \"Assume that the load-and-zero-rightmost-byte facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.load_store_on_cond)] = .{\n        .llvm_name = \"load-store-on-cond\",\n        .description = \"Assume that the load/store-on-condition facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.load_store_on_cond_2)] = .{\n        .llvm_name = \"load-store-on-cond-2\",\n        .description = \"Assume that the load/store-on-condition facility 2 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension3)] = .{\n        .llvm_name = \"message-security-assist-extension3\",\n        .description = \"Assume that the message-security-assist extension facility 3 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension4)] = .{\n        .llvm_name = \"message-security-assist-extension4\",\n        .description = \"Assume that the message-security-assist extension facility 4 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension5)] = .{\n        .llvm_name = \"message-security-assist-extension5\",\n        .description = \"Assume that the message-security-assist extension facility 5 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension7)] = .{\n        .llvm_name = \"message-security-assist-extension7\",\n        .description = \"Assume that the message-security-assist extension facility 7 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension8)] = .{\n        .llvm_name = \"message-security-assist-extension8\",\n        .description = \"Assume that the message-security-assist extension facility 8 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.message_security_assist_extension9)] = .{\n        .llvm_name = \"message-security-assist-extension9\",\n        .description = \"Assume that the message-security-assist extension facility 9 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.miscellaneous_extensions)] = .{\n        .llvm_name = \"miscellaneous-extensions\",\n        .description = \"Assume that the miscellaneous-extensions facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.miscellaneous_extensions_2)] = .{\n        .llvm_name = \"miscellaneous-extensions-2\",\n        .description = \"Assume that the miscellaneous-extensions facility 2 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.miscellaneous_extensions_3)] = .{\n        .llvm_name = \"miscellaneous-extensions-3\",\n        .description = \"Assume that the miscellaneous-extensions facility 3 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nnp_assist)] = .{\n        .llvm_name = \"nnp-assist\",\n        .description = \"Assume that the NNP-assist facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.population_count)] = .{\n        .llvm_name = \"population-count\",\n        .description = \"Assume that the population-count facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.processor_activity_instrumentation)] = .{\n        .llvm_name = \"processor-activity-instrumentation\",\n        .description = \"Assume that the processor-activity-instrumentation facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.processor_assist)] = .{\n        .llvm_name = \"processor-assist\",\n        .description = \"Assume that the processor-assist facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reset_dat_protection)] = .{\n        .llvm_name = \"reset-dat-protection\",\n        .description = \"Assume that the reset-DAT-protection facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reset_reference_bits_multiple)] = .{\n        .llvm_name = \"reset-reference-bits-multiple\",\n        .description = \"Assume that the reset-reference-bits-multiple facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.soft_float)] = .{\n        .llvm_name = \"soft-float\",\n        .description = \"Use software emulation for floating point\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.transactional_execution)] = .{\n        .llvm_name = \"transactional-execution\",\n        .description = \"Assume that the transactional-execution facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector)] = .{\n        .llvm_name = \"vector\",\n        .description = \"Assume that the vectory facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector_enhancements_1)] = .{\n        .llvm_name = \"vector-enhancements-1\",\n        .description = \"Assume that the vector enhancements facility 1 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector_enhancements_2)] = .{\n        .llvm_name = \"vector-enhancements-2\",\n        .description = \"Assume that the vector enhancements facility 2 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector_packed_decimal)] = .{\n        .llvm_name = \"vector-packed-decimal\",\n        .description = \"Assume that the vector packed decimal facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector_packed_decimal_enhancement)] = .{\n        .llvm_name = \"vector-packed-decimal-enhancement\",\n        .description = \"Assume that the vector packed decimal enhancement facility is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vector_packed_decimal_enhancement_2)] = .{\n        .llvm_name = \"vector-packed-decimal-enhancement-2\",\n        .description = \"Assume that the vector packed decimal enhancement facility 2 is installed\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.vpu)] = .{\n        .llvm_name = \"vpu\",\n        .description = \"Enable the VPU\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.atomics)] = .{\n        .llvm_name = \"atomics\",\n        .description = \"Enable Atomics\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.bulk_memory)] = .{\n        .llvm_name = \"bulk-memory\",\n        .description = \"Enable bulk memory operations\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.exception_handling)] = .{\n        .llvm_name = \"exception-handling\",\n        .description = \"Enable Wasm exception handling\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.extended_const)] = .{\n        .llvm_name = \"extended-const\",\n        .description = \"Enable extended const expressions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.multivalue)] = .{\n        .llvm_name = \"multivalue\",\n        .description = \"Enable multivalue blocks, instructions, and functions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mutable_globals)] = .{\n        .llvm_name = \"mutable-globals\",\n        .description = \"Enable mutable globals\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nontrapping_fptoint)] = .{\n        .llvm_name = \"nontrapping-fptoint\",\n        .description = \"Enable non-trapping float-to-int conversion operators\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.reference_types)] = .{\n        .llvm_name = \"reference-types\",\n        .description = \"Enable reference types\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.relaxed_simd)] = .{\n        .llvm_name = \"relaxed-simd\",\n        .description = \"Enable relaxed-simd instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sign_ext)] = .{\n        .llvm_name = \"sign-ext\",\n        .description = \"Enable sign extension operators\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.simd128)] = .{\n        .llvm_name = \"simd128\",\n        .description = \"Enable 128-bit SIMD\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tail_call)] = .{\n        .llvm_name = \"tail-call\",\n        .description = \"Enable tail call instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.@\"16bit_mode\")] = .{\n        .llvm_name = \"16bit-mode\",\n        .description = \"16-bit mode (i8086)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"32bit_mode\")] = .{\n        .llvm_name = \"32bit-mode\",\n        .description = \"32-bit mode (80386)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.@\"3dnow\")] = .{\n        .llvm_name = \"3dnow\",\n        .description = \"Enable 3DNow! instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .mmx,\n        }),\n    };\n    result[@intFromEnum(Feature.@\"3dnowa\")] = .{\n        .llvm_name = \"3dnowa\",\n        .description = \"Enable 3DNow! Athlon instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .@\"3dnow\",\n        }),\n    };\n    result[@intFromEnum(Feature.@\"64bit\")] = .{\n        .llvm_name = \"64bit\",\n        .description = \"Support 64-bit instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.adx)] = .{\n        .llvm_name = \"adx\",\n        .description = \"Support ADX instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.aes)] = .{\n        .llvm_name = \"aes\",\n        .description = \"Enable AES instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.allow_light_256_bit)] = .{\n        .llvm_name = \"allow-light-256-bit\",\n        .description = \"Enable generation of 256-bit load/stores even if we prefer 128-bit\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.amx_bf16)] = .{\n        .llvm_name = \"amx-bf16\",\n        .description = \"Support AMX-BF16 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .amx_tile,\n        }),\n    };\n    result[@intFromEnum(Feature.amx_complex)] = .{\n        .llvm_name = \"amx-complex\",\n        .description = \"Support AMX-COMPLEX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .amx_tile,\n        }),\n    };\n    result[@intFromEnum(Feature.amx_fp16)] = .{\n        .llvm_name = \"amx-fp16\",\n        .description = \"Support AMX amx-fp16 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .amx_tile,\n        }),\n    };\n    result[@intFromEnum(Feature.amx_int8)] = .{\n        .llvm_name = \"amx-int8\",\n        .description = \"Support AMX-INT8 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .amx_tile,\n        }),\n    };\n    result[@intFromEnum(Feature.amx_tile)] = .{\n        .llvm_name = \"amx-tile\",\n        .description = \"Support AMX-TILE instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.avx)] = .{\n        .llvm_name = \"avx\",\n        .description = \"Enable AVX instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse4_2,\n        }),\n    };\n    result[@intFromEnum(Feature.avx2)] = .{\n        .llvm_name = \"avx2\",\n        .description = \"Enable AVX2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512bf16)] = .{\n        .llvm_name = \"avx512bf16\",\n        .description = \"Support bfloat16 floating point\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512bw,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512bitalg)] = .{\n        .llvm_name = \"avx512bitalg\",\n        .description = \"Enable AVX-512 Bit Algorithms\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512bw,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512bw)] = .{\n        .llvm_name = \"avx512bw\",\n        .description = \"Enable AVX-512 Byte and Word Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512cd)] = .{\n        .llvm_name = \"avx512cd\",\n        .description = \"Enable AVX-512 Conflict Detection Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512dq)] = .{\n        .llvm_name = \"avx512dq\",\n        .description = \"Enable AVX-512 Doubleword and Quadword Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512er)] = .{\n        .llvm_name = \"avx512er\",\n        .description = \"Enable AVX-512 Exponential and Reciprocal Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512f)] = .{\n        .llvm_name = \"avx512f\",\n        .description = \"Enable AVX-512 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n            .f16c,\n            .fma,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512fp16)] = .{\n        .llvm_name = \"avx512fp16\",\n        .description = \"Support 16-bit floating point\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512bw,\n            .avx512dq,\n            .avx512vl,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512ifma)] = .{\n        .llvm_name = \"avx512ifma\",\n        .description = \"Enable AVX-512 Integer Fused Multiple-Add\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512pf)] = .{\n        .llvm_name = \"avx512pf\",\n        .description = \"Enable AVX-512 PreFetch Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vbmi)] = .{\n        .llvm_name = \"avx512vbmi\",\n        .description = \"Enable AVX-512 Vector Byte Manipulation Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512bw,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vbmi2)] = .{\n        .llvm_name = \"avx512vbmi2\",\n        .description = \"Enable AVX-512 further Vector Byte Manipulation Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512bw,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vl)] = .{\n        .llvm_name = \"avx512vl\",\n        .description = \"Enable AVX-512 Vector Length eXtensions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vnni)] = .{\n        .llvm_name = \"avx512vnni\",\n        .description = \"Enable AVX-512 Vector Neural Network Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vp2intersect)] = .{\n        .llvm_name = \"avx512vp2intersect\",\n        .description = \"Enable AVX-512 vp2intersect\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avx512vpopcntdq)] = .{\n        .llvm_name = \"avx512vpopcntdq\",\n        .description = \"Enable AVX-512 Population Count Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx512f,\n        }),\n    };\n    result[@intFromEnum(Feature.avxifma)] = .{\n        .llvm_name = \"avxifma\",\n        .description = \"Enable AVX-IFMA\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n        }),\n    };\n    result[@intFromEnum(Feature.avxneconvert)] = .{\n        .llvm_name = \"avxneconvert\",\n        .description = \"Support AVX-NE-CONVERT instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n        }),\n    };\n    result[@intFromEnum(Feature.avxvnni)] = .{\n        .llvm_name = \"avxvnni\",\n        .description = \"Support AVX_VNNI encoding\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n        }),\n    };\n    result[@intFromEnum(Feature.avxvnniint16)] = .{\n        .llvm_name = \"avxvnniint16\",\n        .description = \"Enable AVX-VNNI-INT16\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n        }),\n    };\n    result[@intFromEnum(Feature.avxvnniint8)] = .{\n        .llvm_name = \"avxvnniint8\",\n        .description = \"Enable AVX-VNNI-INT8\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx2,\n        }),\n    };\n    result[@intFromEnum(Feature.bmi)] = .{\n        .llvm_name = \"bmi\",\n        .description = \"Support BMI instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.bmi2)] = .{\n        .llvm_name = \"bmi2\",\n        .description = \"Support BMI2 instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.branchfusion)] = .{\n        .llvm_name = \"branchfusion\",\n        .description = \"CMP/TEST can be fused with conditional branches\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cldemote)] = .{\n        .llvm_name = \"cldemote\",\n        .description = \"Enable Cache Line Demote\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.clflushopt)] = .{\n        .llvm_name = \"clflushopt\",\n        .description = \"Flush A Cache Line Optimized\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.clwb)] = .{\n        .llvm_name = \"clwb\",\n        .description = \"Cache Line Write Back\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.clzero)] = .{\n        .llvm_name = \"clzero\",\n        .description = \"Enable Cache Line Zero\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cmov)] = .{\n        .llvm_name = \"cmov\",\n        .description = \"Enable conditional move instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cmpccxadd)] = .{\n        .llvm_name = \"cmpccxadd\",\n        .description = \"Support CMPCCXADD instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.crc32)] = .{\n        .llvm_name = \"crc32\",\n        .description = \"Enable SSE 4.2 CRC32 instruction (used when SSE4.2 is supported but function is GPR only)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.cx16)] = .{\n        .llvm_name = \"cx16\",\n        .description = \"64-bit with cmpxchg16b (this is true for most x86-64 chips, but not the first AMD chips)\",\n        .dependencies = featureSet(&[_]Feature{\n            .cx8,\n        }),\n    };\n    result[@intFromEnum(Feature.cx8)] = .{\n        .llvm_name = \"cx8\",\n        .description = \"Support CMPXCHG8B instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.enqcmd)] = .{\n        .llvm_name = \"enqcmd\",\n        .description = \"Has ENQCMD instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ermsb)] = .{\n        .llvm_name = \"ermsb\",\n        .description = \"REP MOVS/STOS are fast\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.f16c)] = .{\n        .llvm_name = \"f16c\",\n        .description = \"Support 16-bit floating point conversion instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.false_deps_getmant)] = .{\n        .llvm_name = \"false-deps-getmant\",\n        .description = \"VGETMANTSS/SD/SH and VGETMANDPS/PD(memory version) has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_lzcnt_tzcnt)] = .{\n        .llvm_name = \"false-deps-lzcnt-tzcnt\",\n        .description = \"LZCNT/TZCNT have a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_mulc)] = .{\n        .llvm_name = \"false-deps-mulc\",\n        .description = \"VF[C]MULCPH/SH has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_mullq)] = .{\n        .llvm_name = \"false-deps-mullq\",\n        .description = \"VPMULLQ has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_perm)] = .{\n        .llvm_name = \"false-deps-perm\",\n        .description = \"VPERMD/Q/PS/PD has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_popcnt)] = .{\n        .llvm_name = \"false-deps-popcnt\",\n        .description = \"POPCNT has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.false_deps_range)] = .{\n        .llvm_name = \"false-deps-range\",\n        .description = \"VRANGEPD/PS/SD/SS has a false dependency on dest register\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_11bytenop)] = .{\n        .llvm_name = \"fast-11bytenop\",\n        .description = \"Target can quickly decode up to 11 byte NOPs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_15bytenop)] = .{\n        .llvm_name = \"fast-15bytenop\",\n        .description = \"Target can quickly decode up to 15 byte NOPs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_7bytenop)] = .{\n        .llvm_name = \"fast-7bytenop\",\n        .description = \"Target can quickly decode up to 7 byte NOPs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_bextr)] = .{\n        .llvm_name = \"fast-bextr\",\n        .description = \"Indicates that the BEXTR instruction is implemented as a single uop with good throughput\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_gather)] = .{\n        .llvm_name = \"fast-gather\",\n        .description = \"Indicates if gather is reasonably fast (this is true for Skylake client and all AVX-512 CPUs)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_hops)] = .{\n        .llvm_name = \"fast-hops\",\n        .description = \"Prefer horizontal vector math instructions (haddp, phsub, etc.) over normal vector instructions with shuffles\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_lzcnt)] = .{\n        .llvm_name = \"fast-lzcnt\",\n        .description = \"LZCNT instructions are as fast as most simple integer ops\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_movbe)] = .{\n        .llvm_name = \"fast-movbe\",\n        .description = \"Prefer a movbe over a single-use load + bswap / single-use bswap + store\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_scalar_fsqrt)] = .{\n        .llvm_name = \"fast-scalar-fsqrt\",\n        .description = \"Scalar SQRT is fast (disable Newton-Raphson)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_scalar_shift_masks)] = .{\n        .llvm_name = \"fast-scalar-shift-masks\",\n        .description = \"Prefer a left/right scalar logical shift pair over a shift+and pair\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_shld_rotate)] = .{\n        .llvm_name = \"fast-shld-rotate\",\n        .description = \"SHLD can be used as a faster rotate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_variable_crosslane_shuffle)] = .{\n        .llvm_name = \"fast-variable-crosslane-shuffle\",\n        .description = \"Cross-lane shuffles with variable masks are fast\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_variable_perlane_shuffle)] = .{\n        .llvm_name = \"fast-variable-perlane-shuffle\",\n        .description = \"Per-lane shuffles with variable masks are fast\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_vector_fsqrt)] = .{\n        .llvm_name = \"fast-vector-fsqrt\",\n        .description = \"Vector SQRT is fast (disable Newton-Raphson)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fast_vector_shift_masks)] = .{\n        .llvm_name = \"fast-vector-shift-masks\",\n        .description = \"Prefer a left/right vector logical shift pair over a shift+and pair\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.faster_shift_than_shuffle)] = .{\n        .llvm_name = \"faster-shift-than-shuffle\",\n        .description = \"Shifts are faster (or as fast) as shuffle\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fma)] = .{\n        .llvm_name = \"fma\",\n        .description = \"Enable three-operand fused multiple-add\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.fma4)] = .{\n        .llvm_name = \"fma4\",\n        .description = \"Enable four-operand fused multiple-add\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n            .sse4a,\n        }),\n    };\n    result[@intFromEnum(Feature.fsgsbase)] = .{\n        .llvm_name = \"fsgsbase\",\n        .description = \"Support FS/GS Base instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fsrm)] = .{\n        .llvm_name = \"fsrm\",\n        .description = \"REP MOVSB of short lengths is faster\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.fxsr)] = .{\n        .llvm_name = \"fxsr\",\n        .description = \"Support fxsave/fxrestore instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.gfni)] = .{\n        .llvm_name = \"gfni\",\n        .description = \"Enable Galois Field Arithmetic Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.harden_sls_ijmp)] = .{\n        .llvm_name = \"harden-sls-ijmp\",\n        .description = \"Harden against straight line speculation across indirect JMP instructions.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.harden_sls_ret)] = .{\n        .llvm_name = \"harden-sls-ret\",\n        .description = \"Harden against straight line speculation across RET instructions.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.hreset)] = .{\n        .llvm_name = \"hreset\",\n        .description = \"Has hreset instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.idivl_to_divb)] = .{\n        .llvm_name = \"idivl-to-divb\",\n        .description = \"Use 8-bit divide for positive values less than 256\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.idivq_to_divl)] = .{\n        .llvm_name = \"idivq-to-divl\",\n        .description = \"Use 32-bit divide for positive values less than 2^32\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.invpcid)] = .{\n        .llvm_name = \"invpcid\",\n        .description = \"Invalidate Process-Context Identifier\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.kl)] = .{\n        .llvm_name = \"kl\",\n        .description = \"Support Key Locker kl Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.lea_sp)] = .{\n        .llvm_name = \"lea-sp\",\n        .description = \"Use LEA for adjusting the stack pointer (this is an optimization for Intel Atom processors)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lea_uses_ag)] = .{\n        .llvm_name = \"lea-uses-ag\",\n        .description = \"LEA instruction needs inputs at AG stage\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lvi_cfi)] = .{\n        .llvm_name = \"lvi-cfi\",\n        .description = \"Prevent indirect calls/branches from using a memory operand, and precede all indirect calls/branches from a register with an LFENCE instruction to serialize control flow. Also decompose RET instructions into a POP+LFENCE+JMP sequence.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lvi_load_hardening)] = .{\n        .llvm_name = \"lvi-load-hardening\",\n        .description = \"Insert LFENCE instructions to prevent data speculatively injected into loads from being used maliciously.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lwp)] = .{\n        .llvm_name = \"lwp\",\n        .description = \"Enable LWP instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.lzcnt)] = .{\n        .llvm_name = \"lzcnt\",\n        .description = \"Support LZCNT instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.macrofusion)] = .{\n        .llvm_name = \"macrofusion\",\n        .description = \"Various instructions can be fused with conditional branches\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mmx)] = .{\n        .llvm_name = \"mmx\",\n        .description = \"Enable MMX instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.movbe)] = .{\n        .llvm_name = \"movbe\",\n        .description = \"Support MOVBE instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.movdir64b)] = .{\n        .llvm_name = \"movdir64b\",\n        .description = \"Support movdir64b instruction (direct store 64 bytes)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.movdiri)] = .{\n        .llvm_name = \"movdiri\",\n        .description = \"Support movdiri instruction (direct store integer)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.mwaitx)] = .{\n        .llvm_name = \"mwaitx\",\n        .description = \"Enable MONITORX/MWAITX timer functionality\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bypass_delay)] = .{\n        .llvm_name = \"no-bypass-delay\",\n        .description = \"Has no bypass delay when using the 'wrong' domain\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bypass_delay_blend)] = .{\n        .llvm_name = \"no-bypass-delay-blend\",\n        .description = \"Has no bypass delay when using the 'wrong' blend type\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bypass_delay_mov)] = .{\n        .llvm_name = \"no-bypass-delay-mov\",\n        .description = \"Has no bypass delay when using the 'wrong' mov type\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.no_bypass_delay_shuffle)] = .{\n        .llvm_name = \"no-bypass-delay-shuffle\",\n        .description = \"Has no bypass delay when using the 'wrong' shuffle type\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.nopl)] = .{\n        .llvm_name = \"nopl\",\n        .description = \"Enable NOPL instruction (generally pentium pro+)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pad_short_functions)] = .{\n        .llvm_name = \"pad-short-functions\",\n        .description = \"Pad short functions (to prevent a stall when returning too early)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pclmul)] = .{\n        .llvm_name = \"pclmul\",\n        .description = \"Enable packed carry-less multiplication instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.pconfig)] = .{\n        .llvm_name = \"pconfig\",\n        .description = \"platform configuration instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.pku)] = .{\n        .llvm_name = \"pku\",\n        .description = \"Enable protection keys\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.popcnt)] = .{\n        .llvm_name = \"popcnt\",\n        .description = \"Support POPCNT instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_128_bit)] = .{\n        .llvm_name = \"prefer-128-bit\",\n        .description = \"Prefer 128-bit AVX instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_256_bit)] = .{\n        .llvm_name = \"prefer-256-bit\",\n        .description = \"Prefer 256-bit AVX instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_mask_registers)] = .{\n        .llvm_name = \"prefer-mask-registers\",\n        .description = \"Prefer AVX512 mask registers over PTEST/MOVMSK\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefer_movmsk_over_vtest)] = .{\n        .llvm_name = \"prefer-movmsk-over-vtest\",\n        .description = \"Prefer movmsk over vtest instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefetchi)] = .{\n        .llvm_name = \"prefetchi\",\n        .description = \"Prefetch instruction with T0 or T1 Hint\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prefetchwt1)] = .{\n        .llvm_name = \"prefetchwt1\",\n        .description = \"Prefetch with Intent to Write and T1 Hint\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.prfchw)] = .{\n        .llvm_name = \"prfchw\",\n        .description = \"Support PRFCHW instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ptwrite)] = .{\n        .llvm_name = \"ptwrite\",\n        .description = \"Support ptwrite instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.raoint)] = .{\n        .llvm_name = \"raoint\",\n        .description = \"Support RAO-INT instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rdpid)] = .{\n        .llvm_name = \"rdpid\",\n        .description = \"Support RDPID instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rdpru)] = .{\n        .llvm_name = \"rdpru\",\n        .description = \"Support RDPRU instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rdrnd)] = .{\n        .llvm_name = \"rdrnd\",\n        .description = \"Support RDRAND instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rdseed)] = .{\n        .llvm_name = \"rdseed\",\n        .description = \"Support RDSEED instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.retpoline)] = .{\n        .llvm_name = \"retpoline\",\n        .description = \"Remove speculation of indirect branches from the generated code, either by avoiding them entirely or lowering them with a speculation blocking construct\",\n        .dependencies = featureSet(&[_]Feature{\n            .retpoline_indirect_branches,\n            .retpoline_indirect_calls,\n        }),\n    };\n    result[@intFromEnum(Feature.retpoline_external_thunk)] = .{\n        .llvm_name = \"retpoline-external-thunk\",\n        .description = \"When lowering an indirect call or branch using a `retpoline`, rely on the specified user provided thunk rather than emitting one ourselves. Only has effect when combined with some other retpoline feature\",\n        .dependencies = featureSet(&[_]Feature{\n            .retpoline_indirect_calls,\n        }),\n    };\n    result[@intFromEnum(Feature.retpoline_indirect_branches)] = .{\n        .llvm_name = \"retpoline-indirect-branches\",\n        .description = \"Remove speculation of indirect branches from the generated code\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.retpoline_indirect_calls)] = .{\n        .llvm_name = \"retpoline-indirect-calls\",\n        .description = \"Remove speculation of indirect calls from the generated code\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.rtm)] = .{\n        .llvm_name = \"rtm\",\n        .description = \"Support RTM instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sahf)] = .{\n        .llvm_name = \"sahf\",\n        .description = \"Support LAHF and SAHF instructions in 64-bit mode\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sbb_dep_breaking)] = .{\n        .llvm_name = \"sbb-dep-breaking\",\n        .description = \"SBB with same register has no source dependency\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.serialize)] = .{\n        .llvm_name = \"serialize\",\n        .description = \"Has serialize instruction\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.seses)] = .{\n        .llvm_name = \"seses\",\n        .description = \"Prevent speculative execution side channel timing attacks by inserting a speculation barrier before memory reads, memory writes, and conditional branches. Implies LVI Control Flow integrity.\",\n        .dependencies = featureSet(&[_]Feature{\n            .lvi_cfi,\n        }),\n    };\n    result[@intFromEnum(Feature.sgx)] = .{\n        .llvm_name = \"sgx\",\n        .description = \"Enable Software Guard Extensions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sha)] = .{\n        .llvm_name = \"sha\",\n        .description = \"Enable SHA instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.sha512)] = .{\n        .llvm_name = \"sha512\",\n        .description = \"Support SHA512 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.shstk)] = .{\n        .llvm_name = \"shstk\",\n        .description = \"Support CET Shadow-Stack instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_3ops_lea)] = .{\n        .llvm_name = \"slow-3ops-lea\",\n        .description = \"LEA instruction with 3 ops or certain registers is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_incdec)] = .{\n        .llvm_name = \"slow-incdec\",\n        .description = \"INC and DEC instructions are slower than ADD and SUB\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_lea)] = .{\n        .llvm_name = \"slow-lea\",\n        .description = \"LEA instruction with certain arguments is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_pmaddwd)] = .{\n        .llvm_name = \"slow-pmaddwd\",\n        .description = \"PMADDWD is slower than PMULLD\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_pmulld)] = .{\n        .llvm_name = \"slow-pmulld\",\n        .description = \"PMULLD instruction is slow (compared to PMULLW/PMULHW and PMULUDQ)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_shld)] = .{\n        .llvm_name = \"slow-shld\",\n        .description = \"SHLD instruction is slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_two_mem_ops)] = .{\n        .llvm_name = \"slow-two-mem-ops\",\n        .description = \"Two memory operand instructions are slow\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_unaligned_mem_16)] = .{\n        .llvm_name = \"slow-unaligned-mem-16\",\n        .description = \"Slow unaligned 16-byte memory access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.slow_unaligned_mem_32)] = .{\n        .llvm_name = \"slow-unaligned-mem-32\",\n        .description = \"Slow unaligned 32-byte memory access\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sm3)] = .{\n        .llvm_name = \"sm3\",\n        .description = \"Support SM3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.sm4)] = .{\n        .llvm_name = \"sm4\",\n        .description = \"Support SM4 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.soft_float)] = .{\n        .llvm_name = \"soft-float\",\n        .description = \"Use software floating point features\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sse)] = .{\n        .llvm_name = \"sse\",\n        .description = \"Enable SSE instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.sse2)] = .{\n        .llvm_name = \"sse2\",\n        .description = \"Enable SSE2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse,\n        }),\n    };\n    result[@intFromEnum(Feature.sse3)] = .{\n        .llvm_name = \"sse3\",\n        .description = \"Enable SSE3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse2,\n        }),\n    };\n    result[@intFromEnum(Feature.sse4_1)] = .{\n        .llvm_name = \"sse4.1\",\n        .description = \"Enable SSE 4.1 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .ssse3,\n        }),\n    };\n    result[@intFromEnum(Feature.sse4_2)] = .{\n        .llvm_name = \"sse4.2\",\n        .description = \"Enable SSE 4.2 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse4_1,\n        }),\n    };\n    result[@intFromEnum(Feature.sse4a)] = .{\n        .llvm_name = \"sse4a\",\n        .description = \"Support SSE 4a instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse3,\n        }),\n    };\n    result[@intFromEnum(Feature.sse_unaligned_mem)] = .{\n        .llvm_name = \"sse-unaligned-mem\",\n        .description = \"Allow unaligned memory operands with SSE instructions (this may require setting a configuration bit in the processor)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.ssse3)] = .{\n        .llvm_name = \"ssse3\",\n        .description = \"Enable SSSE3 instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .sse3,\n        }),\n    };\n    result[@intFromEnum(Feature.tagged_globals)] = .{\n        .llvm_name = \"tagged-globals\",\n        .description = \"Use an instruction sequence for taking the address of a global that allows a memory tag in the upper address bits.\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tbm)] = .{\n        .llvm_name = \"tbm\",\n        .description = \"Enable TBM instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tsxldtrk)] = .{\n        .llvm_name = \"tsxldtrk\",\n        .description = \"Support TSXLDTRK instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.tuning_fast_imm_vector_shift)] = .{\n        .llvm_name = \"tuning-fast-imm-vector-shift\",\n        .description = \"Vector shifts are fast (2/cycle) as opposed to slow (1/cycle)\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.uintr)] = .{\n        .llvm_name = \"uintr\",\n        .description = \"Has UINTR Instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_glm_div_sqrt_costs)] = .{\n        .llvm_name = \"use-glm-div-sqrt-costs\",\n        .description = \"Use Goldmont specific floating point div/sqrt costs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.use_slm_arith_costs)] = .{\n        .llvm_name = \"use-slm-arith-costs\",\n        .description = \"Use Silvermont specific arithmetic costs\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.vaes)] = .{\n        .llvm_name = \"vaes\",\n        .description = \"Promote selected AES instructions to AVX512/AVX registers\",\n        .dependencies = featureSet(&[_]Feature{\n            .aes,\n            .avx,\n        }),\n    };\n    result[@intFromEnum(Feature.vpclmulqdq)] = .{\n        .llvm_name = \"vpclmulqdq\",\n        .description = \"Enable vpclmulqdq instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .avx,\n            .pclmul,\n        }),\n    };\n    result[@intFromEnum(Feature.vzeroupper)] = .{\n        .llvm_name = \"vzeroupper\",\n        .description = \"Should insert vzeroupper instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.waitpkg)] = .{\n        .llvm_name = \"waitpkg\",\n        .description = \"Wait and pause enhancements\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.wbnoinvd)] = .{\n        .llvm_name = \"wbnoinvd\",\n        .description = \"Write Back No Invalidate\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.widekl)] = .{\n        .llvm_name = \"widekl\",\n        .description = \"Support Key Locker wide Instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .kl,\n        }),\n    };\n    result[@intFromEnum(Feature.x87)] = .{\n        .llvm_name = \"x87\",\n        .description = \"Enable X87 float instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xop)] = .{\n        .llvm_name = \"xop\",\n        .description = \"Enable XOP instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .fma4,\n        }),\n    };\n    result[@intFromEnum(Feature.xsave)] = .{\n        .llvm_name = \"xsave\",\n        .description = \"Support xsave instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    result[@intFromEnum(Feature.xsavec)] = .{\n        .llvm_name = \"xsavec\",\n        .description = \"Support xsavec instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .xsave,\n        }),\n    };\n    result[@intFromEnum(Feature.xsaveopt)] = .{\n        .llvm_name = \"xsaveopt\",\n        .description = \"Support xsaveopt instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .xsave,\n        }),\n    };\n    result[@intFromEnum(Feature.xsaves)] = .{\n        .llvm_name = \"xsaves\",\n        .description = \"Support xsaves instructions\",\n        .dependencies = featureSet(&[_]Feature{\n            .xsave,\n        }),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"blk: {\n    const len = @typeInfo(Feature).Enum.fields.len;\n    std.debug.assert(len <= CpuFeature.Set.needed_bit_count);\n    var result: [len]CpuFeature = undefined;\n    result[@intFromEnum(Feature.density)] = .{\n        .llvm_name = \"density\",\n        .description = \"Enable Density instructions\",\n        .dependencies = featureSet(&[_]Feature{}),\n    };\n    const ti = @typeInfo(Feature);\n    for (&result, 0..) |*elem, i| {\n        elem.index = i;\n        elem.name = ti.Enum.fields[i].name;\n    }\n    break :blk result;\n}"},{"code":"coerce_ptr_elem_ty"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"struct_init_field_type"},{"code":"F"},{"code":"F"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.single_threaded)\n    SingleThreadedImpl\nelse if (builtin.os.tag == .windows)\n    WindowsImpl\nelse if (builtin.os.tag.isDarwin())\n    DarwinImpl\nelse if (builtin.os.tag == .linux)\n    LinuxImpl\nelse if (builtin.os.tag == .freebsd)\n    FreebsdImpl\nelse if (builtin.os.tag == .openbsd)\n    OpenbsdImpl\nelse if (builtin.os.tag == .dragonfly)\n    DragonflyImpl\nelse if (builtin.target.isWasm())\n    WasmImpl\nelse if (std.Thread.use_pthreads)\n    PosixImpl\nelse\n    UnsupportedImpl"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.single_threaded)\n    SingleThreadedImpl\nelse\n    FutexImpl"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.mode == .Debug and !builtin.single_threaded)\n    DebugImpl\nelse\n    ReleaseImpl"},{"code":"if (builtin.single_threaded)\n    SingleThreadedImpl\nelse if (builtin.os.tag == .windows)\n    WindowsImpl\nelse if (builtin.os.tag.isDarwin())\n    DarwinImpl\nelse\n    FutexImpl"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.single_threaded)\n    SingleThreadedImpl\nelse if (builtin.os.tag == .windows)\n    WindowsImpl\nelse\n    FutexImpl"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.single_threaded)\n    SingleThreadedRwLock\nelse if (std.Thread.use_pthreads)\n    PthreadRwLock\nelse\n    DefaultRwLock"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (target.os.tag == .windows)\n    WindowsThreadImpl\nelse if (use_pthreads)\n    PosixThreadImpl\nelse if (target.os.tag == .linux)\n    LinuxThreadImpl\nelse if (target.os.tag == .wasi)\n    WasiThreadImpl\nelse\n    UnsupportedImpl"},{"code":"switch (target.os.tag) {\n    .linux => 15,\n    .windows => 31,\n    .macos, .ios, .watchos, .tvos => 63,\n    .netbsd => 31,\n    .freebsd => 15,\n    .openbsd => 23,\n    .dragonfly => 1023,\n    .solaris, .illumos => 31,\n    else => 0,\n}"},{"code":"switch (target.os.tag) {\n    .linux,\n    .dragonfly,\n    .netbsd,\n    .freebsd,\n    .openbsd,\n    .haiku,\n    .wasi,\n    => u32,\n    .macos, .ios, .watchos, .tvos => u64,\n    .windows => os.windows.DWORD,\n    else => usize,\n}"},{"code":"field call"},{"code":"switch (Impl) {\n    WindowsThreadImpl => std.os.windows.DWORD,\n    LinuxThreadImpl => u8,\n    PosixThreadImpl => ?*anyopaque,\n    else => unreachable,\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Key"},{"code":"Key"},{"code":"Key"},{"code":"Key"},{"code":"Key"},{"code":"Key"},{"code":"Key"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"writer"},{"code":"writer"},{"code":"writer"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"func call"},{"code":"K"},{"code":"func call"},{"code":"func call"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"func call"},{"code":"K"},{"code":"func call"},{"code":"func call"},{"code":"V"},{"code":"func call"},{"code":"V"},{"code":"func call"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"store_hash"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"ctx"},{"code":"store_hash"},{"code":"func call"},{"code":"K"},{"code":"V"},{"code":"ctx"},{"code":"store_hash"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"field call"},{"code":"if (store_hash) u32 else void"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"store_hash"},{"code":"func call"},{"code":"if (store_hash) void else Context"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"Context"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"Context"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"I"},{"code":"func call"},{"code":"K"},{"code":"Context"},{"code":"T"},{"code":"I"},{"code":"I"},{"code":"I"},{"code":"typeof_log2_int_type"},{"code":"blk: {\n    var caps: [max_bit_index + 1]u32 = undefined;\n    for (caps[0..max_bit_index], 0..) |*item, i| {\n        item.* = (1 << i) * 3 / 5;\n    }\n    caps[max_bit_index] = max_capacity;\n    break :blk caps;\n}"},{"code":"I"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"func call"},{"code":"K"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"T"},{"code":"switch (builtin.cpu.arch) {\n    // x86_64: Starting from Intel's Sandy Bridge, the spatial prefetcher pulls in pairs of 64-byte cache lines at a time.\n    // - https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf\n    // - https://github.com/facebook/folly/blob/1b5288e6eea6df074758f877c849b6e73bbb9fbb/folly/lang/Align.h#L107\n    //\n    // aarch64: Some big.LITTLE ARM archs have \"big\" cores with 128-byte cache lines:\n    // - https://www.mono-project.com/news/2016/09/12/arm64-icache/\n    // - https://cpufun.substack.com/p/more-m1-fun-hardware-information\n    //\n    // powerpc64: PPC has 128-byte cache lines\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_ppc64x.go#L9\n    .x86_64, .aarch64, .powerpc64 => 128,\n\n    // These platforms reportedly have 32-byte cache lines\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_arm.go#L7\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips.go#L7\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mipsle.go#L7\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_mips64x.go#L9\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_riscv64.go#L7\n    .arm, .mips, .mips64, .riscv64 => 32,\n\n    // This platform reportedly has 256-byte cache lines\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_s390x.go#L7\n    .s390x => 256,\n\n    // Other x86 and WASM platforms have 64-byte cache lines.\n    // The rest of the architectures are assumed to be similar.\n    // - https://github.com/golang/go/blob/dda2991c2ea0c5914714469c4defc2562a907230/src/internal/cpu/cpu_x86.go#L9\n    // - https://github.com/golang/go/blob/3dd58676054223962cd915bb0934d1f9f489d4d2/src/internal/cpu/cpu_wasm.go#L7\n    else => 64,\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"size"},{"code":"size"},{"code":"field call"},{"code":"field call"},{"code":"options"},{"code":"func call"},{"code":"options"},{"code":"func call"},{"code":"size"},{"code":"MaskIntType"},{"code":"field call"},{"code":"size"},{"code":"size"},{"code":"typeof_log2_int_type"},{"code":"options"},{"code":"func call"},{"code":"options"},{"code":"func call"},{"code":"field call"},{"code":"options"},{"code":"func call"},{"code":"options"},{"code":"func call"},{"code":"field call"},{"code":"options"},{"code":"func call"},{"code":"MaskInt"},{"code":"MaskInt"},{"code":"MaskInt"},{"code":"MaskInt"},{"code":"MaskInt"},{"code":"blk: {\n    if (@hasDecl(builtin, \"explicit_subsystem\")) break :blk builtin.explicit_subsystem;\n    switch (builtin.os.tag) {\n        .windows => {\n            if (builtin.is_test) {\n                break :blk std.Target.SubSystem.Console;\n            }\n            if (@hasDecl(root, \"main\") or\n                @hasDecl(root, \"WinMain\") or\n                @hasDecl(root, \"wWinMain\") or\n                @hasDecl(root, \"WinMainCRTStartup\") or\n                @hasDecl(root, \"wWinMainCRTStartup\"))\n            {\n                break :blk std.Target.SubSystem.Windows;\n            } else {\n                break :blk std.Target.SubSystem.Console;\n            }\n        },\n        else => break :blk null,\n    }\n}"},{"code":"field call"},{"code":"switch (builtin.cpu.arch) {\n    .aarch64, .aarch64_be => switch (builtin.os.tag) {\n        .windows => *u8,\n        .ios, .macos, .tvos, .watchos => *u8,\n        else => @compileError(\"disabled due to miscompilations\"), // VaListAarch64,\n    },\n    .arm => switch (builtin.os.tag) {\n        .ios, .macos, .tvos, .watchos => *u8,\n        else => *anyopaque,\n    },\n    .amdgcn => *u8,\n    .avr => *anyopaque,\n    .bpfel, .bpfeb => *anyopaque,\n    .hexagon => if (builtin.target.isMusl()) VaListHexagon else *u8,\n    .mips, .mipsel, .mips64, .mips64el => *anyopaque,\n    .riscv32, .riscv64 => *anyopaque,\n    .powerpc, .powerpcle => switch (builtin.os.tag) {\n        .ios, .macos, .tvos, .watchos, .aix => *u8,\n        else => VaListPowerPc,\n    },\n    .powerpc64, .powerpc64le => *u8,\n    .sparc, .sparcel, .sparc64 => *anyopaque,\n    .spirv32, .spirv64 => *anyopaque,\n    .s390x => VaListS390x,\n    .wasm32, .wasm64 => *anyopaque,\n    .x86 => *u8,\n    .x86_64 => switch (builtin.os.tag) {\n        .windows => @compileError(\"disabled due to miscompilations\"), // *u8,\n        else => VaListX86_64,\n    },\n    else => @compileError(\"VaList not supported for this target yet\"),\n}"},{"code":"if (@hasDecl(root, \"panic\"))\n    root.panic\nelse if (@hasDecl(root, \"os\") and @hasDecl(root.os, \"panic\"))\n    root.os.panic\nelse\n    default_panic"},{"code":"expected"},{"code":"expected"},{"code":"active"},{"code":"field call"},{"code":"switch (builtin.os.tag) {\n    .linux => @import(\"c/linux.zig\"),\n    .windows => @import(\"c/windows.zig\"),\n    .macos, .ios, .tvos, .watchos => @import(\"c/darwin.zig\"),\n    .freebsd, .kfreebsd => @import(\"c/freebsd.zig\"),\n    .netbsd => @import(\"c/netbsd.zig\"),\n    .dragonfly => @import(\"c/dragonfly.zig\"),\n    .openbsd => @import(\"c/openbsd.zig\"),\n    .haiku => @import(\"c/haiku.zig\"),\n    .hermit => @import(\"c/hermit.zig\"),\n    .solaris, .illumos => @import(\"c/solaris.zig\"),\n    .fuchsia => @import(\"c/fuchsia.zig\"),\n    .minix => @import(\"c/minix.zig\"),\n    .emscripten => @import(\"c/emscripten.zig\"),\n    .wasi => @import(\"c/wasi.zig\"),\n    else => struct {},\n}"},{"code":"switch (builtin.os.tag) {\n    .netbsd, .windows => struct {},\n    else => struct {\n        pub const DIR = opaque {};\n        pub extern \"c\" fn opendir(pathname: [*:0]const u8) ?*DIR;\n        pub extern \"c\" fn fdopendir(fd: c_int) ?*DIR;\n        pub extern \"c\" fn rewinddir(dp: *DIR) void;\n        pub extern \"c\" fn closedir(dp: *DIR) c_int;\n        pub extern \"c\" fn telldir(dp: *DIR) c_long;\n        pub extern \"c\" fn seekdir(dp: *DIR, loc: c_long) void;\n\n        pub extern \"c\" fn clock_gettime(clk_id: c_int, tp: *c.timespec) c_int;\n        pub extern \"c\" fn clock_getres(clk_id: c_int, tp: *c.timespec) c_int;\n        pub extern \"c\" fn gettimeofday(noalias tv: ?*c.timeval, noalias tz: ?*c.timezone) c_int;\n        pub extern \"c\" fn nanosleep(rqtp: *const c.timespec, rmtp: ?*c.timespec) c_int;\n\n        pub extern \"c\" fn getrusage(who: c_int, usage: *c.rusage) c_int;\n\n        pub extern \"c\" fn sched_yield() c_int;\n\n        pub extern \"c\" fn sigaction(sig: c_int, noalias act: ?*const c.Sigaction, noalias oact: ?*c.Sigaction) c_int;\n        pub extern \"c\" fn sigprocmask(how: c_int, noalias set: ?*const c.sigset_t, noalias oset: ?*c.sigset_t) c_int;\n        pub extern \"c\" fn sigfillset(set: ?*c.sigset_t) void;\n        pub extern \"c\" fn sigwait(set: ?*c.sigset_t, sig: ?*c_int) c_int;\n\n        pub extern \"c\" fn socket(domain: c_uint, sock_type: c_uint, protocol: c_uint) c_int;\n\n        pub extern \"c\" fn stat(noalias path: [*:0]const u8, noalias buf: *c.Stat) c_int;\n\n        pub extern \"c\" fn alarm(seconds: c_uint) c_uint;\n\n        pub extern \"c\" fn msync(addr: *align(page_size) const anyopaque, len: usize, flags: c_int) c_int;\n    },\n}"},{"code":"switch (builtin.os.tag) {\n    .netbsd, .macos, .ios, .watchos, .tvos, .windows => struct {},\n    else => struct {\n        pub extern \"c\" fn fstat(fd: c.fd_t, buf: *c.Stat) c_int;\n        pub extern \"c\" fn readdir(dp: *c.DIR) ?*c.dirent;\n    },\n}"},{"code":"switch (builtin.os.tag) {\n    .macos, .ios, .watchos, .tvos => struct {},\n    else => struct {\n        pub extern \"c\" fn realpath(noalias file_name: [*:0]const u8, noalias resolved_name: [*]u8) ?[*:0]u8;\n        pub extern \"c\" fn fstatat(dirfd: c.fd_t, path: [*:0]const u8, stat_buf: *c.Stat, flags: u32) c_int;\n    },\n}"},{"code":"if (builtin.target.isAndroid()) struct {\n    // android bionic libc does not implement getcontext,\n    // and std.os.linux.getcontext also cannot be built for\n    // bionic libc currently.\n} else if (builtin.os.tag == .linux and builtin.target.isMusl()) struct {\n    // musl does not implement getcontext\n    pub const getcontext = std.os.linux.getcontext;\n} else struct {\n    pub extern \"c\" fn getcontext(ucp: *std.os.ucontext_t) c_int;\n}"},{"code":"switch (builtin.os.tag) {\n    .linux => std.os.linux.MAP,\n    .emscripten => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n            SHARED_VALIDATE = 0x03,\n        },\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        _6: u2 = 0,\n        GROWSDOWN: bool = false,\n        _9: u2 = 0,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        LOCKED: bool = false,\n        NORESERVE: bool = false,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _: u11 = 0,\n    },\n    .solaris, .illumos => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        RENAME: bool = false,\n        NORESERVE: bool = false,\n        @\"32BIT\": bool = false,\n        ANONYMOUS: bool = false,\n        ALIGN: bool = false,\n        TEXT: bool = false,\n        INITDATA: bool = false,\n        _: u20 = 0,\n    },\n    .netbsd => packed struct(u32) {\n        TYPE: enum(u2) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        REMAPDUP: bool = false,\n        _3: u1 = 0,\n        FIXED: bool = false,\n        RENAME: bool = false,\n        NORESERVE: bool = false,\n        INHERIT: bool = false,\n        _8: u1 = 0,\n        HASSEMAPHORE: bool = false,\n        TRYFIXED: bool = false,\n        WIRED: bool = false,\n        ANONYMOUS: bool = false,\n        STACK: bool = false,\n        _: u18 = 0,\n    },\n    .openbsd => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        _5: u7 = 0,\n        ANONYMOUS: bool = false,\n        _13: u1 = 0,\n        STACK: bool = false,\n        CONCEAL: bool = false,\n        _: u16 = 0,\n    },\n    .haiku => packed struct(u32) {\n        TYPE: enum(u2) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        NORESERVE: bool = false,\n        _: u27 = 0,\n    },\n    .macos, .ios, .tvos, .watchos => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        _5: u1 = 0,\n        NORESERVE: bool = false,\n        _7: u2 = 0,\n        HASSEMAPHORE: bool = false,\n        NOCACHE: bool = false,\n        _11: u1 = 0,\n        ANONYMOUS: bool = false,\n        _: u19 = 0,\n    },\n    .dragonfly => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        RENAME: bool = false,\n        NORESERVE: bool = false,\n        INHERIT: bool = false,\n        NOEXTEND: bool = false,\n        HASSEMAPHORE: bool = false,\n        STACK: bool = false,\n        NOSYNC: bool = false,\n        ANONYMOUS: bool = false,\n        VPAGETABLE: bool = false,\n        _14: u2 = 0,\n        TRYFIXED: bool = false,\n        NOCORE: bool = false,\n        SIZEALIGN: bool = false,\n        _: u13 = 0,\n    },\n    .freebsd => packed struct(u32) {\n        TYPE: enum(u4) {\n            SHARED = 0x01,\n            PRIVATE = 0x02,\n        },\n        FIXED: bool = false,\n        _5: u5 = 0,\n        STACK: bool = false,\n        NOSYNC: bool = false,\n        ANONYMOUS: bool = false,\n        GUARD: bool = false,\n        EXCL: bool = false,\n        _15: u2 = 0,\n        NOCORE: bool = false,\n        PREFAULT_READ: bool = false,\n        @\"32BIT\": bool = false,\n        _: u12 = 0,\n    },\n    else => @compileError(\"target libc does not have MAP\"),\n}"},{"code":"field call"},{"code":"if (builtin.os.tag == .wasi) std.os.wasi.whence_t else c_int"},{"code":"if (builtin.os.tag == .windows) c_int else isize"},{"code":"if (builtin.os.tag == .windows) c_int else isize"},{"code":"if (builtin.abi == .msvc)\n    f64\nelse if (builtin.target.isDarwin())\n    c_longdouble\nelse\n    extern struct {\n        a: c_longlong,\n        b: c_longdouble,\n    }"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"WriterType"},{"code":"WriterType"},{"code":"WriterType"},{"code":"writer"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"writer"},{"code":"func call"},{"code":"field call"},{"code":"WriterType"},{"code":"WriterType"},{"code":"WriterType"},{"code":"WriterType"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"typeof_log2_int_type"},{"code":"func call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"reader"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"writer"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"num_bits"},{"code":"typeof_log2_int_type"},{"code":"num_bits"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"reader"},{"code":"func call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"func call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"reader"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"writer"},{"code":"func call"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"coerce_ptr_elem_ty"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"U"},{"code":"U"},{"code":"field call"},{"code":"U"},{"code":"U"},{"code":"Reader"},{"code":"field call"},{"code":"reader"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"source"},{"code":"max_accuracy_log"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"source"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"source"},{"code":"typeof_log2_int_type"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"if (options.verify_checksum) ?u32 else void"},{"code":"reader"},{"code":"options"},{"code":"func call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"HasherType"},{"code":"reader"},{"code":"hasher"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"HasherType"},{"code":"writer"},{"code":"hasher"},{"code":"func call"},{"code":"V"},{"code":"kvs_list"},{"code":"func call"},{"code":"\"samelen\""},{"code":"V"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"tag_bits"},{"code":"tag_bits"},{"code":"tag_bits"},{"code":"tag_bits"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"Aes"},{"code":"func call"},{"code":"func call"},{"code":"Aes"},{"code":"Aes"},{"code":"field call"},{"code":"Aes"},{"code":"field call"},{"code":"Aes"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if ((builtin.cpu.arch == .x86_64 and has_aesni) or (builtin.cpu.arch == .aarch64 and has_armaes)) 4 else 0"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"degree"},{"code":"dm"},{"code":"field call"},{"code":"out_len"},{"code":"func call"},{"code":"func call"},{"code":"if (builtin.cpu.arch == .x86_64 and builtin.zig_backend != .stage2_x86_64) SalsaVecImpl else SalsaNonVecImpl"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Hash"},{"code":"Hash"},{"code":"Hash"},{"code":"c_rounds"},{"code":"d_rounds"},{"code":"func call"},{"code":"c_rounds"},{"code":"d_rounds"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"c_rounds"},{"code":"d_rounds"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"func call"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"block_comptime"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.cpu.arch == .x86_64 and builtin.zig_backend != .stage2_c and builtin.zig_backend != .stage2_x86_64 and has_aesni and has_avx) impl: {\n    break :impl @import(\"aes/aesni.zig\");\n} else if (builtin.cpu.arch == .aarch64 and builtin.zig_backend != .stage2_c and has_armaes)\nimpl: {\n    break :impl @import(\"aes/armcrypto.zig\");\n} else impl: {\n    break :impl @import(\"aes/soft.zig\");\n}"},{"code":"field call"},{"code":"f"},{"code":"f"},{"code":"field call"},{"code":"rc: {\n            const RC64 = [_]u64{\n                0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,\n                0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,\n                0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,\n                0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,\n                0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,\n                0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008,\n            };\n            var rc: [max_rounds]T = undefined;\n            for (&rc, RC64[0..max_rounds]) |*t, c| t.* = @as(T, @truncate(c));\n            break :rc rc;\n        }"},{"code":"f"},{"code":"field call"},{"code":"block_comptime"},{"code":"f"},{"code":"field call"},{"code":"capacity"},{"code":"f"},{"code":"func call"},{"code":"field call"},{"code":"BlockCipher"},{"code":"BlockCipher"},{"code":"switch (builtin.mode) {\n    .ReleaseSafe, .ReleaseFast => .Inline,\n    .Debug, .ReleaseSmall => .Unspecified,\n}"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"s: {\n    var s: [32]u8 = undefined;\n    mem.writeInt(u256, &s, field_order, .little);\n    break :s s;\n}"},{"code":"typeof_log2_int_type"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"p"},{"code":"field call"},{"code":"p"},{"code":"p"},{"code":"field call"},{"code":"p"},{"code":"func call"},{"code":"p"},{"code":"func call"},{"code":"p"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"a"},{"code":"a"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"a"},{"code":"a"},{"code":"a"},{"code":"a"},{"code":"a"},{"code":"a"},{"code":"a"},{"code":"struct_init_field_type"},{"code":"d"},{"code":"func call"},{"code":"d"},{"code":"func call"},{"code":"K"},{"code":"d"},{"code":"func call"},{"code":"d"},{"code":"func call"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"func call"},{"code":"len"},{"code":"len"},{"code":"len"},{"code":"len"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"n"},{"code":"count"},{"code":"pc: {\n        @setEvalBranchQuota(10000);\n        break :pc precompute(Edwards25519.basePoint, 15);\n    }"},{"code":"count"},{"code":"count"},{"code":"n"},{"code":"params"},{"code":"params"},{"code":"params"},{"code":"params"},{"code":"params"},{"code":"field call"},{"code":"one: {\n            var fe: Fe = undefined;\n            fiat.setOne(&fe.limbs);\n            break :one fe;\n        }"},{"code":"params"},{"code":"field call"},{"code":"T"},{"code":"params"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"bits"},{"code":"Fe.fromInt(48439561293906451759052585252797914202762949526041747995844080717082404635286) catch unreachable"},{"code":"Fe.fromInt(36134250956749795798585127919587881956611106672985015071877198253568414405109) catch unreachable"},{"code":"Fe.fromInt(41058363725152142129326129780047268409114441015993725554835256314039467401291) catch unreachable"},{"code":"n"},{"code":"count"},{"code":"pc: {\n        @setEvalBranchQuota(50000);\n        break :pc precompute(P256.basePoint, 15);\n    }"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"bits"},{"code":"Fe.fromInt(26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087) catch unreachable"},{"code":"Fe.fromInt(8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871) catch unreachable"},{"code":"Fe.fromInt(27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575) catch unreachable"},{"code":"n"},{"code":"count"},{"code":"pc: {\n        @setEvalBranchQuota(50000);\n        break :pc precompute(P384.basePoint, 15);\n    }"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"bits"},{"code":"Fe.fromInt(55066263022277343669578718895168534326250603453777594175500187360389116729240) catch unreachable"},{"code":"Fe.fromInt(32670510020758816978083085130507043184471273380659243275938904335757337482424) catch unreachable"},{"code":"Fe.fromInt(7) catch unreachable"},{"code":"s: {\n            var buf: [32]u8 = undefined;\n            mem.writeInt(u256, &buf, Endormorphism.lambda, .little);\n            break :s buf;\n        }"},{"code":"n"},{"code":"count"},{"code":"pc: {\n        @setEvalBranchQuota(50000);\n        break :pc precompute(Secp256k1.basePoint, 15);\n    }"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"out_bits"},{"code":"out_bits"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"out_bits"},{"code":"out_bits"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"if (builtin.cpu.arch == .x86_64 and builtin.zig_backend != .stage2_x86_64)\n    CompressVectorized.compress\nelse\n    CompressGeneric.compress"},{"code":"count"},{"code":"count"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"params"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"params"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"delim"},{"code":"func call"},{"code":"delim"},{"code":"func call"},{"code":"output_bits"},{"code":"f"},{"code":"output_bits"},{"code":"delim"},{"code":"rounds"},{"code":"func call"},{"code":"field call"},{"code":"f"},{"code":"output_bits"},{"code":"delim"},{"code":"rounds"},{"code":"func call"},{"code":"security_level"},{"code":"func call"},{"code":"security_level"},{"code":"delim orelse 0x1f"},{"code":"func call"},{"code":"security_level"},{"code":"security_level"},{"code":"delim"},{"code":"rounds"},{"code":"func call"},{"code":"field call"},{"code":"security_level"},{"code":"delim"},{"code":"rounds"},{"code":"func call"},{"code":"security_level"},{"code":"delim"},{"code":"rounds"},{"code":"func call"},{"code":"H1"},{"code":"H1"},{"code":"H1"},{"code":"H2"},{"code":"H1"},{"code":"H2"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Hmac"},{"code":"Hmac"},{"code":"func call"},{"code":"func call"},{"code":"if (builtin.mode != .ReleaseSmall) 16 else 2"},{"code":"if (builtin.cpu.arch == .x86) .karatsuba else .schoolbook"},{"code":"switch (builtin.cpu.arch) {\n            .wasm32, .wasm64 => clmulSoft128_64,\n            else => if (std.simd.suggestVectorLength(u128) != null) clmulSoft128 else clmulSoft128_64,\n        }"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.cpu.arch == .x86_64 and builtin.zig_backend != .stage2_c and has_pclmul and has_avx) impl: {\n            break :impl clmulPclmul;\n        } else if (builtin.cpu.arch == .aarch64 and builtin.zig_backend != .stage2_c and has_armaes) impl: {\n            break :impl clmulPmull;\n        } else impl: {\n            break :impl clmulSoft;\n        }"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"max_len"},{"code":"max_len"},{"code":"field call"},{"code":"max_len"},{"code":"HashResult"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"crypt_max_hash_len"},{"code":"func call"},{"code":"func call"},{"code":"max_len"},{"code":"max_len"},{"code":"field call"},{"code":"max_len"},{"code":"len"},{"code":"len"},{"code":"field call"},{"code":"T"},{"code":"map"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"count"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Curve"},{"code":"Hash"},{"code":"Hash"},{"code":"Curve"},{"code":"Curve"},{"code":"unreduced_len"},{"code":"Curve"},{"code":"Hash"},{"code":"Curve"},{"code":"Curve"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"math.divCeil(usize, max_bits, t_bits) catch unreachable"},{"code":"math.divCeil(usize, max_bits, 8) catch unreachable"},{"code":"struct_init_field_type"},{"code":"T"},{"code":"T"},{"code":"bits"},{"code":"func call"},{"code":"bits"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"bits"},{"code":"func call"},{"code":"max_bits"},{"code":"func call"},{"code":"T"},{"code":"if (std.options.side_channels_mitigations == .none) ct_unprotected else ct_protected"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"switch (builtin.os.tag) {\n    .dragonfly,\n    .freebsd,\n    .ios,\n    .kfreebsd,\n    .linux,\n    .macos,\n    .netbsd,\n    .openbsd,\n    .solaris,\n    .illumos,\n    .tvos,\n    .watchos,\n    .haiku,\n    => true,\n\n    else => false,\n}"},{"code":"builtin.os.isAtLeast(.linux, .{\n    .major = 4,\n    .minor = 14,\n    .patch = 0,\n}) orelse true"},{"code":"field call"},{"code":"coerce_ptr_elem_ty"},{"code":"Stream"},{"code":"Stream"},{"code":"stream"},{"code":"func call"},{"code":"field call"},{"code":"x"},{"code":"scheme"},{"code":"switch (scheme) {\n        .ecdsa_secp256r1_sha256 => crypto.sign.ecdsa.EcdsaP256Sha256,\n        .ecdsa_secp384r1_sha384 => crypto.sign.ecdsa.EcdsaP384Sha384,\n        else => @compileError(\"bad scheme\"),\n    }"},{"code":"scheme"},{"code":"switch (scheme) {\n        .rsa_pss_rsae_sha256 => crypto.hash.sha2.Sha256,\n        .rsa_pss_rsae_sha384 => crypto.hash.sha2.Sha384,\n        .rsa_pss_rsae_sha512 => crypto.hash.sha2.Sha512,\n        else => @compileError(\"bad scheme\"),\n    }"},{"code":"scheme"},{"code":"switch (scheme) {\n        .ed25519 => crypto.sign.Ed25519,\n        else => @compileError(\"bad scheme\"),\n    }"},{"code":"if (crypto.core.aes.has_hardware_support)\n    enum_array(tls.CipherSuite, &.{\n        .AEGIS_128L_SHA256,\n        .AEGIS_256_SHA512,\n        .AES_128_GCM_SHA256,\n        .AES_256_GCM_SHA384,\n        .CHACHA20_POLY1305_SHA256,\n    })\nelse\n    enum_array(tls.CipherSuite, &.{\n        .CHACHA20_POLY1305_SHA256,\n        .AEGIS_128L_SHA256,\n        .AEGIS_256_SHA512,\n        .AES_128_GCM_SHA256,\n        .AES_256_GCM_SHA384,\n    })"},{"code":"typeof_log2_int_type"},{"code":"AeadType"},{"code":"HashType"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"AeadType"},{"code":"HashType"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Hkdf"},{"code":"len"},{"code":"Hash"},{"code":"Hmac"},{"code":"Hmac"},{"code":"bytes"},{"code":"bytes"},{"code":"E"},{"code":"E"},{"code":"tags"},{"code":"T"},{"code":"len"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"algorithm"},{"code":"switch (algorithm) {\n            .sha1WithRSAEncryption => crypto.hash.Sha1,\n            .ecdsa_with_SHA224, .sha224WithRSAEncryption => crypto.hash.sha2.Sha224,\n            .ecdsa_with_SHA256, .sha256WithRSAEncryption => crypto.hash.sha2.Sha256,\n            .ecdsa_with_SHA384, .sha384WithRSAEncryption => crypto.hash.sha2.Sha384,\n            .ecdsa_with_SHA512, .sha512WithRSAEncryption, .curveEd25519 => crypto.hash.sha2.Sha512,\n            .md2WithRSAEncryption => @compileError(\"unimplemented\"),\n            .md5WithRSAEncryption => crypto.hash.Md5,\n        }"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"curve"},{"code":"switch (curve) {\n            .X9_62_prime256v1 => crypto.ecc.P256,\n            .secp384r1 => crypto.ecc.P384,\n            .secp521r1 => @compileError(\"unimplemented\"),\n        }"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"array_init_elem_type"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"E"},{"code":"field call"},{"code":"field call"},{"code":"modulus_len"},{"code":"modulus_len"},{"code":"Hash"},{"code":"modulus_len"},{"code":"modulus_len"},{"code":"field call"},{"code":"switch (builtin.mode) {\n    .Debug, .ReleaseSafe => true,\n    .ReleaseFast, .ReleaseSmall => false,\n}"},{"code":"switch (builtin.cpu.arch) {\n    // Observed to go into an infinite loop.\n    // TODO: Make this work.\n    .mips,\n    .mipsel,\n    => false,\n\n    // `@returnAddress()` in LLVM 10 gives\n    // \"Non-Emscripten WebAssembly hasn't implemented __builtin_return_address\".\n    .wasm32,\n    .wasm64,\n    => builtin.os.tag == .emscripten,\n\n    // `@returnAddress()` is unsupported in LLVM 13.\n    .bpfel,\n    .bpfeb,\n    => false,\n\n    else => true,\n}"},{"code":"switch (builtin.cpu.arch) {\n    .mips, .mipsel, .mips64, .mips64el, .riscv64 => false,\n    else => true,\n}"},{"code":"blk: {\n    if (native_os == .windows) {\n        break :blk std.os.windows.CONTEXT;\n    } else if (have_ucontext) {\n        break :blk os.ucontext_t;\n    } else {\n        break :blk void;\n    }\n}"},{"code":"switch (builtin.cpu.arch) {\n    .x86,\n    .x86_64,\n    => true,\n    else => builtin.link_libc and !builtin.target.isMusl(),\n}"},{"code":"field call"},{"code":"field call"},{"code":"if (have_ucontext)\n    @typeInfo(@typeInfo(@TypeOf(StackIterator.next_unwind)).Fn.return_type.?).ErrorUnion.error_set\nelse\n    void"},{"code":"if (native_arch.isRISCV())\n        // On RISC-V the frame pointer points to the top of the saved register\n        // area, on pretty much every other architecture it points to the stack\n        // slot where the previous frame pointer is saved.\n        2 * @sizeOf(usize)\n    else if (native_arch.isSPARC())\n        // On SPARC the previous frame pointer is stored at 14 slots past %fp+BIAS.\n        14 * @sizeOf(usize)\n    else\n        0"},{"code":"if (native_arch.isSPARC())\n        // On SPARC frame pointers are biased by a constant.\n        2047\n    else\n        0"},{"code":"if (native_arch == .powerpc64le)\n        2 * @sizeOf(usize)\n    else\n        @sizeOf(usize)"},{"code":"if (have_ucontext) ?struct {\n        debug_info: *DebugInfo,\n        dwarf_context: DW.UnwindContext,\n        last_error: ?UnwindError = null,\n        failed: bool = false,\n    } else void"},{"code":"if (have_ucontext) null else {}"},{"code":"field call"},{"code":"if (native_os == .windows) std.ArrayListUnmanaged(WindowsModuleInfo) else void"},{"code":"switch (native_os) {\n    .macos, .ios, .watchos, .tvos => struct {\n        base_address: usize,\n        vmaddr_slide: usize,\n        mapped_memory: []align(mem.page_size) const u8,\n        symbols: []const MachoSymbol,\n        strings: [:0]const u8,\n        ofiles: OFileTable,\n\n        // Backed by the in-memory sections mapped by the loader\n        unwind_info: ?[]const u8 = null,\n        eh_frame: ?[]const u8 = null,\n\n        const OFileTable = std.StringHashMap(OFileInfo);\n        const OFileInfo = struct {\n            di: DW.DwarfInfo,\n            addr_table: std.StringHashMap(u64),\n        };\n\n        pub fn deinit(self: *@This(), allocator: mem.Allocator) void {\n            var it = self.ofiles.iterator();\n            while (it.next()) |entry| {\n                const ofile = entry.value_ptr;\n                ofile.di.deinit(allocator);\n                ofile.addr_table.deinit();\n            }\n            self.ofiles.deinit();\n            allocator.free(self.symbols);\n            os.munmap(self.mapped_memory);\n        }\n\n        fn loadOFile(self: *@This(), allocator: mem.Allocator, o_file_path: []const u8) !*OFileInfo {\n            const o_file = try fs.cwd().openFile(o_file_path, .{});\n            const mapped_mem = try mapWholeFile(o_file);\n\n            const hdr: *const macho.mach_header_64 = @ptrCast(@alignCast(mapped_mem.ptr));\n            if (hdr.magic != std.macho.MH_MAGIC_64)\n                return error.InvalidDebugInfo;\n\n            var segcmd: ?macho.LoadCommandIterator.LoadCommand = null;\n            var symtabcmd: ?macho.symtab_command = null;\n            var it = macho.LoadCommandIterator{\n                .ncmds = hdr.ncmds,\n                .buffer = mapped_mem[@sizeOf(macho.mach_header_64)..][0..hdr.sizeofcmds],\n            };\n            while (it.next()) |cmd| switch (cmd.cmd()) {\n                .SEGMENT_64 => segcmd = cmd,\n                .SYMTAB => symtabcmd = cmd.cast(macho.symtab_command).?,\n                else => {},\n            };\n\n            if (segcmd == null or symtabcmd == null) return error.MissingDebugInfo;\n\n            // Parse symbols\n            const strtab = @as(\n                [*]const u8,\n                @ptrCast(&mapped_mem[symtabcmd.?.stroff]),\n            )[0 .. symtabcmd.?.strsize - 1 :0];\n            const symtab = @as(\n                [*]const macho.nlist_64,\n                @ptrCast(@alignCast(&mapped_mem[symtabcmd.?.symoff])),\n            )[0..symtabcmd.?.nsyms];\n\n            // TODO handle tentative (common) symbols\n            var addr_table = std.StringHashMap(u64).init(allocator);\n            try addr_table.ensureTotalCapacity(@as(u32, @intCast(symtab.len)));\n            for (symtab) |sym| {\n                if (sym.n_strx == 0) continue;\n                if (sym.undf() or sym.tentative() or sym.abs()) continue;\n                const sym_name = mem.sliceTo(strtab[sym.n_strx..], 0);\n                // TODO is it possible to have a symbol collision?\n                addr_table.putAssumeCapacityNoClobber(sym_name, sym.n_value);\n            }\n\n            var sections: DW.DwarfInfo.SectionArray = DW.DwarfInfo.null_section_array;\n            if (self.eh_frame) |eh_frame| sections[@intFromEnum(DW.DwarfSection.eh_frame)] = .{\n                .data = eh_frame,\n                .owned = false,\n            };\n\n            for (segcmd.?.getSections()) |sect| {\n                if (!std.mem.eql(u8, \"__DWARF\", sect.segName())) continue;\n\n                var section_index: ?usize = null;\n                inline for (@typeInfo(DW.DwarfSection).Enum.fields, 0..) |section, i| {\n                    if (mem.eql(u8, \"__\" ++ section.name, sect.sectName())) section_index = i;\n                }\n                if (section_index == null) continue;\n\n                const section_bytes = try chopSlice(mapped_mem, sect.offset, sect.size);\n                sections[section_index.?] = .{\n                    .data = section_bytes,\n                    .virtual_address = sect.addr,\n                    .owned = false,\n                };\n            }\n\n            const missing_debug_info =\n                sections[@intFromEnum(DW.DwarfSection.debug_info)] == null or\n                sections[@intFromEnum(DW.DwarfSection.debug_abbrev)] == null or\n                sections[@intFromEnum(DW.DwarfSection.debug_str)] == null or\n                sections[@intFromEnum(DW.DwarfSection.debug_line)] == null;\n            if (missing_debug_info) return error.MissingDebugInfo;\n\n            var di = DW.DwarfInfo{\n                .endian = .little,\n                .sections = sections,\n                .is_macho = true,\n            };\n\n            try DW.openDwarfDebugInfo(&di, allocator);\n            const info = OFileInfo{\n                .di = di,\n                .addr_table = addr_table,\n            };\n\n            // Add the debug info to the cache\n            const result = try self.ofiles.getOrPut(o_file_path);\n            assert(!result.found_existing);\n            result.value_ptr.* = info;\n\n            return result.value_ptr;\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), allocator: mem.Allocator, address: usize) !SymbolInfo {\n            nosuspend {\n                const result = try self.getOFileInfoForAddress(allocator, address);\n                if (result.symbol == null) return .{};\n\n                // Take the symbol name from the N_FUN STAB entry, we're going to\n                // use it if we fail to find the DWARF infos\n                const stab_symbol = mem.sliceTo(self.strings[result.symbol.?.strx..], 0);\n                if (result.o_file_info == null) return .{ .symbol_name = stab_symbol };\n\n                // Translate again the address, this time into an address inside the\n                // .o file\n                const relocated_address_o = result.o_file_info.?.addr_table.get(stab_symbol) orelse return .{\n                    .symbol_name = \"???\",\n                };\n\n                const addr_off = result.relocated_address - result.symbol.?.addr;\n                const o_file_di = &result.o_file_info.?.di;\n                if (o_file_di.findCompileUnit(relocated_address_o)) |compile_unit| {\n                    return SymbolInfo{\n                        .symbol_name = o_file_di.getSymbolName(relocated_address_o) orelse \"???\",\n                        .compile_unit_name = compile_unit.die.getAttrString(\n                            o_file_di,\n                            DW.AT.name,\n                            o_file_di.section(.debug_str),\n                            compile_unit.*,\n                        ) catch |err| switch (err) {\n                            error.MissingDebugInfo, error.InvalidDebugInfo => \"???\",\n                        },\n                        .line_info = o_file_di.getLineNumberInfo(\n                            allocator,\n                            compile_unit.*,\n                            relocated_address_o + addr_off,\n                        ) catch |err| switch (err) {\n                            error.MissingDebugInfo, error.InvalidDebugInfo => null,\n                            else => return err,\n                        },\n                    };\n                } else |err| switch (err) {\n                    error.MissingDebugInfo, error.InvalidDebugInfo => {\n                        return SymbolInfo{ .symbol_name = stab_symbol };\n                    },\n                    else => return err,\n                }\n            }\n        }\n\n        pub fn getOFileInfoForAddress(self: *@This(), allocator: mem.Allocator, address: usize) !struct {\n            relocated_address: usize,\n            symbol: ?*const MachoSymbol = null,\n            o_file_info: ?*OFileInfo = null,\n        } {\n            nosuspend {\n                // Translate the VA into an address into this object\n                const relocated_address = address - self.vmaddr_slide;\n\n                // Find the .o file where this symbol is defined\n                const symbol = machoSearchSymbols(self.symbols, relocated_address) orelse return .{\n                    .relocated_address = relocated_address,\n                };\n\n                // Check if its debug infos are already in the cache\n                const o_file_path = mem.sliceTo(self.strings[symbol.ofile..], 0);\n                const o_file_info = self.ofiles.getPtr(o_file_path) orelse\n                    (self.loadOFile(allocator, o_file_path) catch |err| switch (err) {\n                    error.FileNotFound,\n                    error.MissingDebugInfo,\n                    error.InvalidDebugInfo,\n                    => return .{\n                        .relocated_address = relocated_address,\n                        .symbol = symbol,\n                    },\n                    else => return err,\n                });\n\n                return .{\n                    .relocated_address = relocated_address,\n                    .symbol = symbol,\n                    .o_file_info = o_file_info,\n                };\n            }\n        }\n\n        pub fn getDwarfInfoForAddress(self: *@This(), allocator: mem.Allocator, address: usize) !?*const DW.DwarfInfo {\n            return if ((try self.getOFileInfoForAddress(allocator, address)).o_file_info) |o_file_info| &o_file_info.di else null;\n        }\n    },\n    .uefi, .windows => struct {\n        base_address: usize,\n        pdb: ?pdb.Pdb = null,\n        dwarf: ?DW.DwarfInfo = null,\n        coff_image_base: u64,\n\n        /// Only used if pdb is non-null\n        coff_section_headers: []coff.SectionHeader,\n\n        pub fn deinit(self: *@This(), allocator: mem.Allocator) void {\n            if (self.dwarf) |*dwarf| {\n                dwarf.deinit(allocator);\n            }\n\n            if (self.pdb) |*p| {\n                p.deinit();\n                allocator.free(self.coff_section_headers);\n            }\n        }\n\n        fn getSymbolFromPdb(self: *@This(), relocated_address: usize) !?SymbolInfo {\n            var coff_section: *align(1) const coff.SectionHeader = undefined;\n            const mod_index = for (self.pdb.?.sect_contribs) |sect_contrib| {\n                if (sect_contrib.Section > self.coff_section_headers.len) continue;\n                // Remember that SectionContribEntry.Section is 1-based.\n                coff_section = &self.coff_section_headers[sect_contrib.Section - 1];\n\n                const vaddr_start = coff_section.virtual_address + sect_contrib.Offset;\n                const vaddr_end = vaddr_start + sect_contrib.Size;\n                if (relocated_address >= vaddr_start and relocated_address < vaddr_end) {\n                    break sect_contrib.ModuleIndex;\n                }\n            } else {\n                // we have no information to add to the address\n                return null;\n            };\n\n            const module = (try self.pdb.?.getModule(mod_index)) orelse\n                return error.InvalidDebugInfo;\n            const obj_basename = fs.path.basename(module.obj_file_name);\n\n            const symbol_name = self.pdb.?.getSymbolName(\n                module,\n                relocated_address - coff_section.virtual_address,\n            ) orelse \"???\";\n            const opt_line_info = try self.pdb.?.getLineNumberInfo(\n                module,\n                relocated_address - coff_section.virtual_address,\n            );\n\n            return SymbolInfo{\n                .symbol_name = symbol_name,\n                .compile_unit_name = obj_basename,\n                .line_info = opt_line_info,\n            };\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), allocator: mem.Allocator, address: usize) !SymbolInfo {\n            // Translate the VA into an address into this object\n            const relocated_address = address - self.base_address;\n\n            if (self.pdb != null) {\n                if (try self.getSymbolFromPdb(relocated_address)) |symbol| return symbol;\n            }\n\n            if (self.dwarf) |*dwarf| {\n                const dwarf_address = relocated_address + self.coff_image_base;\n                return getSymbolFromDwarf(allocator, dwarf_address, dwarf);\n            }\n\n            return SymbolInfo{};\n        }\n\n        pub fn getDwarfInfoForAddress(self: *@This(), allocator: mem.Allocator, address: usize) !?*const DW.DwarfInfo {\n            _ = allocator;\n            _ = address;\n\n            return switch (self.debug_data) {\n                .dwarf => |*dwarf| dwarf,\n                else => null,\n            };\n        }\n    },\n    .linux, .netbsd, .freebsd, .dragonfly, .openbsd, .haiku, .solaris, .illumos => struct {\n        base_address: usize,\n        dwarf: DW.DwarfInfo,\n        mapped_memory: []align(mem.page_size) const u8,\n        external_mapped_memory: ?[]align(mem.page_size) const u8,\n\n        pub fn deinit(self: *@This(), allocator: mem.Allocator) void {\n            self.dwarf.deinit(allocator);\n            os.munmap(self.mapped_memory);\n            if (self.external_mapped_memory) |m| os.munmap(m);\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), allocator: mem.Allocator, address: usize) !SymbolInfo {\n            // Translate the VA into an address into this object\n            const relocated_address = address - self.base_address;\n            return getSymbolFromDwarf(allocator, relocated_address, &self.dwarf);\n        }\n\n        pub fn getDwarfInfoForAddress(self: *@This(), allocator: mem.Allocator, address: usize) !?*const DW.DwarfInfo {\n            _ = allocator;\n            _ = address;\n            return &self.dwarf;\n        }\n    },\n    .wasi => struct {\n        pub fn deinit(self: *@This(), allocator: mem.Allocator) void {\n            _ = self;\n            _ = allocator;\n        }\n\n        pub fn getSymbolAtAddress(self: *@This(), allocator: mem.Allocator, address: usize) !SymbolInfo {\n            _ = self;\n            _ = allocator;\n            _ = address;\n            return SymbolInfo{};\n        }\n\n        pub fn getDwarfInfoForAddress(self: *@This(), allocator: mem.Allocator, address: usize) !?*const DW.DwarfInfo {\n            _ = self;\n            _ = allocator;\n            _ = address;\n            return null;\n        }\n    },\n    else => DW.DwarfInfo,\n}"},{"code":"switch (native_os) {\n    .linux,\n    .macos,\n    .netbsd,\n    .solaris,\n    .illumos,\n    .windows,\n    => true,\n\n    .freebsd, .openbsd => @hasDecl(os.system, \"ucontext_t\"),\n    else => false,\n}"},{"code":"func call"},{"code":"if (enabled) size else 0"},{"code":"if (enabled) usize else u0"},{"code":"is_enabled"},{"code":"if (enabled) addNoInline else addNoOp"},{"code":"stack_frame_count"},{"code":"T"},{"code":"T"},{"code":"l"},{"code":"l"},{"code":"field call"},{"code":"l"},{"code":"l"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"struct_init_field_type"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"T"},{"code":"thread_context_ptr"},{"code":"T"},{"code":"func call"},{"code":"if (info.Pointer.is_const) return []const u8 else []u8"},{"code":"thread_context_ptr"},{"code":"func call"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"options"},{"code":"pub fn asIntegral(self: Value) !addr_type {\n                return switch (self) {\n                    .generic => |v| v,\n\n                    // TODO: For these two prongs, look up the type and assert it's integral?\n                    .regval_type => |regval_type| regval_type.value,\n                    .const_type => |const_type| {\n                        const value: u64 = switch (const_type.value_bytes.len) {\n                            1 => mem.readInt(u8, const_type.value_bytes[0..1], native_endian),\n                            2 => mem.readInt(u16, const_type.value_bytes[0..2], native_endian),\n                            4 => mem.readInt(u32, const_type.value_bytes[0..4], native_endian),\n                            8 => mem.readInt(u64, const_type.value_bytes[0..8], native_endian),\n                            else => return error.InvalidIntegralTypeSize,\n                        };\n\n                        return std.math.cast(addr_type, value) orelse error.TruncatedIntegralType;\n                    },\n                };\n            }"},{"code":"options"},{"code":"type_size: u8"},{"code":"options"},{"code":"u8"},{"code":"options"},{"code":"Value"},{"code":"options"},{"code":"const_type"},{"code":"options"},{"code":"std.mem.Allocator"},{"code":"options"},{"code":"u64"},{"code":"options"},{"code":"u64"},{"code":"options"},{"code":"mem.readInt"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"options"},{"code":"options"},{"code":"T"},{"code":"if (is_64) u64 else u32"},{"code":"field call"},{"code":"field call"},{"code":"U"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"parse_source"},{"code":"func call"},{"code":"parse_source"},{"code":"func call"},{"code":"ParseSource"},{"code":"ParseSource"},{"code":"int_64"},{"code":"Int64"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_auxv_t,\n    8 => Elf64_auxv_t,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Ehdr,\n    8 => Elf64_Ehdr,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Phdr,\n    8 => Elf64_Phdr,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Dyn,\n    8 => Elf64_Dyn,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Rel,\n    8 => Elf64_Rel,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Rela,\n    8 => Elf64_Rela,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Shdr,\n    8 => Elf64_Shdr,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Chdr,\n    8 => Elf64_Chdr,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Sym,\n    8 => Elf64_Sym,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Verdef,\n    8 => Elf64_Verdef,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Verdaux,\n    8 => Elf64_Verdaux,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Addr,\n    8 => Elf64_Addr,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"switch (@sizeOf(usize)) {\n    4 => Elf32_Half,\n    8 => Elf64_Half,\n    else => @compileError(\"expected pointer size of 32 or 64\"),\n}"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Data"},{"code":"struct_init_field_type"},{"code":"alloc_mut"},{"code":"struct_init_field_type"},{"code":"E"},{"code":"E"},{"code":"E"},{"code":"E"},{"code":"Data"},{"code":"func call"},{"code":"E"},{"code":"max_unused_slots"},{"code":"func call"},{"code":"Data"},{"code":"Data"},{"code":"E"},{"code":"Data"},{"code":"default"},{"code":"func call"},{"code":"E"},{"code":"max_unused_slots"},{"code":"func call"},{"code":"Data"},{"code":"E"},{"code":"E"},{"code":"func call"},{"code":"E"},{"code":"func call"},{"code":"Self"},{"code":"func call"},{"code":"E"},{"code":"func call"},{"code":"V"},{"code":"E"},{"code":"V"},{"code":"V"},{"code":"func call"},{"code":"Self"},{"code":"V"},{"code":"Self"},{"code":"E"},{"code":"V"},{"code":"V"},{"code":"func call"},{"code":"Self"},{"code":"V"},{"code":"E"},{"code":"V"},{"code":"default"},{"code":"func call"},{"code":"Self"},{"code":"func call"},{"code":"E"},{"code":"func call"},{"code":"E"},{"code":"CountSize"},{"code":"func call"},{"code":"CountSize"},{"code":"E"},{"code":"E"},{"code":"E"},{"code":"CountSize"},{"code":"E"},{"code":"CountSize"},{"code":"E"},{"code":"CountSize"},{"code":"E"},{"code":"CountSize"},{"code":"E"},{"code":"CountSize"},{"code":"E"},{"code":"CountSize"},{"code":"func call"},{"code":"E"},{"code":"func call"},{"code":"V"},{"code":"E"},{"code":"V"},{"code":"V"},{"code":"func call"},{"code":"Self"},{"code":"V"},{"code":"E"},{"code":"V"},{"code":"default"},{"code":"func call"},{"code":"Self"},{"code":"func call"},{"code":"Ext orelse NoExtension"},{"code":"func call"},{"code":"I"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Ext orelse NoExtension"},{"code":"func call"},{"code":"I"},{"code":"V"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Ext orelse NoExtension"},{"code":"func call"},{"code":"I"},{"code":"V"},{"code":"E"},{"code":"alloc_inferred_mut"},{"code":"E"},{"code":"E"},{"code":"field call"},{"code":"field call"},{"code":"if (buffer_type == .Static) *Self else Self"},{"code":"buffer_type"},{"code":"switch (buffer_type) {\n            .Static => initStatic,\n            .Slice => initSlice,\n            .Dynamic => initDynamic,\n        }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"if (buffer_type == .Dynamic) Allocator else void"},{"code":"if (buffer_type == .Static) [buffer_type.Static]T else []T"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"writer"},{"code":"writer"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"writer"},{"code":"block_comptime"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"FloatT"},{"code":"T"},{"code":"func call"},{"code":"MantissaT"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"switch (T) {\n        f16, f32, f64 => u64,\n        f128 => u128,\n        else => unreachable,\n    }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"floatFromU64"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (MantissaT == u64) 768 else 11564"},{"code":"if (MantissaT == u64) 19 else 38"},{"code":"if (MantissaT == u64) 2047 else 32767"},{"code":"if (MantissaT == u64) -324 else -4966"},{"code":"if (MantissaT == u64) 310 else 4933"},{"code":"if (MantissaT == u64) 18 else 37"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"fmt"},{"code":"args"},{"code":"func call"},{"code":"input"},{"code":"field call"},{"code":"field call"},{"code":"switch (builtin.os.tag) {\n    .macos, .ios, .freebsd, .netbsd, .dragonfly, .openbsd, .solaris, .illumos => struct {\n        dir: Dir,\n        seek: i64,\n        buf: [1024]u8, // TODO align(@alignOf(posix.system.dirent)),\n        index: usize,\n        end_index: usize,\n        first_iter: bool,\n\n        const Self = @This();\n\n        pub const Error = IteratorError;\n\n        /// Memory such as file names referenced in this returned entry becomes invalid\n        /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n        pub fn next(self: *Self) Error!?Entry {\n            switch (builtin.os.tag) {\n                .macos, .ios => return self.nextDarwin(),\n                .freebsd, .netbsd, .dragonfly, .openbsd => return self.nextBsd(),\n                .solaris, .illumos => return self.nextSolaris(),\n                else => @compileError(\"unimplemented\"),\n            }\n        }\n\n        fn nextDarwin(self: *Self) !?Entry {\n            start_over: while (true) {\n                if (self.index >= self.end_index) {\n                    if (self.first_iter) {\n                        posix.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions\n                        self.first_iter = false;\n                    }\n                    const rc = posix.system.__getdirentries64(\n                        self.dir.fd,\n                        &self.buf,\n                        self.buf.len,\n                        &self.seek,\n                    );\n                    if (rc == 0) return null;\n                    if (rc < 0) {\n                        switch (posix.errno(rc)) {\n                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                            .FAULT => unreachable,\n                            .NOTDIR => unreachable,\n                            .INVAL => unreachable,\n                            else => |err| return posix.unexpectedErrno(err),\n                        }\n                    }\n                    self.index = 0;\n                    self.end_index = @as(usize, @intCast(rc));\n                }\n                const darwin_entry = @as(*align(1) posix.system.dirent, @ptrCast(&self.buf[self.index]));\n                const next_index = self.index + darwin_entry.reclen();\n                self.index = next_index;\n\n                const name = @as([*]u8, @ptrCast(&darwin_entry.d_name))[0..darwin_entry.d_namlen];\n\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (darwin_entry.d_ino == 0)) {\n                    continue :start_over;\n                }\n\n                const entry_kind: Entry.Kind = switch (darwin_entry.d_type) {\n                    posix.DT.BLK => .block_device,\n                    posix.DT.CHR => .character_device,\n                    posix.DT.DIR => .directory,\n                    posix.DT.FIFO => .named_pipe,\n                    posix.DT.LNK => .sym_link,\n                    posix.DT.REG => .file,\n                    posix.DT.SOCK => .unix_domain_socket,\n                    posix.DT.WHT => .whiteout,\n                    else => .unknown,\n                };\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        fn nextSolaris(self: *Self) !?Entry {\n            start_over: while (true) {\n                if (self.index >= self.end_index) {\n                    if (self.first_iter) {\n                        posix.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions\n                        self.first_iter = false;\n                    }\n                    const rc = posix.system.getdents(self.dir.fd, &self.buf, self.buf.len);\n                    switch (posix.errno(rc)) {\n                        .SUCCESS => {},\n                        .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                        .FAULT => unreachable,\n                        .NOTDIR => unreachable,\n                        .INVAL => unreachable,\n                        else => |err| return posix.unexpectedErrno(err),\n                    }\n                    if (rc == 0) return null;\n                    self.index = 0;\n                    self.end_index = @as(usize, @intCast(rc));\n                }\n                const entry = @as(*align(1) posix.system.dirent, @ptrCast(&self.buf[self.index]));\n                const next_index = self.index + entry.reclen();\n                self.index = next_index;\n\n                const name = mem.sliceTo(@as([*:0]u8, @ptrCast(&entry.d_name)), 0);\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\"))\n                    continue :start_over;\n\n                // Solaris dirent doesn't expose d_type, so we have to call stat to get it.\n                const stat_info = posix.fstatat(\n                    self.dir.fd,\n                    name,\n                    posix.AT.SYMLINK_NOFOLLOW,\n                ) catch |err| switch (err) {\n                    error.NameTooLong => unreachable,\n                    error.SymLinkLoop => unreachable,\n                    error.FileNotFound => unreachable, // lost the race\n                    else => |e| return e,\n                };\n                const entry_kind: Entry.Kind = switch (stat_info.mode & posix.S.IFMT) {\n                    posix.S.IFIFO => .named_pipe,\n                    posix.S.IFCHR => .character_device,\n                    posix.S.IFDIR => .directory,\n                    posix.S.IFBLK => .block_device,\n                    posix.S.IFREG => .file,\n                    posix.S.IFLNK => .sym_link,\n                    posix.S.IFSOCK => .unix_domain_socket,\n                    posix.S.IFDOOR => .door,\n                    posix.S.IFPORT => .event_port,\n                    else => .unknown,\n                };\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        fn nextBsd(self: *Self) !?Entry {\n            start_over: while (true) {\n                if (self.index >= self.end_index) {\n                    if (self.first_iter) {\n                        posix.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions\n                        self.first_iter = false;\n                    }\n                    const rc = if (builtin.os.tag == .netbsd)\n                        posix.system.__getdents30(self.dir.fd, &self.buf, self.buf.len)\n                    else\n                        posix.system.getdents(self.dir.fd, &self.buf, self.buf.len);\n                    switch (posix.errno(rc)) {\n                        .SUCCESS => {},\n                        .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                        .FAULT => unreachable,\n                        .NOTDIR => unreachable,\n                        .INVAL => unreachable,\n                        // Introduced in freebsd 13.2: directory unlinked but still open.\n                        // To be consistent, iteration ends if the directory being iterated is deleted during iteration.\n                        .NOENT => return null,\n                        else => |err| return posix.unexpectedErrno(err),\n                    }\n                    if (rc == 0) return null;\n                    self.index = 0;\n                    self.end_index = @as(usize, @intCast(rc));\n                }\n                const bsd_entry = @as(*align(1) posix.system.dirent, @ptrCast(&self.buf[self.index]));\n                const next_index = self.index + bsd_entry.reclen();\n                self.index = next_index;\n\n                const name = @as([*]u8, @ptrCast(&bsd_entry.d_name))[0..bsd_entry.d_namlen];\n\n                const skip_zero_fileno = switch (builtin.os.tag) {\n                    // d_fileno=0 is used to mark invalid entries or deleted files.\n                    .openbsd, .netbsd => true,\n                    else => false,\n                };\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or\n                    (skip_zero_fileno and bsd_entry.d_fileno == 0))\n                {\n                    continue :start_over;\n                }\n\n                const entry_kind: Entry.Kind = switch (bsd_entry.d_type) {\n                    posix.DT.BLK => .block_device,\n                    posix.DT.CHR => .character_device,\n                    posix.DT.DIR => .directory,\n                    posix.DT.FIFO => .named_pipe,\n                    posix.DT.LNK => .sym_link,\n                    posix.DT.REG => .file,\n                    posix.DT.SOCK => .unix_domain_socket,\n                    posix.DT.WHT => .whiteout,\n                    else => .unknown,\n                };\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        pub fn reset(self: *Self) void {\n            self.index = 0;\n            self.end_index = 0;\n            self.first_iter = true;\n        }\n    },\n    .haiku => struct {\n        dir: Dir,\n        buf: [1024]u8, // TODO align(@alignOf(posix.dirent64)),\n        index: usize,\n        end_index: usize,\n        first_iter: bool,\n\n        const Self = @This();\n\n        pub const Error = IteratorError;\n\n        /// Memory such as file names referenced in this returned entry becomes invalid\n        /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n        pub fn next(self: *Self) Error!?Entry {\n            start_over: while (true) {\n                // TODO: find a better max\n                const HAIKU_MAX_COUNT = 10000;\n                if (self.index >= self.end_index) {\n                    if (self.first_iter) {\n                        posix.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions\n                        self.first_iter = false;\n                    }\n                    const rc = posix.system._kern_read_dir(\n                        self.dir.fd,\n                        &self.buf,\n                        self.buf.len,\n                        HAIKU_MAX_COUNT,\n                    );\n                    if (rc == 0) return null;\n                    if (rc < 0) {\n                        switch (posix.errno(rc)) {\n                            .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                            .FAULT => unreachable,\n                            .NOTDIR => unreachable,\n                            .INVAL => unreachable,\n                            else => |err| return posix.unexpectedErrno(err),\n                        }\n                    }\n                    self.index = 0;\n                    self.end_index = @as(usize, @intCast(rc));\n                }\n                const haiku_entry = @as(*align(1) posix.system.dirent, @ptrCast(&self.buf[self.index]));\n                const next_index = self.index + haiku_entry.reclen();\n                self.index = next_index;\n                const name = mem.sliceTo(@as([*:0]u8, @ptrCast(&haiku_entry.d_name)), 0);\n\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\") or (haiku_entry.d_ino == 0)) {\n                    continue :start_over;\n                }\n\n                var stat_info: posix.Stat = undefined;\n                const rc = posix.system._kern_read_stat(\n                    self.dir.fd,\n                    &haiku_entry.d_name,\n                    false,\n                    &stat_info,\n                    0,\n                );\n                if (rc != 0) {\n                    switch (posix.errno(rc)) {\n                        .SUCCESS => {},\n                        .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                        .FAULT => unreachable,\n                        .NOTDIR => unreachable,\n                        .INVAL => unreachable,\n                        else => |err| return posix.unexpectedErrno(err),\n                    }\n                }\n                const statmode = stat_info.mode & posix.S.IFMT;\n\n                const entry_kind: Entry.Kind = switch (statmode) {\n                    posix.S.IFDIR => .directory,\n                    posix.S.IFBLK => .block_device,\n                    posix.S.IFCHR => .character_device,\n                    posix.S.IFLNK => .sym_link,\n                    posix.S.IFREG => .file,\n                    posix.S.IFIFO => .named_pipe,\n                    else => .unknown,\n                };\n\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        pub fn reset(self: *Self) void {\n            self.index = 0;\n            self.end_index = 0;\n            self.first_iter = true;\n        }\n    },\n    .linux => struct {\n        dir: Dir,\n        // The if guard is solely there to prevent compile errors from missing `linux.dirent64`\n        // definition when compiling for other OSes. It doesn't do anything when compiling for Linux.\n        buf: [1024]u8 align(if (builtin.os.tag != .linux) 1 else @alignOf(linux.dirent64)),\n        index: usize,\n        end_index: usize,\n        first_iter: bool,\n\n        const Self = @This();\n        const linux = std.os.linux;\n\n        pub const Error = IteratorError;\n\n        /// Memory such as file names referenced in this returned entry becomes invalid\n        /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n        pub fn next(self: *Self) Error!?Entry {\n            return self.nextLinux() catch |err| switch (err) {\n                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.\n                // This matches the behavior of non-Linux UNIX platforms.\n                error.DirNotFound => null,\n                else => |e| return e,\n            };\n        }\n\n        pub const ErrorLinux = error{DirNotFound} || IteratorError;\n\n        /// Implementation of `next` that can return `error.DirNotFound` if the directory being\n        /// iterated was deleted during iteration (this error is Linux specific).\n        pub fn nextLinux(self: *Self) ErrorLinux!?Entry {\n            start_over: while (true) {\n                if (self.index >= self.end_index) {\n                    if (self.first_iter) {\n                        posix.lseek_SET(self.dir.fd, 0) catch unreachable; // EBADF here likely means that the Dir was not opened with iteration permissions\n                        self.first_iter = false;\n                    }\n                    const rc = linux.getdents64(self.dir.fd, &self.buf, self.buf.len);\n                    switch (linux.getErrno(rc)) {\n                        .SUCCESS => {},\n                        .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                        .FAULT => unreachable,\n                        .NOTDIR => unreachable,\n                        .NOENT => return error.DirNotFound, // The directory being iterated was deleted during iteration.\n                        .INVAL => return error.Unexpected, // Linux may in some cases return EINVAL when reading /proc/$PID/net.\n                        .ACCES => return error.AccessDenied, // Do not have permission to iterate this directory.\n                        else => |err| return posix.unexpectedErrno(err),\n                    }\n                    if (rc == 0) return null;\n                    self.index = 0;\n                    self.end_index = rc;\n                }\n                const linux_entry = @as(*align(1) linux.dirent64, @ptrCast(&self.buf[self.index]));\n                const next_index = self.index + linux_entry.reclen();\n                self.index = next_index;\n\n                const name = mem.sliceTo(@as([*:0]u8, @ptrCast(&linux_entry.d_name)), 0);\n\n                // skip . and .. entries\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {\n                    continue :start_over;\n                }\n\n                const entry_kind: Entry.Kind = switch (linux_entry.d_type) {\n                    linux.DT.BLK => .block_device,\n                    linux.DT.CHR => .character_device,\n                    linux.DT.DIR => .directory,\n                    linux.DT.FIFO => .named_pipe,\n                    linux.DT.LNK => .sym_link,\n                    linux.DT.REG => .file,\n                    linux.DT.SOCK => .unix_domain_socket,\n                    else => .unknown,\n                };\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        pub fn reset(self: *Self) void {\n            self.index = 0;\n            self.end_index = 0;\n            self.first_iter = true;\n        }\n    },\n    .windows => struct {\n        dir: Dir,\n        buf: [1024]u8 align(@alignOf(std.os.windows.FILE_BOTH_DIR_INFORMATION)),\n        index: usize,\n        end_index: usize,\n        first_iter: bool,\n        name_data: [fs.MAX_NAME_BYTES]u8,\n\n        const Self = @This();\n\n        pub const Error = IteratorError;\n\n        /// Memory such as file names referenced in this returned entry becomes invalid\n        /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n        pub fn next(self: *Self) Error!?Entry {\n            while (true) {\n                const w = std.os.windows;\n                if (self.index >= self.end_index) {\n                    var io: w.IO_STATUS_BLOCK = undefined;\n                    const rc = w.ntdll.NtQueryDirectoryFile(\n                        self.dir.fd,\n                        null,\n                        null,\n                        null,\n                        &io,\n                        &self.buf,\n                        self.buf.len,\n                        .FileBothDirectoryInformation,\n                        w.FALSE,\n                        null,\n                        if (self.first_iter) @as(w.BOOLEAN, w.TRUE) else @as(w.BOOLEAN, w.FALSE),\n                    );\n                    self.first_iter = false;\n                    if (io.Information == 0) return null;\n                    self.index = 0;\n                    self.end_index = io.Information;\n                    switch (rc) {\n                        .SUCCESS => {},\n                        .ACCESS_DENIED => return error.AccessDenied, // Double-check that the Dir was opened with iteration ability\n\n                        else => return w.unexpectedStatus(rc),\n                    }\n                }\n\n                // While the official api docs guarantee FILE_BOTH_DIR_INFORMATION to be aligned properly\n                // this may not always be the case (e.g. due to faulty VM/Sandboxing tools)\n                const dir_info: *align(2) w.FILE_BOTH_DIR_INFORMATION = @ptrCast(@alignCast(&self.buf[self.index]));\n                if (dir_info.NextEntryOffset != 0) {\n                    self.index += dir_info.NextEntryOffset;\n                } else {\n                    self.index = self.buf.len;\n                }\n\n                const name_utf16le = @as([*]u16, @ptrCast(&dir_info.FileName))[0 .. dir_info.FileNameLength / 2];\n\n                if (mem.eql(u16, name_utf16le, &[_]u16{'.'}) or mem.eql(u16, name_utf16le, &[_]u16{ '.', '.' }))\n                    continue;\n                // Trust that Windows gives us valid UTF-16LE\n                const name_utf8_len = std.unicode.utf16leToUtf8(self.name_data[0..], name_utf16le) catch unreachable;\n                const name_utf8 = self.name_data[0..name_utf8_len];\n                const kind: Entry.Kind = blk: {\n                    const attrs = dir_info.FileAttributes;\n                    if (attrs & w.FILE_ATTRIBUTE_DIRECTORY != 0) break :blk .directory;\n                    if (attrs & w.FILE_ATTRIBUTE_REPARSE_POINT != 0) break :blk .sym_link;\n                    break :blk .file;\n                };\n                return Entry{\n                    .name = name_utf8,\n                    .kind = kind,\n                };\n            }\n        }\n\n        pub fn reset(self: *Self) void {\n            self.index = 0;\n            self.end_index = 0;\n            self.first_iter = true;\n        }\n    },\n    .wasi => struct {\n        dir: Dir,\n        buf: [1024]u8, // TODO align(@alignOf(posix.wasi.dirent_t)),\n        cookie: u64,\n        index: usize,\n        end_index: usize,\n\n        const Self = @This();\n\n        pub const Error = IteratorError;\n\n        /// Memory such as file names referenced in this returned entry becomes invalid\n        /// with subsequent calls to `next`, as well as when this `Dir` is deinitialized.\n        pub fn next(self: *Self) Error!?Entry {\n            return self.nextWasi() catch |err| switch (err) {\n                // To be consistent across platforms, iteration ends if the directory being iterated is deleted during iteration.\n                // This matches the behavior of non-Linux UNIX platforms.\n                error.DirNotFound => null,\n                else => |e| return e,\n            };\n        }\n\n        pub const ErrorWasi = error{DirNotFound} || IteratorError;\n\n        /// Implementation of `next` that can return platform-dependent errors depending on the host platform.\n        /// When the host platform is Linux, `error.DirNotFound` can be returned if the directory being\n        /// iterated was deleted during iteration.\n        pub fn nextWasi(self: *Self) ErrorWasi!?Entry {\n            // We intentinally use fd_readdir even when linked with libc,\n            // since its implementation is exactly the same as below,\n            // and we avoid the code complexity here.\n            const w = std.os.wasi;\n            start_over: while (true) {\n                // According to the WASI spec, the last entry might be truncated,\n                // so we need to check if the left buffer contains the whole dirent.\n                if (self.end_index - self.index < @sizeOf(w.dirent_t)) {\n                    var bufused: usize = undefined;\n                    switch (w.fd_readdir(self.dir.fd, &self.buf, self.buf.len, self.cookie, &bufused)) {\n                        .SUCCESS => {},\n                        .BADF => unreachable, // Dir is invalid or was opened without iteration ability\n                        .FAULT => unreachable,\n                        .NOTDIR => unreachable,\n                        .INVAL => unreachable,\n                        .NOENT => return error.DirNotFound, // The directory being iterated was deleted during iteration.\n                        .NOTCAPABLE => return error.AccessDenied,\n                        else => |err| return posix.unexpectedErrno(err),\n                    }\n                    if (bufused == 0) return null;\n                    self.index = 0;\n                    self.end_index = bufused;\n                }\n                const entry = @as(*align(1) w.dirent_t, @ptrCast(&self.buf[self.index]));\n                const entry_size = @sizeOf(w.dirent_t);\n                const name_index = self.index + entry_size;\n                if (name_index + entry.d_namlen > self.end_index) {\n                    // This case, the name is truncated, so we need to call readdir to store the entire name.\n                    self.end_index = self.index; // Force fd_readdir in the next loop.\n                    continue :start_over;\n                }\n                const name = self.buf[name_index .. name_index + entry.d_namlen];\n\n                const next_index = name_index + entry.d_namlen;\n                self.index = next_index;\n                self.cookie = entry.d_next;\n\n                // skip . and .. entries\n                if (mem.eql(u8, name, \".\") or mem.eql(u8, name, \"..\")) {\n                    continue :start_over;\n                }\n\n                const entry_kind: Entry.Kind = switch (entry.d_type) {\n                    .BLOCK_DEVICE => .block_device,\n                    .CHARACTER_DEVICE => .character_device,\n                    .DIRECTORY => .directory,\n                    .SYMBOLIC_LINK => .sym_link,\n                    .REGULAR_FILE => .file,\n                    .SOCKET_STREAM, .SOCKET_DGRAM => .unix_domain_socket,\n                    else => .unknown,\n                };\n                return Entry{\n                    .name = name,\n                    .kind = entry_kind,\n                };\n            }\n        }\n\n        pub fn reset(self: *Self) void {\n            self.index = 0;\n            self.end_index = 0;\n            self.cookie = std.os.wasi.DIRCOOKIE_START;\n        }\n    },\n    else => @compileError(\"unimplemented\"),\n}"},{"code":"field call"},{"code":"field call"},{"code":"if (optional_sentinel) |s| [:s]align(alignment) u8 else []align(alignment) u8"},{"code":"switch (builtin.os.tag) {\n    .windows => 0,\n    .wasi => 0,\n    else => 0o666,\n}"},{"code":"switch (builtin.os.tag) {\n        .windows => PermissionsWindows,\n        else => PermissionsUnix,\n    }"},{"code":"switch (builtin.os.tag) {\n        .windows => MetadataWindows,\n        .linux => MetadataLinux,\n        else => MetadataUnix,\n    }"},{"code":"if (optional_sentinel) |s| [:s]align(alignment) u8 else []align(alignment) u8"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"switch (native_os) {\n    .windows, .uefi => sep_windows,\n    else => sep_posix,\n}"},{"code":"switch (native_os) {\n    .windows, .uefi => sep_str_windows,\n    else => sep_str_posix,\n}"},{"code":"if (native_os == .windows) delimiter_windows else delimiter_posix"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"path_type"},{"code":"switch (path_type) {\n            .windows => error{BadPathName},\n            else => error{},\n        }"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"switch (native_os) {\n    .windows => .windows,\n    .uefi => .uefi,\n    else => .posix,\n}"},{"code":"func call"},{"code":"switch (builtin.os.tag) {\n    .windows, .wasi => false,\n    else => true,\n}"},{"code":"switch (builtin.os.tag) {\n    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .haiku, .solaris, .illumos, .plan9 => os.PATH_MAX,\n    // Each UTF-16LE character may be expanded to 3 UTF-8 bytes.\n    // If it would require 4 UTF-8 bytes, then there would be a surrogate\n    // pair in the UTF-16LE, and we (over)account 3 bytes for it that way.\n    // +1 for the null byte at the end, which can be encoded in 1 byte.\n    .windows => os.windows.PATH_MAX_WIDE * 3 + 1,\n    // TODO work out what a reasonable value we should use here\n    .wasi => 4096,\n    else => if (@hasDecl(root, \"os\") and @hasDecl(root.os, \"PATH_MAX\"))\n        root.os.PATH_MAX\n    else\n        @compileError(\"PATH_MAX not implemented for \" ++ @tagName(builtin.os.tag)),\n}"},{"code":"switch (builtin.os.tag) {\n    .linux, .macos, .ios, .freebsd, .openbsd, .netbsd, .dragonfly, .solaris, .illumos => os.NAME_MAX,\n    // Haiku's NAME_MAX includes the null terminator, so subtract one.\n    .haiku => os.NAME_MAX - 1,\n    // Each UTF-16LE character may be expanded to 3 UTF-8 bytes.\n    // If it would require 4 UTF-8 bytes, then there would be a surrogate\n    // pair in the UTF-16LE, and we (over)account 3 bytes for it that way.\n    .windows => os.windows.NAME_MAX * 3,\n    // For WASI, the MAX_NAME will depend on the host OS, so it needs to be\n    // as large as the largest MAX_NAME_BYTES (Windows) in order to work on any host OS.\n    // TODO determine if this is a reasonable approach\n    .wasi => os.windows.NAME_MAX * 3,\n    else => if (@hasDecl(root, \"os\") and @hasDecl(root.os, \"NAME_MAX\"))\n        root.os.NAME_MAX\n    else\n        @compileError(\"NAME_MAX not implemented for \" ++ @tagName(builtin.os.tag)),\n}"},{"code":"field call"},{"code":"field call"},{"code":"hash_fn"},{"code":"Hash"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"W"},{"code":"W"},{"code":"W"},{"code":"W"},{"code":"func call"},{"code":"if (@bitSizeOf(W) < 8) u8 else W"},{"code":"blk: {\n            @setEvalBranchQuota(2500);\n\n            const poly = if (algorithm.reflect_input)\n                @bitReverse(@as(I, algorithm.polynomial)) >> (@bitSizeOf(I) - @bitSizeOf(W))\n            else\n                @as(I, algorithm.polynomial) << (@bitSizeOf(I) - @bitSizeOf(W));\n\n            var table: [256]I = undefined;\n            for (&table, 0..) |*e, i| {\n                var crc: I = i;\n                if (algorithm.reflect_input) {\n                    var j: usize = 0;\n                    while (j < 8) : (j += 1) {\n                        crc = (crc >> 1) ^ ((crc & 1) * poly);\n                    }\n                } else {\n                    crc <<= @bitSizeOf(I) - 8;\n                    var j: usize = 0;\n                    while (j < 8) : (j += 1) {\n                        crc = (crc << 1) ^ (((crc >> (@bitSizeOf(I) - 1)) & 1) * poly);\n                    }\n                }\n                e.* = crc;\n            }\n            break :blk table;\n        }"},{"code":"W"},{"code":"W"},{"code":"func call"},{"code":"block: {\n            @setEvalBranchQuota(20000);\n            var tables: [8][256]u32 = undefined;\n\n            for (&tables[0], 0..) |*e, i| {\n                var crc = @as(u32, @intCast(i));\n                var j: usize = 0;\n                while (j < 8) : (j += 1) {\n                    if (crc & 1 == 1) {\n                        crc = (crc >> 1) ^ @intFromEnum(poly);\n                    } else {\n                        crc = (crc >> 1);\n                    }\n                }\n                e.* = crc;\n            }\n\n            var i: usize = 0;\n            while (i < 256) : (i += 1) {\n                var crc = tables[0][i];\n                var j: usize = 1;\n                while (j < 8) : (j += 1) {\n                    const index: u8 = @truncate(crc);\n                    crc = tables[0][index] ^ (crc >> 8);\n                    tables[j][i] = crc;\n                }\n            }\n\n            break :block tables;\n        }"},{"code":"block: {\n            var table: [16]u32 = undefined;\n\n            for (&table, 0..) |*e, i| {\n                var crc = @as(u32, @intCast(i * 16));\n                var j: usize = 0;\n                while (j < 8) : (j += 1) {\n                    if (crc & 1 == 1) {\n                        crc = (crc >> 1) ^ @intFromEnum(poly);\n                    } else {\n                        crc = (crc >> 1);\n                    }\n                }\n                e.* = crc;\n            }\n\n            break :block table;\n        }"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"x"},{"code":"Context"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"func call"},{"code":"func call"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"func call"},{"code":"func call"},{"code":"K"},{"code":"func call"},{"code":"K"},{"code":"func call"},{"code":"V"},{"code":"func call"},{"code":"V"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"max_load_percentage"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"new_ctx"},{"code":"max_load_percentage"},{"code":"func call"},{"code":"K"},{"code":"V"},{"code":"new_ctx"},{"code":"max_load_percentage"},{"code":"func call"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"func call"},{"code":"V"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"max_load_percentage"},{"code":"func call"},{"code":"Context"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"Context"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"Context"},{"code":"V"},{"code":"V"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"K"},{"code":"V"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"Context"},{"code":"K"},{"code":"V"},{"code":"new_ctx"},{"code":"max_load_percentage"},{"code":"func call"},{"code":"Context"},{"code":"success_log_level"},{"code":"failure_log_level"},{"code":"func call"},{"code":"func call"},{"code":"Writer"},{"code":"Writer"},{"code":"writer"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (builtin.is_test) 10 else 6"},{"code":"if (std.debug.sys_can_stack_trace) default_test_stack_trace_frames else 0"},{"code":"switch (builtin.mode) {\n    .Debug => default_sys_stack_trace_frames,\n    else => 0,\n}"},{"code":"if (config.enable_memory_limit) @as(usize, 0) else {}"},{"code":"if (config.enable_memory_limit) @as(usize, math.maxInt(usize)) else {}"},{"code":"if (config.MutexType) |T|\n            T{}\n        else if (config.thread_safe)\n            std.Thread.Mutex{}\n        else\n            DummyMutex{}"},{"code":"config"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"if (config.retain_metadata) traces_per_slot else 1"},{"code":"if (config.enable_memory_limit) usize else void"},{"code":"if (config.retain_metadata) bool else void"},{"code":"if (config.never_unmap and config.retain_metadata) u8 else void"},{"code":"field call"},{"code":"if (config.retain_metadata) Buckets else void"},{"code":"if (config.retain_metadata) Buckets{} else {}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"coerce_ptr_elem_ty"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Item"},{"code":"block_comptime"},{"code":"func call"},{"code":"Item"},{"code":"pool_options.alignment orelse @alignOf(Item)"},{"code":"Item"},{"code":"if (@hasDecl(c, \"malloc_size\"))\n        c.malloc_size\n    else if (@hasDecl(c, \"malloc_usable_size\"))\n        c.malloc_usable_size\n    else if (@hasDecl(c, \"_msize\"))\n        c._msize\n    else {}"},{"code":"if (@hasDecl(root, \"os\") and\n    @hasDecl(root.os, \"heap\") and\n    @hasDecl(root.os.heap, \"page_allocator\"))\n    root.os.heap.page_allocator\nelse if (builtin.target.isWasm())\n    Allocator{\n        .ptr = undefined,\n        .vtable = &WasmPageAllocator.vtable,\n    }\nelse if (builtin.target.os.tag == .plan9)\n    Allocator{\n        .ptr = undefined,\n        .vtable = &SbrkAllocator(std.os.plan9.sbrk).vtable,\n    }\nelse\n    Allocator{\n        .ptr = undefined,\n        .vtable = &PageAllocator.vtable,\n    }"},{"code":"switch (builtin.os.tag) {\n    .windows => struct {\n        heap_handle: ?HeapHandle,\n\n        const HeapHandle = os.windows.HANDLE;\n\n        pub fn init() HeapAllocator {\n            return HeapAllocator{\n                .heap_handle = null,\n            };\n        }\n\n        pub fn allocator(self: *HeapAllocator) Allocator {\n            return .{\n                .ptr = self,\n                .vtable = &.{\n                    .alloc = alloc,\n                    .resize = resize,\n                    .free = free,\n                },\n            };\n        }\n\n        pub fn deinit(self: *HeapAllocator) void {\n            if (self.heap_handle) |heap_handle| {\n                os.windows.HeapDestroy(heap_handle);\n            }\n        }\n\n        fn getRecordPtr(buf: []u8) *align(1) usize {\n            return @as(*align(1) usize, @ptrFromInt(@intFromPtr(buf.ptr) + buf.len));\n        }\n\n        fn alloc(\n            ctx: *anyopaque,\n            n: usize,\n            log2_ptr_align: u8,\n            return_address: usize,\n        ) ?[*]u8 {\n            _ = return_address;\n            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));\n\n            const ptr_align = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_ptr_align));\n            const amt = n + ptr_align - 1 + @sizeOf(usize);\n            const optional_heap_handle = @atomicLoad(?HeapHandle, &self.heap_handle, .SeqCst);\n            const heap_handle = optional_heap_handle orelse blk: {\n                const options = if (builtin.single_threaded) os.windows.HEAP_NO_SERIALIZE else 0;\n                const hh = os.windows.kernel32.HeapCreate(options, amt, 0) orelse return null;\n                const other_hh = @cmpxchgStrong(?HeapHandle, &self.heap_handle, null, hh, .SeqCst, .SeqCst) orelse break :blk hh;\n                os.windows.HeapDestroy(hh);\n                break :blk other_hh.?; // can't be null because of the cmpxchg\n            };\n            const ptr = os.windows.kernel32.HeapAlloc(heap_handle, 0, amt) orelse return null;\n            const root_addr = @intFromPtr(ptr);\n            const aligned_addr = mem.alignForward(usize, root_addr, ptr_align);\n            const buf = @as([*]u8, @ptrFromInt(aligned_addr))[0..n];\n            getRecordPtr(buf).* = root_addr;\n            return buf.ptr;\n        }\n\n        fn resize(\n            ctx: *anyopaque,\n            buf: []u8,\n            log2_buf_align: u8,\n            new_size: usize,\n            return_address: usize,\n        ) bool {\n            _ = log2_buf_align;\n            _ = return_address;\n            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));\n\n            const root_addr = getRecordPtr(buf).*;\n            const align_offset = @intFromPtr(buf.ptr) - root_addr;\n            const amt = align_offset + new_size + @sizeOf(usize);\n            const new_ptr = os.windows.kernel32.HeapReAlloc(\n                self.heap_handle.?,\n                os.windows.HEAP_REALLOC_IN_PLACE_ONLY,\n                @as(*anyopaque, @ptrFromInt(root_addr)),\n                amt,\n            ) orelse return false;\n            assert(new_ptr == @as(*anyopaque, @ptrFromInt(root_addr)));\n            getRecordPtr(buf.ptr[0..new_size]).* = root_addr;\n            return true;\n        }\n\n        fn free(\n            ctx: *anyopaque,\n            buf: []u8,\n            log2_buf_align: u8,\n            return_address: usize,\n        ) void {\n            _ = log2_buf_align;\n            _ = return_address;\n            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));\n            os.windows.HeapFree(self.heap_handle.?, 0, @as(*anyopaque, @ptrFromInt(getRecordPtr(buf).*)));\n        }\n    },\n    else => @compileError(\"Unsupported OS\"),\n}"},{"code":"size"},{"code":"func call"},{"code":"size"},{"code":"if (std.debug.runtime_safety) bool else void"},{"code":"if (std.debug.runtime_safety) false else {}"},{"code":"field call"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (!disable_tls) *std.crypto.tls.Client else void"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"field call"},{"code":"struct_init_field_type"},{"code":"if (disable_tls) void else std.crypto.Certificate.Bundle"},{"code":"if (disable_tls) {} else .{}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"writer"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"Context"},{"code":"ReadError"},{"code":"ReadError"},{"code":"ReadError"},{"code":"field call"},{"code":"alignment"},{"code":"field call"},{"code":"field call"},{"code":"writer"},{"code":"num_bytes"},{"code":"num_bytes"},{"code":"field call"},{"code":"num_bytes"},{"code":"field call"},{"code":"T"},{"code":"ReturnType"},{"code":"T"},{"code":"T"},{"code":"Enum"},{"code":"Context"},{"code":"Context"},{"code":"WriteError"},{"code":"WriteError"},{"code":"T"},{"code":"Context"},{"code":"field call"},{"code":"alignment"},{"code":"field call"},{"code":"field call"},{"code":"num_bytes"},{"code":"num_bytes"},{"code":"field call"},{"code":"num_bytes"},{"code":"field call"},{"code":"T"},{"code":"ReturnType"},{"code":"T"},{"code":"T"},{"code":"Enum"},{"code":"field call"},{"code":"T"},{"code":"Context"},{"code":"SeekErrorType"},{"code":"Context"},{"code":"SeekErrorType"},{"code":"Context"},{"code":"GetSeekPosErrorType"},{"code":"Context"},{"code":"GetSeekPosErrorType"},{"code":"SeekErrorType"},{"code":"GetSeekPosErrorType"},{"code":"Context"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"buffer_size"},{"code":"underlying_stream"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"buffer_size"},{"code":"reader"},{"code":"func call"},{"code":"size"},{"code":"reader"},{"code":"func call"},{"code":"underlying_stream"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"buffer_type"},{"code":"field call"},{"code":"buffer_type"},{"code":"switch (buffer_type) {\n            .Static => initStatic,\n            .Slice => initSlice,\n            .Dynamic => initDynamic,\n        }"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"lookahead"},{"code":"underlying_stream"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Buffer"},{"code":"Buffer"},{"code":"buffer"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"inner_reader"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"child_stream"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"reader"},{"code":"func call"},{"code":"alloc_inferred_comptime_mut"},{"code":"field call"},{"code":"Writers"},{"code":"streams"},{"code":"func call"},{"code":"ReaderType"},{"code":"field call"},{"code":"ReaderType"},{"code":"U"},{"code":"U"},{"code":"ReaderType"},{"code":"endian"},{"code":"underlying_stream"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"WriterType"},{"code":"endian"},{"code":"underlying_stream"},{"code":"func call"},{"code":"WriterType"},{"code":"field call"},{"code":"WriterType"},{"code":"underlying_writer"},{"code":"func call"},{"code":"UnderlyingWriter"},{"code":"field call"},{"code":"UnderlyingWriter"},{"code":"underlying_writer"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"if (has_file) std.fs.File.ReadError else error{}"},{"code":"if (has_file) std.fs.File.WriteError else error{}"},{"code":"if (has_file) std.fs.File.SeekError else error{}"},{"code":"if (has_file) std.fs.File.GetSeekPosError else error{}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (has_file) std.fs.File else void"},{"code":"if (native_os == .windows) WindowsContext else void"},{"code":"func call"},{"code":"StreamEnum"},{"code":"func call"},{"code":"StreamEnum"},{"code":"func call"},{"code":"field call"},{"code":"StreamEnum"},{"code":"if (builtin.os.tag == .windows) void else std.os.pollfd"},{"code":"StreamEnum"},{"code":"if (builtin.os.tag == .windows) struct {\n            first_read_done: bool,\n            overlapped: [enum_fields.len]os.windows.OVERLAPPED,\n            active: struct {\n                count: math.IntFittingRange(0, enum_fields.len),\n                handles_buf: [enum_fields.len]os.windows.HANDLE,\n                stream_map: [enum_fields.len]StreamEnum,\n\n                pub fn removeAt(self: *@This(), index: u32) void {\n                    std.debug.assert(index < self.count);\n                    for (index + 1..self.count) |i| {\n                        self.handles_buf[i - 1] = self.handles_buf[i];\n                        self.stream_map[i - 1] = self.stream_map[i];\n                    }\n                    self.count -= 1;\n                }\n            },\n        } else void"},{"code":"struct_init_field_type"},{"code":"alloc_mut"},{"code":"struct_init_field_type"},{"code":"out_stream"},{"code":"out_stream"},{"code":"out_stream"},{"code":"func call"},{"code":"out_stream"},{"code":"if (max_depth) |d| .{ .checked_to_fixed_depth = d } else .assumed_correct"},{"code":"func call"},{"code":"out_stream"},{"code":"func call"},{"code":"switch (@import(\"builtin\").mode) {\n            .Debug, .ReleaseSafe => safety_checks_hint,\n            .ReleaseFast, .ReleaseSmall => .assumed_correct,\n        }"},{"code":"OutStream"},{"code":"switch (safety_checks) {\n            .checked_to_arbitrary_depth => Stream.Error || error{OutOfMemory},\n            .checked_to_fixed_depth, .assumed_correct => Stream.Error,\n        }"},{"code":"OutStream"},{"code":"OutStream"},{"code":"switch (safety_checks) {\n            .checked_to_arbitrary_depth => BitStack,\n            .checked_to_fixed_depth => |fixed_buffer_size| [(fixed_buffer_size + 7) >> 3]u8,\n            .assumed_correct => void,\n        }"},{"code":"io_reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"func call"},{"code":"func call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"buffer_size"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"scanner_or_reader"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"scanner_or_reader"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"Source"},{"code":"Source"},{"code":"Source"},{"code":"source"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"source"},{"code":"func call"},{"code":"T"},{"code":"field call"},{"code":"value"},{"code":"func call"},{"code":"T"},{"code":"switch (builtin.mode) {\n    .Debug => .debug,\n    .ReleaseSafe => .info,\n    .ReleaseFast, .ReleaseSmall => .err,\n}"},{"code":"func call"},{"code":"Cmd"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"x"},{"code":"func call"},{"code":"magnitude"},{"code":"magnitude"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"block_comptime"},{"code":"switch (@typeInfo(T)) {\n        .Int => |int| std.meta.Int(.unsigned, (int.bits + 1) / 2),\n        else => T,\n    }"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"y"},{"code":"x"},{"code":"y"},{"code":"x"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"x"},{"code":"a"},{"code":"b"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"value"},{"code":"value"},{"code":"value"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"value"},{"code":"value"},{"code":"z"},{"code":"z"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"s"},{"code":"s"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"z"},{"code":"z"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"typeof_log2_int_type"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"x"},{"code":"val"},{"code":"lower"},{"code":"upper"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"alloc_inferred_comptime_mut"},{"code":"field call"},{"code":"alloc_inferred_comptime_mut"},{"code":"field call"},{"code":"if (from < 0) .signed else .unsigned"},{"code":"alloc_inferred_mut"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"x"},{"code":"field call"},{"code":"T"},{"code":"alloc_inferred_mut"},{"code":"alignment"},{"code":"ptr"},{"code":"func call"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"field call"},{"code":"value"},{"code":"value"},{"code":"value"},{"code":"T"},{"code":"T"},{"code":"value"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"a"},{"code":"b"},{"code":"t"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"MaskInt"},{"code":"denom"},{"code":"func call"},{"code":"i"},{"code":"field call"},{"code":"Fields"},{"code":"Fields"},{"code":"field call"},{"code":"field call"},{"code":"blk: {\n            var fields: [bit_count]Type.StructField = undefined;\n            for (@typeInfo(Fields).Struct.fields, 0..) |struct_field, i| {\n                fields[i] = Type.StructField{\n                    .name = struct_field.name,\n                    .type = ?struct_field.type,\n                    .default_value = &@as(?struct_field.type, null),\n                    .is_comptime = false,\n                    .alignment = @alignOf(?struct_field.type),\n                };\n            }\n            break :blk @Type(.{\n                .Struct = .{\n                    .layout = .Auto,\n                    .fields = &fields,\n                    .decls = &.{},\n                    .is_tuple = false,\n                },\n            });\n        }"},{"code":"Fields"},{"code":"field"},{"code":"func call"},{"code":"Fields"},{"code":"Fields"},{"code":"field"},{"code":"func call"},{"code":"Fields"},{"code":"field"},{"code":"func call"},{"code":"Fields"},{"code":"field"},{"code":"func call"},{"code":"block_comptime"},{"code":"field"},{"code":"T"},{"code":"block_comptime"},{"code":"switch (@typeInfo(T)) {\n        .Array => |info| info.child,\n        .Vector => |info| info.child,\n        .Pointer => |info| info.child,\n        .Optional => |info| info.child,\n        else => @compileError(\"Expected pointer, optional, array or vector type, found '\" ++ @typeName(T) ++ \"'\"),\n    }"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"switch (@typeInfo(T)) {\n    .Struct => []const Type.StructField,\n    .Union => []const Type.UnionField,\n    .ErrorSet => []const Type.Error,\n    .Enum => []const Type.EnumField,\n    else => @compileError(\"Expected struct, union, error set or enum type, found '\" ++ @typeName(T) ++ \"'\"),\n}"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"switch (@typeInfo(T)) {\n    .Struct => Type.StructField,\n    .Union => Type.UnionField,\n    .ErrorSet => Type.Error,\n    .Enum => Type.EnumField,\n    else => @compileError(\"Expected struct, union, error set or enum type, found '\" ++ @typeName(T) ++ \"'\"),\n}"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"struct_init_field_type"},{"code":"field call"},{"code":"alloc_mut"},{"code":"alloc_inferred_mut"},{"code":"expected"},{"code":"struct_init_field_type"},{"code":"field call"},{"code":"alloc_mut"},{"code":"alloc_inferred_mut"},{"code":"block_comptime"},{"code":"switch (@typeInfo(T)) {\n        .Enum => |info| info.tag_type,\n        .Union => |info| info.tag_type orelse @compileError(@typeName(T) ++ \" has no tag type\"),\n        else => @compileError(\"expected enum or union type, found '\" ++ @typeName(T) ++ \"'\"),\n    }"},{"code":"u"},{"code":"func call"},{"code":"U"},{"code":"func call"},{"code":"U"},{"code":"tag"},{"code":"func call"},{"code":"a"},{"code":"EnumTag"},{"code":"Decl"},{"code":"struct_init_field_type"},{"code":"signedness"},{"code":"bit_count"},{"code":"struct_init_field_type"},{"code":"bit_count"},{"code":"alloc_mut"},{"code":"alloc_mut"},{"code":"func call"},{"code":"types"},{"code":"types"},{"code":"types"},{"code":"func call"},{"code":"N"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"alloc_mut"},{"code":"field call"},{"code":"builtin.os.version_range.windows.isAtLeast(.win10_rs4) orelse false"},{"code":"if (has_unix_sockets) os.sockaddr.un else void"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (switch (builtin.zig_backend) {\n    // Calling extern functions is not yet supported with these backends\n    .stage2_aarch64, .stage2_arm, .stage2_riscv64, .stage2_sparc64 => false,\n    else => !builtin.link_libc,\n}) struct {\n    /// See `std.elf` for the constants.\n    /// This matches the libc getauxval function.\n    pub extern fn getauxval(index: usize) usize;\n    comptime {\n        @export(getauxvalImpl, .{ .name = \"getauxval\", .linkage = .Weak });\n    }\n} else struct {\n    pub const getauxval = getauxvalImpl;\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"switch (native_arch) {\n    .thumb => @import(\"linux/thumb.zig\"),\n    else => arch_bits,\n}"},{"code":"switch (native_arch) {\n    .x86 => @import(\"linux/x86.zig\"),\n    .x86_64 => @import(\"linux/x86_64.zig\"),\n    .aarch64, .aarch64_be => @import(\"linux/arm64.zig\"),\n    .arm, .thumb => @import(\"linux/arm-eabi.zig\"),\n    .riscv64 => @import(\"linux/riscv64.zig\"),\n    .sparc64 => @import(\"linux/sparc64.zig\"),\n    .mips, .mipsel => @import(\"linux/mips.zig\"),\n    .mips64, .mips64el => @import(\"linux/mips64.zig\"),\n    .powerpc, .powerpcle => @import(\"linux/powerpc.zig\"),\n    .powerpc64, .powerpc64le => @import(\"linux/powerpc64.zig\"),\n    else => struct {},\n}"},{"code":"switch (native_arch) {\n    .arm, .armeb, .thumb, .aarch64, .aarch64_be, .riscv32, .riscv64, .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpcle, .powerpc64, .powerpc64le => TLSVariant.VariantI,\n    .x86_64, .x86, .sparc64 => TLSVariant.VariantII,\n    else => @compileError(\"undefined tls_variant for this architecture\"),\n}"},{"code":"switch (native_arch) {\n    // ARM EABI mandates enough space for two pointers: the first one points to\n    // the DTV while the second one is unspecified but reserved\n    .arm, .armeb, .thumb, .aarch64, .aarch64_be => 2 * @sizeOf(usize),\n    // One pointer-sized word that points either to the DTV or the TCB itself\n    else => @sizeOf(usize),\n}"},{"code":"switch (native_arch) {\n    .riscv32, .riscv64, .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => true,\n    else => false,\n}"},{"code":"switch (native_arch) {\n    .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => 0x7000,\n    else => 0,\n}"},{"code":"switch (native_arch) {\n    .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => 0x8000,\n    .riscv32, .riscv64 => 0x800,\n    else => 0,\n}"},{"code":"T"},{"code":"switch (builtin.cpu.arch) {\n    .x86 => R_386_RELATIVE,\n    .x86_64 => R_AMD64_RELATIVE,\n    .arm => R_ARM_RELATIVE,\n    .aarch64 => R_AARCH64_RELATIVE,\n    .riscv64 => R_RISCV_RELATIVE,\n    else => @compileError(\"Missing R_RELATIVE definition for this target\"),\n}"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"switch (builtin.cpu.arch) {\n    .bpfel, .bpfeb => true,\n    else => false,\n}"},{"code":"if (in_bpf_program) @import(\"helpers.zig\") else struct {}"},{"code":"switch (@import(\"builtin\").cpu.arch) {\n    .mips,\n    .mipsel,\n    .mips64,\n    .mips64el,\n    .powerpc,\n    .powerpcle,\n    .powerpc64,\n    .powerpc64le,\n    .sparc,\n    .sparc64,\n    .sparcel,\n    => .{ .size = 13, .dir = 3, .none = 1, .read = 2, .write = 4 },\n    else => .{ .size = 14, .dir = 2, .none = 0, .read = 2, .write = 1 },\n}"},{"code":"field call"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"switch (@import(\"builtin\").cpu.arch) {\n    .x86 => syscalls.X86,\n    .x86_64 => syscalls.X64,\n    .aarch64, .aarch64_be => syscalls.Arm64,\n    .arm, .thumb => syscalls.Arm,\n    .riscv64 => syscalls.RiscV64,\n    .sparc64 => syscalls.Sparc64,\n    .mips, .mipsel => syscalls.Mips,\n    .mips64, .mips64el => syscalls.Mips64,\n    .powerpc, .powerpcle => syscalls.PowerPC,\n    .powerpc64, .powerpc64le => syscalls.PowerPC64,\n    else => @compileError(\"The Zig Standard Library is missing syscall definitions for the target CPU architecture\"),\n}"},{"code":"switch (native_arch) {\n    .x86_64, .x86 => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        @\"32BIT\": bool = false,\n        _7: u1 = 0,\n        GROWSDOWN: bool = false,\n        _9: u2 = 0,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        LOCKED: bool = false,\n        NORESERVE: bool = false,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    .aarch64, .aarch64_be, .arm, .thumb => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        _6: u2 = 0,\n        GROWSDOWN: bool = false,\n        _9: u2 = 0,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        LOCKED: bool = false,\n        NORESERVE: bool = false,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    .riscv64 => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        _6: u9 = 0,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    .sparc64 => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        NORESERVE: bool = false,\n        _7: u1 = 0,\n        LOCKED: bool = false,\n        GROWSDOWN: bool = false,\n        _10: u1 = 0,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        _13: u2 = 0,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    .mips, .mipsel, .mips64, .mips64el => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        _5: u1 = 0,\n        @\"32BIT\": bool = false,\n        _7: u3 = 0,\n        NORESERVE: bool = false,\n        ANONYMOUS: bool = false,\n        GROWSDOWN: bool = false,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        LOCKED: bool = false,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    .powerpc, .powerpcle, .powerpc64, .powerpc64le => packed struct(u32) {\n        TYPE: MAP_TYPE,\n        FIXED: bool = false,\n        ANONYMOUS: bool = false,\n        NORESERVE: bool = false,\n        LOCKED: bool = false,\n        GROWSDOWN: bool = false,\n        _9: u2 = 0,\n        DENYWRITE: bool = false,\n        EXECUTABLE: bool = false,\n        _13: u2 = 0,\n        POPULATE: bool = false,\n        NONBLOCK: bool = false,\n        STACK: bool = false,\n        HUGETLB: bool = false,\n        SYNC: bool = false,\n        FIXED_NOREPLACE: bool = false,\n        _21: u5 = 0,\n        UNINITIALIZED: bool = false,\n        _: u5 = 0,\n    },\n    else => @compileError(\"missing std.os.linux.MAP constants for this architecture\"),\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"switch (native_arch) {\n    .mips, .mipsel => @import(\"linux/errno/mips.zig\").E,\n    .sparc, .sparcel, .sparc64 => @import(\"linux/errno/sparc.zig\").E,\n    else => @import(\"linux/errno/generic.zig\").E,\n}"},{"code":"switch (native_arch) {\n        // TODO: also xtensa\n        .mips, .mipsel, .mips64, .mips64el => 0x10,\n        else => 0x8,\n    }"},{"code":"if (is_mips) struct {\n    pub const NOCLDSTOP = 1;\n    pub const NOCLDWAIT = 0x10000;\n    pub const SIGINFO = 8;\n    pub const RESTART = 0x10000000;\n    pub const RESETHAND = 0x80000000;\n    pub const ONSTACK = 0x08000000;\n    pub const NODEFER = 0x40000000;\n    pub const RESTORER = 0x04000000;\n} else if (is_sparc) struct {\n    pub const NOCLDSTOP = 0x8;\n    pub const NOCLDWAIT = 0x100;\n    pub const SIGINFO = 0x200;\n    pub const RESTART = 0x2;\n    pub const RESETHAND = 0x4;\n    pub const ONSTACK = 0x1;\n    pub const NODEFER = 0x20;\n    pub const RESTORER = 0x04000000;\n} else struct {\n    pub const NOCLDSTOP = 1;\n    pub const NOCLDWAIT = 2;\n    pub const SIGINFO = 4;\n    pub const RESTART = 0x10000000;\n    pub const RESETHAND = 0x80000000;\n    pub const ONSTACK = 0x08000000;\n    pub const NODEFER = 0x40000000;\n    pub const RESTORER = 0x04000000;\n}"},{"code":"if (is_mips) struct {\n    pub const BLOCK = 1;\n    pub const UNBLOCK = 2;\n    pub const SETMASK = 3;\n\n    pub const HUP = 1;\n    pub const INT = 2;\n    pub const QUIT = 3;\n    pub const ILL = 4;\n    pub const TRAP = 5;\n    pub const ABRT = 6;\n    pub const IOT = ABRT;\n    pub const BUS = 7;\n    pub const FPE = 8;\n    pub const KILL = 9;\n    pub const USR1 = 10;\n    pub const SEGV = 11;\n    pub const USR2 = 12;\n    pub const PIPE = 13;\n    pub const ALRM = 14;\n    pub const TERM = 15;\n    pub const STKFLT = 16;\n    pub const CHLD = 17;\n    pub const CONT = 18;\n    pub const STOP = 19;\n    pub const TSTP = 20;\n    pub const TTIN = 21;\n    pub const TTOU = 22;\n    pub const URG = 23;\n    pub const XCPU = 24;\n    pub const XFSZ = 25;\n    pub const VTALRM = 26;\n    pub const PROF = 27;\n    pub const WINCH = 28;\n    pub const IO = 29;\n    pub const POLL = 29;\n    pub const PWR = 30;\n    pub const SYS = 31;\n    pub const UNUSED = SIG.SYS;\n\n    pub const ERR = @as(?Sigaction.handler_fn, @ptrFromInt(maxInt(usize)));\n    pub const DFL = @as(?Sigaction.handler_fn, @ptrFromInt(0));\n    pub const IGN = @as(?Sigaction.handler_fn, @ptrFromInt(1));\n} else if (is_sparc) struct {\n    pub const BLOCK = 1;\n    pub const UNBLOCK = 2;\n    pub const SETMASK = 4;\n\n    pub const HUP = 1;\n    pub const INT = 2;\n    pub const QUIT = 3;\n    pub const ILL = 4;\n    pub const TRAP = 5;\n    pub const ABRT = 6;\n    pub const EMT = 7;\n    pub const FPE = 8;\n    pub const KILL = 9;\n    pub const BUS = 10;\n    pub const SEGV = 11;\n    pub const SYS = 12;\n    pub const PIPE = 13;\n    pub const ALRM = 14;\n    pub const TERM = 15;\n    pub const URG = 16;\n    pub const STOP = 17;\n    pub const TSTP = 18;\n    pub const CONT = 19;\n    pub const CHLD = 20;\n    pub const TTIN = 21;\n    pub const TTOU = 22;\n    pub const POLL = 23;\n    pub const XCPU = 24;\n    pub const XFSZ = 25;\n    pub const VTALRM = 26;\n    pub const PROF = 27;\n    pub const WINCH = 28;\n    pub const LOST = 29;\n    pub const USR1 = 30;\n    pub const USR2 = 31;\n    pub const IOT = ABRT;\n    pub const CLD = CHLD;\n    pub const PWR = LOST;\n    pub const IO = SIG.POLL;\n\n    pub const ERR = @as(?Sigaction.handler_fn, @ptrFromInt(maxInt(usize)));\n    pub const DFL = @as(?Sigaction.handler_fn, @ptrFromInt(0));\n    pub const IGN = @as(?Sigaction.handler_fn, @ptrFromInt(1));\n} else struct {\n    pub const BLOCK = 0;\n    pub const UNBLOCK = 1;\n    pub const SETMASK = 2;\n\n    pub const HUP = 1;\n    pub const INT = 2;\n    pub const QUIT = 3;\n    pub const ILL = 4;\n    pub const TRAP = 5;\n    pub const ABRT = 6;\n    pub const IOT = ABRT;\n    pub const BUS = 7;\n    pub const FPE = 8;\n    pub const KILL = 9;\n    pub const USR1 = 10;\n    pub const SEGV = 11;\n    pub const USR2 = 12;\n    pub const PIPE = 13;\n    pub const ALRM = 14;\n    pub const TERM = 15;\n    pub const STKFLT = 16;\n    pub const CHLD = 17;\n    pub const CONT = 18;\n    pub const STOP = 19;\n    pub const TSTP = 20;\n    pub const TTIN = 21;\n    pub const TTOU = 22;\n    pub const URG = 23;\n    pub const XCPU = 24;\n    pub const XFSZ = 25;\n    pub const VTALRM = 26;\n    pub const PROF = 27;\n    pub const WINCH = 28;\n    pub const IO = 29;\n    pub const POLL = 29;\n    pub const PWR = 30;\n    pub const SYS = 31;\n    pub const UNUSED = SIG.SYS;\n\n    pub const ERR = @as(?Sigaction.handler_fn, @ptrFromInt(maxInt(usize)));\n    pub const DFL = @as(?Sigaction.handler_fn, @ptrFromInt(0));\n    pub const IGN = @as(?Sigaction.handler_fn, @ptrFromInt(1));\n}"},{"code":"if (is_mips) 2 else 1"},{"code":"if (is_mips) 1 else 2"},{"code":"if (is_sparc) 0o20000000 else 0o2000000"},{"code":"if (is_mips) 0o200 else if (is_sparc) 0o40000 else 0o4000"},{"code":"if (is_mips) struct {\n        pub const DEBUG = 1;\n        pub const REUSEADDR = 0x0004;\n        pub const KEEPALIVE = 0x0008;\n        pub const DONTROUTE = 0x0010;\n        pub const BROADCAST = 0x0020;\n        pub const LINGER = 0x0080;\n        pub const OOBINLINE = 0x0100;\n        pub const REUSEPORT = 0x0200;\n        pub const SNDBUF = 0x1001;\n        pub const RCVBUF = 0x1002;\n        pub const SNDLOWAT = 0x1003;\n        pub const RCVLOWAT = 0x1004;\n        pub const RCVTIMEO = 0x1006;\n        pub const SNDTIMEO = 0x1005;\n        pub const ERROR = 0x1007;\n        pub const TYPE = 0x1008;\n        pub const ACCEPTCONN = 0x1009;\n        pub const PROTOCOL = 0x1028;\n        pub const DOMAIN = 0x1029;\n        pub const NO_CHECK = 11;\n        pub const PRIORITY = 12;\n        pub const BSDCOMPAT = 14;\n        pub const PASSCRED = 17;\n        pub const PEERCRED = 18;\n        pub const PEERSEC = 30;\n        pub const SNDBUFFORCE = 31;\n        pub const RCVBUFFORCE = 33;\n        pub const SECURITY_AUTHENTICATION = 22;\n        pub const SECURITY_ENCRYPTION_TRANSPORT = 23;\n        pub const SECURITY_ENCRYPTION_NETWORK = 24;\n        pub const BINDTODEVICE = 25;\n        pub const ATTACH_FILTER = 26;\n        pub const DETACH_FILTER = 27;\n        pub const GET_FILTER = ATTACH_FILTER;\n        pub const PEERNAME = 28;\n        pub const TIMESTAMP_OLD = 29;\n        pub const PASSSEC = 34;\n        pub const TIMESTAMPNS_OLD = 35;\n        pub const MARK = 36;\n        pub const TIMESTAMPING_OLD = 37;\n        pub const RXQ_OVFL = 40;\n        pub const WIFI_STATUS = 41;\n        pub const PEEK_OFF = 42;\n        pub const NOFCS = 43;\n        pub const LOCK_FILTER = 44;\n        pub const SELECT_ERR_QUEUE = 45;\n        pub const BUSY_POLL = 46;\n        pub const MAX_PACING_RATE = 47;\n        pub const BPF_EXTENSIONS = 48;\n        pub const INCOMING_CPU = 49;\n        pub const ATTACH_BPF = 50;\n        pub const DETACH_BPF = DETACH_FILTER;\n        pub const ATTACH_REUSEPORT_CBPF = 51;\n        pub const ATTACH_REUSEPORT_EBPF = 52;\n        pub const CNX_ADVICE = 53;\n        pub const MEMINFO = 55;\n        pub const INCOMING_NAPI_ID = 56;\n        pub const COOKIE = 57;\n        pub const PEERGROUPS = 59;\n        pub const ZEROCOPY = 60;\n        pub const TXTIME = 61;\n        pub const BINDTOIFINDEX = 62;\n        pub const TIMESTAMP_NEW = 63;\n        pub const TIMESTAMPNS_NEW = 64;\n        pub const TIMESTAMPING_NEW = 65;\n        pub const RCVTIMEO_NEW = 66;\n        pub const SNDTIMEO_NEW = 67;\n        pub const DETACH_REUSEPORT_BPF = 68;\n    } else if (is_ppc or is_ppc64) struct {\n        pub const DEBUG = 1;\n        pub const REUSEADDR = 2;\n        pub const TYPE = 3;\n        pub const ERROR = 4;\n        pub const DONTROUTE = 5;\n        pub const BROADCAST = 6;\n        pub const SNDBUF = 7;\n        pub const RCVBUF = 8;\n        pub const KEEPALIVE = 9;\n        pub const OOBINLINE = 10;\n        pub const NO_CHECK = 11;\n        pub const PRIORITY = 12;\n        pub const LINGER = 13;\n        pub const BSDCOMPAT = 14;\n        pub const REUSEPORT = 15;\n        pub const RCVLOWAT = 16;\n        pub const SNDLOWAT = 17;\n        pub const RCVTIMEO = 18;\n        pub const SNDTIMEO = 19;\n        pub const PASSCRED = 20;\n        pub const PEERCRED = 21;\n        pub const ACCEPTCONN = 30;\n        pub const PEERSEC = 31;\n        pub const SNDBUFFORCE = 32;\n        pub const RCVBUFFORCE = 33;\n        pub const PROTOCOL = 38;\n        pub const DOMAIN = 39;\n        pub const SECURITY_AUTHENTICATION = 22;\n        pub const SECURITY_ENCRYPTION_TRANSPORT = 23;\n        pub const SECURITY_ENCRYPTION_NETWORK = 24;\n        pub const BINDTODEVICE = 25;\n        pub const ATTACH_FILTER = 26;\n        pub const DETACH_FILTER = 27;\n        pub const GET_FILTER = ATTACH_FILTER;\n        pub const PEERNAME = 28;\n        pub const TIMESTAMP_OLD = 29;\n        pub const PASSSEC = 34;\n        pub const TIMESTAMPNS_OLD = 35;\n        pub const MARK = 36;\n        pub const TIMESTAMPING_OLD = 37;\n        pub const RXQ_OVFL = 40;\n        pub const WIFI_STATUS = 41;\n        pub const PEEK_OFF = 42;\n        pub const NOFCS = 43;\n        pub const LOCK_FILTER = 44;\n        pub const SELECT_ERR_QUEUE = 45;\n        pub const BUSY_POLL = 46;\n        pub const MAX_PACING_RATE = 47;\n        pub const BPF_EXTENSIONS = 48;\n        pub const INCOMING_CPU = 49;\n        pub const ATTACH_BPF = 50;\n        pub const DETACH_BPF = DETACH_FILTER;\n        pub const ATTACH_REUSEPORT_CBPF = 51;\n        pub const ATTACH_REUSEPORT_EBPF = 52;\n        pub const CNX_ADVICE = 53;\n        pub const MEMINFO = 55;\n        pub const INCOMING_NAPI_ID = 56;\n        pub const COOKIE = 57;\n        pub const PEERGROUPS = 59;\n        pub const ZEROCOPY = 60;\n        pub const TXTIME = 61;\n        pub const BINDTOIFINDEX = 62;\n        pub const TIMESTAMP_NEW = 63;\n        pub const TIMESTAMPNS_NEW = 64;\n        pub const TIMESTAMPING_NEW = 65;\n        pub const RCVTIMEO_NEW = 66;\n        pub const SNDTIMEO_NEW = 67;\n        pub const DETACH_REUSEPORT_BPF = 68;\n    } else if (is_sparc) struct {\n        pub const DEBUG = 1;\n        pub const REUSEADDR = 4;\n        pub const TYPE = 4104;\n        pub const ERROR = 4103;\n        pub const DONTROUTE = 16;\n        pub const BROADCAST = 32;\n        pub const SNDBUF = 4097;\n        pub const RCVBUF = 4098;\n        pub const KEEPALIVE = 8;\n        pub const OOBINLINE = 256;\n        pub const NO_CHECK = 11;\n        pub const PRIORITY = 12;\n        pub const LINGER = 128;\n        pub const BSDCOMPAT = 1024;\n        pub const REUSEPORT = 512;\n        pub const PASSCRED = 2;\n        pub const PEERCRED = 64;\n        pub const RCVLOWAT = 2048;\n        pub const SNDLOWAT = 4096;\n        pub const RCVTIMEO = 8192;\n        pub const SNDTIMEO = 16384;\n        pub const ACCEPTCONN = 32768;\n        pub const PEERSEC = 30;\n        pub const SNDBUFFORCE = 4106;\n        pub const RCVBUFFORCE = 4107;\n        pub const PROTOCOL = 4136;\n        pub const DOMAIN = 4137;\n        pub const SECURITY_AUTHENTICATION = 20481;\n        pub const SECURITY_ENCRYPTION_TRANSPORT = 20482;\n        pub const SECURITY_ENCRYPTION_NETWORK = 20484;\n        pub const BINDTODEVICE = 13;\n        pub const ATTACH_FILTER = 26;\n        pub const DETACH_FILTER = 27;\n        pub const GET_FILTER = 26;\n        pub const PEERNAME = 28;\n        pub const TIMESTAMP_OLD = 29;\n        pub const PASSSEC = 31;\n        pub const TIMESTAMPNS_OLD = 33;\n        pub const MARK = 34;\n        pub const TIMESTAMPING_OLD = 35;\n        pub const RXQ_OVFL = 36;\n        pub const WIFI_STATUS = 37;\n        pub const PEEK_OFF = 38;\n        pub const NOFCS = 39;\n        pub const LOCK_FILTER = 40;\n        pub const SELECT_ERR_QUEUE = 41;\n        pub const BUSY_POLL = 48;\n        pub const MAX_PACING_RATE = 49;\n        pub const BPF_EXTENSIONS = 50;\n        pub const INCOMING_CPU = 51;\n        pub const ATTACH_BPF = 52;\n        pub const DETACH_BPF = 27;\n        pub const ATTACH_REUSEPORT_CBPF = 53;\n        pub const ATTACH_REUSEPORT_EBPF = 54;\n        pub const CNX_ADVICE = 55;\n        pub const MEMINFO = 57;\n        pub const INCOMING_NAPI_ID = 58;\n        pub const COOKIE = 59;\n        pub const PEERGROUPS = 61;\n        pub const ZEROCOPY = 62;\n        pub const TXTIME = 63;\n        pub const BINDTOIFINDEX = 65;\n        pub const TIMESTAMP_NEW = 70;\n        pub const TIMESTAMPNS_NEW = 66;\n        pub const TIMESTAMPING_NEW = 67;\n        pub const RCVTIMEO_NEW = 68;\n        pub const SNDTIMEO_NEW = 69;\n        pub const DETACH_REUSEPORT_BPF = 71;\n    } else struct {\n        pub const DEBUG = 1;\n        pub const REUSEADDR = 2;\n        pub const TYPE = 3;\n        pub const ERROR = 4;\n        pub const DONTROUTE = 5;\n        pub const BROADCAST = 6;\n        pub const SNDBUF = 7;\n        pub const RCVBUF = 8;\n        pub const KEEPALIVE = 9;\n        pub const OOBINLINE = 10;\n        pub const NO_CHECK = 11;\n        pub const PRIORITY = 12;\n        pub const LINGER = 13;\n        pub const BSDCOMPAT = 14;\n        pub const REUSEPORT = 15;\n        pub const PASSCRED = 16;\n        pub const PEERCRED = 17;\n        pub const RCVLOWAT = 18;\n        pub const SNDLOWAT = 19;\n        pub const RCVTIMEO = 20;\n        pub const SNDTIMEO = 21;\n        pub const ACCEPTCONN = 30;\n        pub const PEERSEC = 31;\n        pub const SNDBUFFORCE = 32;\n        pub const RCVBUFFORCE = 33;\n        pub const PROTOCOL = 38;\n        pub const DOMAIN = 39;\n        pub const SECURITY_AUTHENTICATION = 22;\n        pub const SECURITY_ENCRYPTION_TRANSPORT = 23;\n        pub const SECURITY_ENCRYPTION_NETWORK = 24;\n        pub const BINDTODEVICE = 25;\n        pub const ATTACH_FILTER = 26;\n        pub const DETACH_FILTER = 27;\n        pub const GET_FILTER = ATTACH_FILTER;\n        pub const PEERNAME = 28;\n        pub const TIMESTAMP_OLD = 29;\n        pub const PASSSEC = 34;\n        pub const TIMESTAMPNS_OLD = 35;\n        pub const MARK = 36;\n        pub const TIMESTAMPING_OLD = 37;\n        pub const RXQ_OVFL = 40;\n        pub const WIFI_STATUS = 41;\n        pub const PEEK_OFF = 42;\n        pub const NOFCS = 43;\n        pub const LOCK_FILTER = 44;\n        pub const SELECT_ERR_QUEUE = 45;\n        pub const BUSY_POLL = 46;\n        pub const MAX_PACING_RATE = 47;\n        pub const BPF_EXTENSIONS = 48;\n        pub const INCOMING_CPU = 49;\n        pub const ATTACH_BPF = 50;\n        pub const DETACH_BPF = DETACH_FILTER;\n        pub const ATTACH_REUSEPORT_CBPF = 51;\n        pub const ATTACH_REUSEPORT_EBPF = 52;\n        pub const CNX_ADVICE = 53;\n        pub const MEMINFO = 55;\n        pub const INCOMING_NAPI_ID = 56;\n        pub const COOKIE = 57;\n        pub const PEERGROUPS = 59;\n        pub const ZEROCOPY = 60;\n        pub const TXTIME = 61;\n        pub const BINDTOIFINDEX = 62;\n        pub const TIMESTAMP_NEW = 63;\n        pub const TIMESTAMPNS_NEW = 64;\n        pub const TIMESTAMPING_NEW = 65;\n        pub const RCVTIMEO_NEW = 66;\n        pub const SNDTIMEO_NEW = 67;\n        pub const DETACH_REUSEPORT_BPF = 68;\n    }"},{"code":"if (is_mips or is_sparc) 65535 else 1"},{"code":"if (is_mips) 0x540D else 0x5401"},{"code":"if (is_mips) 0x540e else 0x5402"},{"code":"if (is_mips) 0x540f else 0x5403"},{"code":"if (is_mips) 0x5410 else 0x5404"},{"code":"if (is_mips) 0x5401 else 0x5405"},{"code":"if (is_mips) 0x5402 else 0x5406"},{"code":"if (is_mips) 0x5403 else 0x5407"},{"code":"if (is_mips) 0x5404 else 0x5408"},{"code":"if (is_mips) 0x5405 else 0x5409"},{"code":"if (is_mips) 0x5406 else 0x540A"},{"code":"if (is_mips) 0x5407 else 0x540B"},{"code":"if (is_mips) 0x740d else 0x540C"},{"code":"if (is_mips) 0x740e else 0x540D"},{"code":"if (is_mips) 0x7472 else 0x540E"},{"code":"if (is_mips) 0x5472 else 0x540F"},{"code":"if (is_mips) 0x741d else 0x5410"},{"code":"if (is_mips) 0x7472 else 0x5411"},{"code":"if (is_mips) 0x5472 else 0x5412"},{"code":"if (is_mips or is_ppc64) 0x40087468 else 0x5413"},{"code":"if (is_mips or is_ppc64) 0x80087467 else 0x5414"},{"code":"if (is_mips) 0x741d else 0x5415"},{"code":"if (is_mips) 0x741b else 0x5416"},{"code":"if (is_mips) 0x741c else 0x5417"},{"code":"if (is_mips) 0x741a else 0x5418"},{"code":"if (is_mips) 0x5481 else 0x5419"},{"code":"if (is_mips) 0x5482 else 0x541A"},{"code":"if (is_mips) 0x467F else 0x541B"},{"code":"if (is_mips) 0x5483 else 0x541C"},{"code":"if (is_mips) IOCTL.IOW('t', 120, c_int) else 0x541D"},{"code":"if (is_mips) 0x5484 else 0x541E"},{"code":"if (is_mips) 0x5485 else 0x541F"},{"code":"if (is_mips) 0x5470 else 0x5420"},{"code":"if (is_mips) 0x667e else 0x5421"},{"code":"if (is_mips) 0x5471 else 0x5422"},{"code":"if (is_mips) 0x7401 else 0x5423"},{"code":"if (is_mips) 0x7400 else 0x5424"},{"code":"if (is_mips) 0x5486 else 0x5425"},{"code":"if (is_mips) 0x7416 else 0x5429"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (is_mips) 0x004 else 0x100"},{"code":"if (is_mips) 0x100 else 0x200"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"if (is_mips) 128 else 65"},{"code":"switch (native_arch) {\n    .mips, .mipsel => extern struct {\n        flags: c_uint,\n        handler: k_sigaction_funcs.handler,\n        mask: [4]c_ulong,\n        restorer: k_sigaction_funcs.restorer,\n    },\n    .mips64, .mips64el => extern struct {\n        flags: c_uint,\n        handler: k_sigaction_funcs.handler,\n        mask: [2]c_ulong,\n        restorer: k_sigaction_funcs.restorer,\n    },\n    else => extern struct {\n        handler: k_sigaction_funcs.handler,\n        flags: c_ulong,\n        restorer: k_sigaction_funcs.restorer,\n        mask: [2]c_uint,\n    },\n}"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"field call"},{"code":"switch (native_arch) {\n    .x86, .x86_64, .arm, .mipsel => 2048,\n    .aarch64 => 5120,\n    else => @compileError(\"MINSIGSTKSZ not defined for this architecture\"),\n}"},{"code":"switch (native_arch) {\n    .x86, .x86_64, .arm, .mipsel => 8192,\n    .aarch64 => 16384,\n    else => @compileError(\"SIGSTKSZ not defined for this architecture\"),\n}"},{"code":"typeof_log2_int_type"},{"code":"if (is_mips)\n    // IRIX compatible stack_t\n    extern struct {\n        sp: [*]u8,\n        size: usize,\n        flags: i32,\n    }\nelse\n    extern struct {\n        sp: [*]u8,\n        flags: i32,\n        size: usize,\n    }"},{"code":"if (is_mips)\n    extern struct {\n        signo: i32,\n        code: i32,\n        errno: i32,\n        fields: siginfo_fields_union,\n    }\nelse\n    extern struct {\n        signo: i32,\n        errno: i32,\n        code: i32,\n        fields: siginfo_fields_union,\n    }"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"switch (native_arch) {\n    .powerpc, .powerpc64, .powerpc64le => struct {\n        pub const INTR = 0;\n        pub const QUIT = 1;\n        pub const ERASE = 2;\n        pub const KILL = 3;\n        pub const EOF = 4;\n        pub const MIN = 5;\n        pub const EOL = 6;\n        pub const TIME = 7;\n        pub const EOL2 = 8;\n        pub const SWTC = 9;\n        pub const WERASE = 10;\n        pub const REPRINT = 11;\n        pub const SUSP = 12;\n        pub const START = 13;\n        pub const STOP = 14;\n        pub const LNEXT = 15;\n        pub const DISCARD = 16;\n    },\n    .sparc, .sparc64 => struct {\n        pub const INTR = 0;\n        pub const QUIT = 1;\n        pub const ERASE = 2;\n        pub const KILL = 3;\n        pub const EOF = 4;\n        pub const EOL = 5;\n        pub const EOL2 = 6;\n        pub const SWTC = 7;\n        pub const START = 8;\n        pub const STOP = 9;\n        pub const SUSP = 10;\n        pub const DSUSP = 11;\n        pub const REPRINT = 12;\n        pub const DISCARD = 13;\n        pub const WERASE = 14;\n        pub const LNEXT = 15;\n        pub const MIN = EOF;\n        pub const TIME = EOL;\n    },\n    .mips, .mipsel, .mips64, .mips64el => struct {\n        pub const INTR = 0;\n        pub const QUIT = 1;\n        pub const ERASE = 2;\n        pub const KILL = 3;\n        pub const MIN = 4;\n        pub const TIME = 5;\n        pub const EOL2 = 6;\n        pub const SWTC = 7;\n        pub const SWTCH = 7;\n        pub const START = 8;\n        pub const STOP = 9;\n        pub const SUSP = 10;\n        pub const REPRINT = 12;\n        pub const DISCARD = 13;\n        pub const WERASE = 14;\n        pub const LNEXT = 15;\n        pub const EOF = 16;\n        pub const EOL = 17;\n    },\n    else => struct {\n        pub const INTR = 0;\n        pub const QUIT = 1;\n        pub const ERASE = 2;\n        pub const KILL = 3;\n        pub const EOF = 4;\n        pub const TIME = 5;\n        pub const MIN = 6;\n        pub const SWTC = 7;\n        pub const START = 8;\n        pub const STOP = 9;\n        pub const SUSP = 10;\n        pub const EOL = 11;\n        pub const REPRINT = 12;\n        pub const DISCARD = 13;\n        pub const WERASE = 14;\n        pub const LNEXT = 15;\n        pub const EOL2 = 16;\n    },\n}"},{"code":"if (native_arch.isMIPS() or native_arch.isSPARC())\n    arch_bits.rlimit_resource\nelse\n    enum(c_int) {\n        /// Per-process CPU limit, in seconds.\n        CPU,\n\n        /// Largest file that can be created, in bytes.\n        FSIZE,\n\n        /// Maximum size of data segment, in bytes.\n        DATA,\n\n        /// Maximum size of stack segment, in bytes.\n        STACK,\n\n        /// Largest core file that can be created, in bytes.\n        CORE,\n\n        /// Largest resident set size, in bytes.\n        /// This affects swapping; processes that are exceeding their\n        /// resident set size will be more likely to have physical memory\n        /// taken from them.\n        RSS,\n\n        /// Number of processes.\n        NPROC,\n\n        /// Number of open files.\n        NOFILE,\n\n        /// Locked-in-memory address space.\n        MEMLOCK,\n\n        /// Address space limit.\n        AS,\n\n        /// Maximum number of file locks.\n        LOCKS,\n\n        /// Maximum number of pending signals.\n        SIGPENDING,\n\n        /// Maximum bytes in POSIX message queues.\n        MSGQUEUE,\n\n        /// Maximum nice priority allowed to raise to.\n        /// Nice levels 19 .. -20 correspond to 0 .. 39\n        /// values of this resource limit.\n        NICE,\n\n        /// Maximum realtime priority allowed for non-priviledged\n        /// processes.\n        RTPRIO,\n\n        /// Maximum CPU time in µs that a process scheduled under a real-time\n        /// scheduling policy may consume without making a blocking system\n        /// call before being forcibly descheduled.\n        RTTIME,\n\n        _,\n    }"},{"code":"switch (native_arch) {\n    .s390x => if (@typeInfo(usize).Int.bits == 64) struct {\n        pub const NORMAL = 0;\n        pub const RANDOM = 1;\n        pub const SEQUENTIAL = 2;\n        pub const WILLNEED = 3;\n        pub const DONTNEED = 6;\n        pub const NOREUSE = 7;\n    } else struct {\n        pub const NORMAL = 0;\n        pub const RANDOM = 1;\n        pub const SEQUENTIAL = 2;\n        pub const WILLNEED = 3;\n        pub const DONTNEED = 4;\n        pub const NOREUSE = 5;\n    },\n    else => struct {\n        pub const NORMAL = 0;\n        pub const RANDOM = 1;\n        pub const SEQUENTIAL = 2;\n        pub const WILLNEED = 3;\n        pub const DONTNEED = 4;\n        pub const NOREUSE = 5;\n    },\n}"},{"code":"if (@sizeOf(usize) >= 8) timespec else extern struct {\n    tv_sec: i64,\n    tv_nsec: i64,\n}"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"switch (native_arch) {\n            .x86 => .X86,\n            .x86_64 => .X86_64,\n            .aarch64 => .AARCH64,\n            .arm, .thumb => .ARM,\n            .riscv64 => .RISCV64,\n            .sparc64 => .SPARC64,\n            .mips => .MIPS,\n            .mipsel => .MIPSEL,\n            .powerpc => .PPC,\n            .powerpc64 => .PPC64,\n            .powerpc64le => .PPC64LE,\n            else => @compileError(\"unsupported architecture\"),\n        }"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"switch (builtin.cpu.arch) {\n    .x86_64 => @import(\"plan9/x86_64.zig\"),\n    else => @compileError(\"more plan9 syscall implementations (needs more inline asm in stage2\"),\n}"},{"code":"TUnion"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"protocol"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"typeof_log2_int_type"},{"code":"switch (@import(\"builtin\").target.cpu.arch) {\n    .x86_64 => .Win64,\n    else => .C,\n}"},{"code":"if (builtin.link_libc) -2 else 3"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"switch (native_arch) {\n    .x86 => struct {\n        pub const FLOATING_SAVE_AREA = extern struct {\n            ControlWord: DWORD,\n            StatusWord: DWORD,\n            TagWord: DWORD,\n            ErrorOffset: DWORD,\n            ErrorSelector: DWORD,\n            DataOffset: DWORD,\n            DataSelector: DWORD,\n            RegisterArea: [80]BYTE,\n            Cr0NpxState: DWORD,\n        };\n\n        pub const CONTEXT = extern struct {\n            ContextFlags: DWORD,\n            Dr0: DWORD,\n            Dr1: DWORD,\n            Dr2: DWORD,\n            Dr3: DWORD,\n            Dr6: DWORD,\n            Dr7: DWORD,\n            FloatSave: FLOATING_SAVE_AREA,\n            SegGs: DWORD,\n            SegFs: DWORD,\n            SegEs: DWORD,\n            SegDs: DWORD,\n            Edi: DWORD,\n            Esi: DWORD,\n            Ebx: DWORD,\n            Edx: DWORD,\n            Ecx: DWORD,\n            Eax: DWORD,\n            Ebp: DWORD,\n            Eip: DWORD,\n            SegCs: DWORD,\n            EFlags: DWORD,\n            Esp: DWORD,\n            SegSs: DWORD,\n            ExtendedRegisters: [512]BYTE,\n\n            pub fn getRegs(ctx: *const CONTEXT) struct { bp: usize, ip: usize } {\n                return .{ .bp = ctx.Ebp, .ip = ctx.Eip };\n            }\n        };\n    },\n    .x86_64 => struct {\n        pub const M128A = extern struct {\n            Low: ULONGLONG,\n            High: LONGLONG,\n        };\n\n        pub const XMM_SAVE_AREA32 = extern struct {\n            ControlWord: WORD,\n            StatusWord: WORD,\n            TagWord: BYTE,\n            Reserved1: BYTE,\n            ErrorOpcode: WORD,\n            ErrorOffset: DWORD,\n            ErrorSelector: WORD,\n            Reserved2: WORD,\n            DataOffset: DWORD,\n            DataSelector: WORD,\n            Reserved3: WORD,\n            MxCsr: DWORD,\n            MxCsr_Mask: DWORD,\n            FloatRegisters: [8]M128A,\n            XmmRegisters: [16]M128A,\n            Reserved4: [96]BYTE,\n        };\n\n        pub const CONTEXT = extern struct {\n            P1Home: DWORD64 align(16),\n            P2Home: DWORD64,\n            P3Home: DWORD64,\n            P4Home: DWORD64,\n            P5Home: DWORD64,\n            P6Home: DWORD64,\n            ContextFlags: DWORD,\n            MxCsr: DWORD,\n            SegCs: WORD,\n            SegDs: WORD,\n            SegEs: WORD,\n            SegFs: WORD,\n            SegGs: WORD,\n            SegSs: WORD,\n            EFlags: DWORD,\n            Dr0: DWORD64,\n            Dr1: DWORD64,\n            Dr2: DWORD64,\n            Dr3: DWORD64,\n            Dr6: DWORD64,\n            Dr7: DWORD64,\n            Rax: DWORD64,\n            Rcx: DWORD64,\n            Rdx: DWORD64,\n            Rbx: DWORD64,\n            Rsp: DWORD64,\n            Rbp: DWORD64,\n            Rsi: DWORD64,\n            Rdi: DWORD64,\n            R8: DWORD64,\n            R9: DWORD64,\n            R10: DWORD64,\n            R11: DWORD64,\n            R12: DWORD64,\n            R13: DWORD64,\n            R14: DWORD64,\n            R15: DWORD64,\n            Rip: DWORD64,\n            DUMMYUNIONNAME: extern union {\n                FltSave: XMM_SAVE_AREA32,\n                FloatSave: XMM_SAVE_AREA32,\n                DUMMYSTRUCTNAME: extern struct {\n                    Header: [2]M128A,\n                    Legacy: [8]M128A,\n                    Xmm0: M128A,\n                    Xmm1: M128A,\n                    Xmm2: M128A,\n                    Xmm3: M128A,\n                    Xmm4: M128A,\n                    Xmm5: M128A,\n                    Xmm6: M128A,\n                    Xmm7: M128A,\n                    Xmm8: M128A,\n                    Xmm9: M128A,\n                    Xmm10: M128A,\n                    Xmm11: M128A,\n                    Xmm12: M128A,\n                    Xmm13: M128A,\n                    Xmm14: M128A,\n                    Xmm15: M128A,\n                },\n            },\n            VectorRegister: [26]M128A,\n            VectorControl: DWORD64,\n            DebugControl: DWORD64,\n            LastBranchToRip: DWORD64,\n            LastBranchFromRip: DWORD64,\n            LastExceptionToRip: DWORD64,\n            LastExceptionFromRip: DWORD64,\n\n            pub fn getRegs(ctx: *const CONTEXT) struct { bp: usize, ip: usize, sp: usize } {\n                return .{ .bp = ctx.Rbp, .ip = ctx.Rip, .sp = ctx.Rsp };\n            }\n\n            pub fn setIp(ctx: *CONTEXT, ip: usize) void {\n                ctx.Rip = ip;\n            }\n\n            pub fn setSp(ctx: *CONTEXT, sp: usize) void {\n                ctx.Rsp = sp;\n            }\n        };\n\n        pub const RUNTIME_FUNCTION = extern struct {\n            BeginAddress: DWORD,\n            EndAddress: DWORD,\n            UnwindData: DWORD,\n        };\n\n        pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {\n            FloatingContext: [16]?*M128A,\n            IntegerContext: [16]?*ULONG64,\n        };\n    },\n    .aarch64 => struct {\n        pub const NEON128 = extern union {\n            DUMMYSTRUCTNAME: extern struct {\n                Low: ULONGLONG,\n                High: LONGLONG,\n            },\n            D: [2]f64,\n            S: [4]f32,\n            H: [8]WORD,\n            B: [16]BYTE,\n        };\n\n        pub const CONTEXT = extern struct {\n            ContextFlags: ULONG align(16),\n            Cpsr: ULONG,\n            DUMMYUNIONNAME: extern union {\n                DUMMYSTRUCTNAME: extern struct {\n                    X0: DWORD64,\n                    X1: DWORD64,\n                    X2: DWORD64,\n                    X3: DWORD64,\n                    X4: DWORD64,\n                    X5: DWORD64,\n                    X6: DWORD64,\n                    X7: DWORD64,\n                    X8: DWORD64,\n                    X9: DWORD64,\n                    X10: DWORD64,\n                    X11: DWORD64,\n                    X12: DWORD64,\n                    X13: DWORD64,\n                    X14: DWORD64,\n                    X15: DWORD64,\n                    X16: DWORD64,\n                    X17: DWORD64,\n                    X18: DWORD64,\n                    X19: DWORD64,\n                    X20: DWORD64,\n                    X21: DWORD64,\n                    X22: DWORD64,\n                    X23: DWORD64,\n                    X24: DWORD64,\n                    X25: DWORD64,\n                    X26: DWORD64,\n                    X27: DWORD64,\n                    X28: DWORD64,\n                    Fp: DWORD64,\n                    Lr: DWORD64,\n                },\n                X: [31]DWORD64,\n            },\n            Sp: DWORD64,\n            Pc: DWORD64,\n            V: [32]NEON128,\n            Fpcr: DWORD,\n            Fpsr: DWORD,\n            Bcr: [8]DWORD,\n            Bvr: [8]DWORD64,\n            Wcr: [2]DWORD,\n            Wvr: [2]DWORD64,\n\n            pub fn getRegs(ctx: *const CONTEXT) struct { bp: usize, ip: usize, sp: usize } {\n                return .{\n                    .bp = ctx.DUMMYUNIONNAME.DUMMYSTRUCTNAME.Fp,\n                    .ip = ctx.Pc,\n                    .sp = ctx.Sp,\n                };\n            }\n\n            pub fn setIp(ctx: *CONTEXT, ip: usize) void {\n                ctx.Pc = ip;\n            }\n\n            pub fn setSp(ctx: *CONTEXT, sp: usize) void {\n                ctx.Sp = sp;\n            }\n        };\n\n        pub const RUNTIME_FUNCTION = extern struct {\n            BeginAddress: DWORD,\n            DUMMYUNIONNAME: extern union {\n                UnwindData: DWORD,\n                DUMMYSTRUCTNAME: packed struct {\n                    Flag: u2,\n                    FunctionLength: u11,\n                    RegF: u3,\n                    RegI: u4,\n                    H: u1,\n                    CR: u2,\n                    FrameSize: u9,\n                },\n            },\n        };\n\n        pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {\n            X19: ?*DWORD64,\n            X20: ?*DWORD64,\n            X21: ?*DWORD64,\n            X22: ?*DWORD64,\n            X23: ?*DWORD64,\n            X24: ?*DWORD64,\n            X25: ?*DWORD64,\n            X26: ?*DWORD64,\n            X27: ?*DWORD64,\n            X28: ?*DWORD64,\n            Fp: ?*DWORD64,\n            Lr: ?*DWORD64,\n            D8: ?*DWORD64,\n            D9: ?*DWORD64,\n            D10: ?*DWORD64,\n            D11: ?*DWORD64,\n            D12: ?*DWORD64,\n            D13: ?*DWORD64,\n            D14: ?*DWORD64,\n            D15: ?*DWORD64,\n        };\n    },\n    else => struct {},\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"if (@sizeOf(usize) == @sizeOf(u64))\n    extern struct {\n        wVersion: WORD,\n        wHighVersion: WORD,\n        iMaxSockets: u16,\n        iMaxUdpDg: u16,\n        lpVendorInfo: *u8,\n        szDescription: [WSADESCRIPTION_LEN + 1]u8,\n        szSystemStatus: [WSASYS_STATUS_LEN + 1]u8,\n    }\nelse\n    extern struct {\n        wVersion: WORD,\n        wHighVersion: WORD,\n        szDescription: [WSADESCRIPTION_LEN + 1]u8,\n        szSystemStatus: [WSASYS_STATUS_LEN + 1]u8,\n        iMaxSockets: u16,\n        iMaxUdpDg: u16,\n        lpVendorInfo: *u8,\n    }"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"if (native_arch == .x86)\n    .Stdcall\nelse\n    .C"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"switch (builtin.target.cpu.arch.endian()) {\n        .big => [16]u6{\n            0,  2,  4,  6,\n            9,  11, 14, 16,\n            19, 21, 24, 26,\n            28, 30, 32, 34,\n        },\n        .little => [16]u6{\n            6,  4,  2,  0,\n            11, 9,  16, 14,\n            19, 21, 24, 26,\n            28, 30, 32, 34,\n        },\n    }"},{"code":"field call"},{"code":"switch (@sizeOf(usize)) {\n            4 => 0x22,\n            8 => 0x3C,\n            else => unreachable,\n        }"},{"code":"FileInformationType"},{"code":"if (@hasDecl(root, \"os\") and root.os != @This())\n    root.os.system\nelse if (builtin.link_libc or is_windows)\n    std.c\nelse switch (builtin.os.tag) {\n    .linux => linux,\n    .plan9 => plan9,\n    .wasi => wasi,\n    .uefi => uefi,\n    else => struct {},\n}"},{"code":"switch (builtin.os.tag) {\n    .openbsd => system.HW,\n    else => .{},\n}"},{"code":"switch (builtin.os.tag) {\n    // We want to expose the POSIX-like OFLAGS, so we use std.c.wasi.O instead\n    // of std.os.wasi.O, which is for non-POSIX-like `wasi.path_open`, etc.\n    .wasi => std.c.O,\n    else => system.O,\n}"},{"code":"if (builtin.os.tag == .windows) windows.ws2_32.SOCKET else fd_t"},{"code":"if (builtin.link_libc) undefined else switch (builtin.os.tag) {\n    .windows => @compileError(\"argv isn't supported on Windows: use std.process.argsAlloc instead\"),\n    .wasi => @compileError(\"argv isn't supported on WASI: use std.process.argsAlloc instead\"),\n    else => undefined,\n}"},{"code":"field call"},{"code":"field call"},{"code":"switch (builtin.os.tag) {\n    .linux => union(linux.LINUX_REBOOT.CMD) {\n        RESTART: void,\n        HALT: void,\n        CAD_ON: void,\n        CAD_OFF: void,\n        POWER_OFF: void,\n        RESTART2: [*:0]const u8,\n        SW_SUSPEND: void,\n        KEXEC: void,\n    },\n    else => @compileError(\"Unsupported OS\"),\n}"},{"code":"arg0_expand"},{"code":"switch (arg0_expand) {\n        .expand => [*:null]?[*:0]const u8,\n        .no_expand => [*:null]const ?[*:0]const u8,\n    }"},{"code":"context"},{"code":"Error"},{"code":"Error"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"f"},{"code":"func call"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"strategy"},{"code":"switch (builtin.os.tag) {\n        .windows => ArgIteratorWindows,\n        .wasi => if (builtin.link_libc) ArgIteratorPosix else ArgIteratorWasi,\n        else => ArgIteratorPosix,\n    }"},{"code":"switch (builtin.os.tag) {\n    .windows, .haiku, .wasi => false,\n    else => true,\n}"},{"code":"switch (builtin.os.tag) {\n    .wasi, .watchos, .tvos => false,\n    else => true,\n}"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"context"},{"code":"key"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"key"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"key"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"key"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"context"},{"code":"T"},{"code":"T"},{"code":"VectorType"},{"code":"func call"},{"code":"field call"},{"code":"VectorType"},{"code":"func call"},{"code":"field call"},{"code":"len"},{"code":"T"},{"code":"len"},{"code":"vec"},{"code":"field call"},{"code":"a"},{"code":"func call"},{"code":"b"},{"code":"func call"},{"code":"a"},{"code":"field call"},{"code":"vecs"},{"code":"func call"},{"code":"vecs"},{"code":"vecs"},{"code":"field call"},{"code":"vec_count"},{"code":"interlaced"},{"code":"func call"},{"code":"vec_count"},{"code":"interlaced"},{"code":"field call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"func call"},{"code":"count"},{"code":"vec"},{"code":"field call"},{"code":"a"},{"code":"b"},{"code":"func call"},{"code":"a"},{"code":"b"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"field call"},{"code":"vec"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"field call"},{"code":"vec"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"vec"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"field call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"field call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"field call"},{"code":"vec"},{"code":"func call"},{"code":"vec"},{"code":"vec"},{"code":"if (ErrorType == void) @TypeOf(vec) else ErrorType!@TypeOf(vec)"},{"code":"vec"},{"code":"field call"},{"code":"if (ErrorType == void) @TypeOf(vec) else ErrorType!@TypeOf(vec)"},{"code":"vec"},{"code":"field call"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"reader"},{"code":"func call"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"ReaderType"},{"code":"field call"},{"code":"field call"},{"code":"if (std.debug.sys_can_stack_trace) 16 else 0"},{"code":"field call"},{"code":"b: {\n    if (!builtin.is_test)\n        @compileError(\"Cannot use testing allocator outside of test block\");\n    break :b std.heap.GeneralPurposeAllocator(.{}){};\n}"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"sentinel"},{"code":"T"},{"code":"T"},{"code":"sentinel"},{"code":"field call"},{"code":"T"},{"code":"T"},{"code":"switch (builtin.os.tag) {\n        .wasi => builtin.link_libc,\n        .windows, .uefi => false,\n        else => true,\n    }"},{"code":"if (is_posix) os.timespec else u64"},{"code":"field call"},{"code":"utf8CodepointSequenceLength(c) catch |err|\n        @compileError(@errorName(err))"},{"code":"calcUtf16LeLen(utf8) catch unreachable"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"x"},{"code":"field call"},{"code":"field call"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"struct_init_field_type"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"UnderlyingWriter"},{"code":"field call"},{"code":"UnderlyingWriter"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"Feature"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"int_64"},{"code":"field call"},{"code":"list: {\n    @setEvalBranchQuota(3000);\n    break :list std.ComptimeStringMap(@This(), .{\n        .{\n            \"@addWithOverflow\",\n            .{\n                .tag = .add_with_overflow,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@addrSpaceCast\",\n            .{\n                .tag = .addrspace_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@alignCast\",\n            .{\n                .tag = .align_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@alignOf\",\n            .{\n                .tag = .align_of,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@as\",\n            .{\n                .tag = .as,\n                .needs_mem_loc = .forward1,\n                .eval_to_error = .maybe,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@asyncCall\",\n            .{\n                .tag = .async_call,\n                .param_count = 4,\n            },\n        },\n        .{\n            \"@atomicLoad\",\n            .{\n                .tag = .atomic_load,\n                .param_count = 3,\n            },\n        },\n        .{\n            \"@atomicRmw\",\n            .{\n                .tag = .atomic_rmw,\n                .param_count = 5,\n            },\n        },\n        .{\n            \"@atomicStore\",\n            .{\n                .tag = .atomic_store,\n                .param_count = 4,\n            },\n        },\n        .{\n            \"@bitCast\",\n            .{\n                .tag = .bit_cast,\n                .needs_mem_loc = .forward0,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@bitOffsetOf\",\n            .{\n                .tag = .bit_offset_of,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@intFromBool\",\n            .{\n                .tag = .int_from_bool,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@bitSizeOf\",\n            .{\n                .tag = .bit_size_of,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@breakpoint\",\n            .{\n                .tag = .breakpoint,\n                .param_count = 0,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@mulAdd\",\n            .{\n                .tag = .mul_add,\n                .param_count = 4,\n            },\n        },\n        .{\n            \"@byteSwap\",\n            .{\n                .tag = .byte_swap,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@bitReverse\",\n            .{\n                .tag = .bit_reverse,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@offsetOf\",\n            .{\n                .tag = .offset_of,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@call\",\n            .{\n                .tag = .call,\n                .needs_mem_loc = .always,\n                .eval_to_error = .maybe,\n                .param_count = 3,\n            },\n        },\n        .{\n            \"@cDefine\",\n            .{\n                .tag = .c_define,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@cImport\",\n            .{\n                .tag = .c_import,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@cInclude\",\n            .{\n                .tag = .c_include,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@clz\",\n            .{\n                .tag = .clz,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@cmpxchgStrong\",\n            .{\n                .tag = .cmpxchg_strong,\n                .param_count = 6,\n            },\n        },\n        .{\n            \"@cmpxchgWeak\",\n            .{\n                .tag = .cmpxchg_weak,\n                .param_count = 6,\n            },\n        },\n        .{\n            \"@compileError\",\n            .{\n                .tag = .compile_error,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@compileLog\",\n            .{\n                .tag = .compile_log,\n                .param_count = null,\n            },\n        },\n        .{\n            \"@constCast\",\n            .{\n                .tag = .const_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@ctz\",\n            .{\n                .tag = .ctz,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@cUndef\",\n            .{\n                .tag = .c_undef,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@cVaArg\", .{\n                .tag = .c_va_arg,\n                .param_count = 2,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@cVaCopy\", .{\n                .tag = .c_va_copy,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@cVaEnd\", .{\n                .tag = .c_va_end,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@cVaStart\", .{\n                .tag = .c_va_start,\n                .param_count = 0,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@divExact\",\n            .{\n                .tag = .div_exact,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@divFloor\",\n            .{\n                .tag = .div_floor,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@divTrunc\",\n            .{\n                .tag = .div_trunc,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@embedFile\",\n            .{\n                .tag = .embed_file,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@intFromEnum\",\n            .{\n                .tag = .int_from_enum,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@errorName\",\n            .{\n                .tag = .error_name,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@errorReturnTrace\",\n            .{\n                .tag = .error_return_trace,\n                .param_count = 0,\n            },\n        },\n        .{\n            \"@intFromError\",\n            .{\n                .tag = .int_from_error,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@errorCast\",\n            .{\n                .tag = .error_cast,\n                .eval_to_error = .always,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@export\",\n            .{\n                .tag = .@\"export\",\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@extern\",\n            .{\n                .tag = .@\"extern\",\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@fence\",\n            .{\n                .tag = .fence,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@field\",\n            .{\n                .tag = .field,\n                .needs_mem_loc = .always,\n                .eval_to_error = .maybe,\n                .param_count = 2,\n                .allows_lvalue = true,\n            },\n        },\n        .{\n            \"@fieldParentPtr\",\n            .{\n                .tag = .field_parent_ptr,\n                .param_count = 3,\n            },\n        },\n        .{\n            \"@floatCast\",\n            .{\n                .tag = .float_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@intFromFloat\",\n            .{\n                .tag = .int_from_float,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@frame\",\n            .{\n                .tag = .frame,\n                .param_count = 0,\n            },\n        },\n        .{\n            \"@Frame\",\n            .{\n                .tag = .Frame,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@frameAddress\",\n            .{\n                .tag = .frame_address,\n                .param_count = 0,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@frameSize\",\n            .{\n                .tag = .frame_size,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@hasDecl\",\n            .{\n                .tag = .has_decl,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@hasField\",\n            .{\n                .tag = .has_field,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@import\",\n            .{\n                .tag = .import,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@inComptime\",\n            .{\n                .tag = .in_comptime,\n                .param_count = 0,\n            },\n        },\n        .{\n            \"@intCast\",\n            .{\n                .tag = .int_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@enumFromInt\",\n            .{\n                .tag = .enum_from_int,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@errorFromInt\",\n            .{\n                .tag = .error_from_int,\n                .eval_to_error = .always,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@floatFromInt\",\n            .{\n                .tag = .float_from_int,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@ptrFromInt\",\n            .{\n                .tag = .ptr_from_int,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@max\",\n            .{\n                .tag = .max,\n                .param_count = null,\n            },\n        },\n        .{\n            \"@memcpy\",\n            .{\n                .tag = .memcpy,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@memset\",\n            .{\n                .tag = .memset,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@min\",\n            .{\n                .tag = .min,\n                .param_count = null,\n            },\n        },\n        .{\n            \"@wasmMemorySize\",\n            .{\n                .tag = .wasm_memory_size,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@wasmMemoryGrow\",\n            .{\n                .tag = .wasm_memory_grow,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@mod\",\n            .{\n                .tag = .mod,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@mulWithOverflow\",\n            .{\n                .tag = .mul_with_overflow,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@panic\",\n            .{\n                .tag = .panic,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@popCount\",\n            .{\n                .tag = .pop_count,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@prefetch\",\n            .{\n                .tag = .prefetch,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@ptrCast\",\n            .{\n                .tag = .ptr_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@intFromPtr\",\n            .{\n                .tag = .int_from_ptr,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@rem\",\n            .{\n                .tag = .rem,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@returnAddress\",\n            .{\n                .tag = .return_address,\n                .param_count = 0,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@select\",\n            .{\n                .tag = .select,\n                .param_count = 4,\n            },\n        },\n        .{\n            \"@setAlignStack\",\n            .{\n                .tag = .set_align_stack,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@setCold\",\n            .{\n                .tag = .set_cold,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@setEvalBranchQuota\",\n            .{\n                .tag = .set_eval_branch_quota,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@setFloatMode\",\n            .{\n                .tag = .set_float_mode,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@setRuntimeSafety\",\n            .{\n                .tag = .set_runtime_safety,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@shlExact\",\n            .{\n                .tag = .shl_exact,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@shlWithOverflow\",\n            .{\n                .tag = .shl_with_overflow,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@shrExact\",\n            .{\n                .tag = .shr_exact,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@shuffle\",\n            .{\n                .tag = .shuffle,\n                .param_count = 4,\n            },\n        },\n        .{\n            \"@sizeOf\",\n            .{\n                .tag = .size_of,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@splat\",\n            .{\n                .tag = .splat,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@reduce\",\n            .{\n                .tag = .reduce,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@src\",\n            .{\n                .tag = .src,\n                .needs_mem_loc = .always,\n                .param_count = 0,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@sqrt\",\n            .{\n                .tag = .sqrt,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@sin\",\n            .{\n                .tag = .sin,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@cos\",\n            .{\n                .tag = .cos,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@tan\",\n            .{\n                .tag = .tan,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@exp\",\n            .{\n                .tag = .exp,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@exp2\",\n            .{\n                .tag = .exp2,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@log\",\n            .{\n                .tag = .log,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@log2\",\n            .{\n                .tag = .log2,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@log10\",\n            .{\n                .tag = .log10,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@abs\",\n            .{\n                .tag = .abs,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@floor\",\n            .{\n                .tag = .floor,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@ceil\",\n            .{\n                .tag = .ceil,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@trunc\",\n            .{\n                .tag = .trunc,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@round\",\n            .{\n                .tag = .round,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@subWithOverflow\",\n            .{\n                .tag = .sub_with_overflow,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@tagName\",\n            .{\n                .tag = .tag_name,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@This\",\n            .{\n                .tag = .This,\n                .param_count = 0,\n            },\n        },\n        .{\n            \"@trap\",\n            .{\n                .tag = .trap,\n                .param_count = 0,\n            },\n        },\n        .{\n            \"@truncate\",\n            .{\n                .tag = .truncate,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@Type\",\n            .{\n                .tag = .Type,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@typeInfo\",\n            .{\n                .tag = .type_info,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@typeName\",\n            .{\n                .tag = .type_name,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@TypeOf\",\n            .{\n                .tag = .TypeOf,\n                .param_count = null,\n            },\n        },\n        .{\n            \"@unionInit\",\n            .{\n                .tag = .union_init,\n                .needs_mem_loc = .always,\n                .param_count = 3,\n            },\n        },\n        .{\n            \"@Vector\",\n            .{\n                .tag = .Vector,\n                .param_count = 2,\n            },\n        },\n        .{\n            \"@volatileCast\",\n            .{\n                .tag = .volatile_cast,\n                .param_count = 1,\n            },\n        },\n        .{\n            \"@workItemId\", .{\n                .tag = .work_item_id,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@workGroupSize\",\n            .{\n                .tag = .work_group_size,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n        .{\n            \"@workGroupId\",\n            .{\n                .tag = .work_group_id,\n                .param_count = 1,\n                .illegal_outside_function = true,\n            },\n        },\n    });\n}"},{"code":"func call"},{"code":"a"},{"code":"b"},{"code":"DestType"},{"code":"DestType"},{"code":"DestType"},{"code":"DestType"},{"code":"SuffixType"},{"code":"number"},{"code":"base"},{"code":"func call"},{"code":"numerator"},{"code":"denominator"},{"code":"n"},{"code":"func call"},{"code":"number"},{"code":"func call"},{"code":"n"},{"code":"func call"},{"code":"n"},{"code":"func call"},{"code":"n"},{"code":"func call"},{"code":"sample"},{"code":"a"},{"code":"switch (@typeInfo(@TypeOf(a))) {\n        .Type => a,\n        .Fn => |fn_info| fn_info.return_type orelse void,\n        else => |info| @compileError(\"Unexpected argument type: \" ++ @tagName(info)),\n    }"},{"code":"T"},{"code":"switch (T) {\n        bool, u8, i8, c_short => c_int,\n        c_ushort => if (@sizeOf(c_ushort) == @sizeOf(c_int)) c_uint else c_int,\n        c_int, c_uint, c_long, c_ulong, c_longlong, c_ulonglong => T,\n        else => if (T == comptime_int) {\n            @compileError(\"Cannot promote `\" ++ @typeName(T) ++ \"`; a fixed-size number type is required\");\n        } else if (@typeInfo(T) == .Int) {\n            @compileError(\"Cannot promote `\" ++ @typeName(T) ++ \"`; a C ABI type is required\");\n        } else {\n            @compileError(\"Attempted to promote invalid type `\" ++ @typeName(T) ++ \"`\");\n        },\n    }"},{"code":"T"},{"code":"switch (T) {\n        c_int => c_uint,\n        c_long => c_ulong,\n        c_longlong => c_ulonglong,\n        else => @compileError(\"Cannot convert `\" ++ @typeName(T) ++ \"` to unsigned\"),\n    }"},{"code":"if (a_signed) A_Promoted else B_Promoted"},{"code":"func call"},{"code":"a"},{"code":"b"},{"code":"func call"},{"code":"a"},{"code":"b"},{"code":"func call"},{"code":"field call"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"array_init_elem_type"},{"code":"field call"},{"code":"if (native_arch.isMIPS()) \"__start\" else \"_start\""},{"code":"if (@hasDecl(root, \"std_options\")) root.std_options else .{}"},{"code":"Os"},{"code":"chdirC"},{"code":"c_import"},{"code":"struct_init_ref"},{"code":"f"},{"code":"func call"},{"code":"block_comptime"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"typeof_log2_int_type"},{"code":"tag"},{"code":"if (tag == VARTAG_INDIRECT) @import(\"std\").zig.c_translation.sizeof(varatt_indirect) else if (VARTAG_IS_EXPANDED(tag)) @import(\"std\").zig.c_translation.sizeof(varatt_expanded) else if (tag == VARTAG_ONDISK) @import(\"std\").zig.c_translation.sizeof(varatt_external) else blk_2: {\n    break :blk_2 @as(c_int, 0);\n}"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"block_comptime"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"field call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"func call"},{"code":"PTR"},{"code":"len"},{"code":"func call"},{"code":"PTR"},{"code":"len"},{"code":"func call"},{"code":"PTR"},{"code":"len"},{"code":"func call"},{"code":"PTR"},{"code":"tag"},{"code":"func call"},{"code":"if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) else VARSIZE_4B(PTR)"},{"code":"if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) - VARHDRSZ_EXTERNAL else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) - VARHDRSZ_SHORT else VARSIZE_4B(PTR) - VARHDRSZ"},{"code":"if (VARATT_IS_1B(PTR)) VARDATA_1B(PTR) else VARDATA_4B(PTR)"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"block_comptime"},{"code":"PTR"},{"code":"field call"},{"code":"typeof_log2_int_type"},{"code":"toast_pointer"},{"code":"toast_pointer"},{"code":"typeof_log2_int_type"},{"code":"toast_pointer"},{"code":"func call"},{"code":"toast_pointer"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"C"},{"code":"T"},{"code":"T"},{"code":"block_comptime"},{"code":"switch (@typeInfo(T)) {\n        .Void => Void,\n        .Bool => Bool,\n        .Int => |i| switch (i.signedness) {\n            .signed => switch (i.bits) {\n                8 => Int8,\n                16 => Int16,\n                32 => Int32,\n                64 => Int64,\n                else => @compileError(\"unsupported int type\"),\n            },\n            .unsigned => switch (i.bits) {\n                8 => UInt8,\n                16 => UInt16,\n                32 => UInt32,\n                64 => UInt64,\n                else => @compileError(\"unsupported unsigned int type\"),\n            },\n        },\n        .Float => |f| switch (f.bits) {\n            32 => Float32,\n            64 => Float64,\n            else => @compileError(\"unsupported float type\"),\n        },\n        .Optional => |opt| OptConv(find(opt.child)),\n        .Array => @compileLog(\"fixed size arrays not supported\"),\n        .Pointer => |ptrInfo| blk: {\n            if (ptrInfo.size != .Slice or ptrInfo.child != u8) {\n                @compileError(\"unsupported ptr type\");\n            }\n            if (ptrInfo.sentinel) |_| {\n                break :blk SliceU8Z;\n            } else {\n                break :blk SliceU8;\n            }\n        },\n        else => {\n            @compileLog(\"type:\", T);\n            @compileError(\"type not supported\");\n        },\n    }"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"argNum"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"struct_init_field_type"},{"code":"f"},{"code":"f"},{"code":"func call"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"func call"},{"code":"field call"},{"code":"block_comptime"},{"code":"switch (@typeInfo(T)) {\n        .Bool => boolconv,\n        .Int => |i| switch (i.signedness) {\n            .signed => switch (i.bits) {\n                8 => i8conv,\n                16 => i16conv,\n                32 => i32conv,\n                64 => i64conv,\n                else => {\n                    @compileLog(\"type:\", T);\n                    @compileError(\"unsupported int type\");\n                },\n            },\n            .unsigned => switch (i.bits) {\n                8 => u8conv,\n                16 => u16conv,\n                32 => u32conv,\n                else => {\n                    @compileLog(\"type:\", T);\n                    @compileError(\"unsupported unsigned int type\");\n                },\n            },\n        },\n        .Float => |f| switch (f.bits) {\n            32 => f32conv,\n            64 => f64conv,\n            else => {\n                @compileLog(\"type:\", T);\n                @compileError(\"unsupported float type\");\n            },\n        },\n        .Optional => |opt| optconv(find(opt.child)),\n        .Array => @compileLog(\"fixed size arrays not supported\"),\n        .Pointer => |ptrInfo| blk: {\n            if (ptrInfo.size != .Slice or ptrInfo.child != u8) {\n                @compileLog(\"type:\", T);\n                @compileError(\"unsupported ptr type\");\n            }\n            if (ptrInfo.sentinel) |_| {\n                break :blk textzconv;\n            } else {\n                break :blk textconv;\n            }\n        },\n        else => {\n            @compileLog(\"type:\", T);\n            @compileError(\"type not supported\");\n        },\n    }"},{"code":"C"},{"code":"C"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"func call"},{"code":"oid"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"func call"},{"code":"oid"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"func call"},{"code":"func call"},{"code":"Self"},{"code":"field call"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"Self"},{"code":"field call"},{"code":"field call"},{"code":"pattern"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"field call"},{"code":"field call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"T"},{"code":"func call"},{"code":"T"},{"code":"func call"},{"code":"T"}];